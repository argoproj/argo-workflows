// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"time"

	"github.com/argoproj/argo-workflows/v3/pkg/apis/workflow/v1alpha1"
	"github.com/argoproj/argo-workflows/v3/server/utils"
	mock "github.com/stretchr/testify/mock"
	"k8s.io/apimachinery/pkg/labels"
)

// NewWorkflowArchive creates a new instance of WorkflowArchive. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWorkflowArchive(t interface {
	mock.TestingT
	Cleanup(func())
}) *WorkflowArchive {
	mock := &WorkflowArchive{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// WorkflowArchive is an autogenerated mock type for the WorkflowArchive type
type WorkflowArchive struct {
	mock.Mock
}

type WorkflowArchive_Expecter struct {
	mock *mock.Mock
}

func (_m *WorkflowArchive) EXPECT() *WorkflowArchive_Expecter {
	return &WorkflowArchive_Expecter{mock: &_m.Mock}
}

// ArchiveWorkflow provides a mock function for the type WorkflowArchive
func (_mock *WorkflowArchive) ArchiveWorkflow(ctx context.Context, wf *v1alpha1.Workflow) error {
	ret := _mock.Called(ctx, wf)

	if len(ret) == 0 {
		panic("no return value specified for ArchiveWorkflow")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Workflow) error); ok {
		r0 = returnFunc(ctx, wf)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowArchive_ArchiveWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ArchiveWorkflow'
type WorkflowArchive_ArchiveWorkflow_Call struct {
	*mock.Call
}

// ArchiveWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - wf *v1alpha1.Workflow
func (_e *WorkflowArchive_Expecter) ArchiveWorkflow(ctx interface{}, wf interface{}) *WorkflowArchive_ArchiveWorkflow_Call {
	return &WorkflowArchive_ArchiveWorkflow_Call{Call: _e.mock.On("ArchiveWorkflow", ctx, wf)}
}

func (_c *WorkflowArchive_ArchiveWorkflow_Call) Run(run func(ctx context.Context, wf *v1alpha1.Workflow)) *WorkflowArchive_ArchiveWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Workflow
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Workflow)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowArchive_ArchiveWorkflow_Call) Return(err error) *WorkflowArchive_ArchiveWorkflow_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowArchive_ArchiveWorkflow_Call) RunAndReturn(run func(ctx context.Context, wf *v1alpha1.Workflow) error) *WorkflowArchive_ArchiveWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// CountWorkflows provides a mock function for the type WorkflowArchive
func (_mock *WorkflowArchive) CountWorkflows(ctx context.Context, options utils.ListOptions) (int64, error) {
	ret := _mock.Called(ctx, options)

	if len(ret) == 0 {
		panic("no return value specified for CountWorkflows")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, utils.ListOptions) (int64, error)); ok {
		return returnFunc(ctx, options)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, utils.ListOptions) int64); ok {
		r0 = returnFunc(ctx, options)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, utils.ListOptions) error); ok {
		r1 = returnFunc(ctx, options)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowArchive_CountWorkflows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountWorkflows'
type WorkflowArchive_CountWorkflows_Call struct {
	*mock.Call
}

// CountWorkflows is a helper method to define mock.On call
//   - ctx context.Context
//   - options utils.ListOptions
func (_e *WorkflowArchive_Expecter) CountWorkflows(ctx interface{}, options interface{}) *WorkflowArchive_CountWorkflows_Call {
	return &WorkflowArchive_CountWorkflows_Call{Call: _e.mock.On("CountWorkflows", ctx, options)}
}

func (_c *WorkflowArchive_CountWorkflows_Call) Run(run func(ctx context.Context, options utils.ListOptions)) *WorkflowArchive_CountWorkflows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 utils.ListOptions
		if args[1] != nil {
			arg1 = args[1].(utils.ListOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowArchive_CountWorkflows_Call) Return(n int64, err error) *WorkflowArchive_CountWorkflows_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *WorkflowArchive_CountWorkflows_Call) RunAndReturn(run func(ctx context.Context, options utils.ListOptions) (int64, error)) *WorkflowArchive_CountWorkflows_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteExpiredWorkflows provides a mock function for the type WorkflowArchive
func (_mock *WorkflowArchive) DeleteExpiredWorkflows(ctx context.Context, ttl time.Duration) error {
	ret := _mock.Called(ctx, ttl)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExpiredWorkflows")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) error); ok {
		r0 = returnFunc(ctx, ttl)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowArchive_DeleteExpiredWorkflows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteExpiredWorkflows'
type WorkflowArchive_DeleteExpiredWorkflows_Call struct {
	*mock.Call
}

// DeleteExpiredWorkflows is a helper method to define mock.On call
//   - ctx context.Context
//   - ttl time.Duration
func (_e *WorkflowArchive_Expecter) DeleteExpiredWorkflows(ctx interface{}, ttl interface{}) *WorkflowArchive_DeleteExpiredWorkflows_Call {
	return &WorkflowArchive_DeleteExpiredWorkflows_Call{Call: _e.mock.On("DeleteExpiredWorkflows", ctx, ttl)}
}

func (_c *WorkflowArchive_DeleteExpiredWorkflows_Call) Run(run func(ctx context.Context, ttl time.Duration)) *WorkflowArchive_DeleteExpiredWorkflows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowArchive_DeleteExpiredWorkflows_Call) Return(err error) *WorkflowArchive_DeleteExpiredWorkflows_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowArchive_DeleteExpiredWorkflows_Call) RunAndReturn(run func(ctx context.Context, ttl time.Duration) error) *WorkflowArchive_DeleteExpiredWorkflows_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWorkflow provides a mock function for the type WorkflowArchive
func (_mock *WorkflowArchive) DeleteWorkflow(ctx context.Context, uid string) error {
	ret := _mock.Called(ctx, uid)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflow")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, uid)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowArchive_DeleteWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWorkflow'
type WorkflowArchive_DeleteWorkflow_Call struct {
	*mock.Call
}

// DeleteWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - uid string
func (_e *WorkflowArchive_Expecter) DeleteWorkflow(ctx interface{}, uid interface{}) *WorkflowArchive_DeleteWorkflow_Call {
	return &WorkflowArchive_DeleteWorkflow_Call{Call: _e.mock.On("DeleteWorkflow", ctx, uid)}
}

func (_c *WorkflowArchive_DeleteWorkflow_Call) Run(run func(ctx context.Context, uid string)) *WorkflowArchive_DeleteWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowArchive_DeleteWorkflow_Call) Return(err error) *WorkflowArchive_DeleteWorkflow_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowArchive_DeleteWorkflow_Call) RunAndReturn(run func(ctx context.Context, uid string) error) *WorkflowArchive_DeleteWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflow provides a mock function for the type WorkflowArchive
func (_mock *WorkflowArchive) GetWorkflow(ctx context.Context, uid string, namespace string, name string) (*v1alpha1.Workflow, error) {
	ret := _mock.Called(ctx, uid, namespace, name)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflow")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, uid, namespace, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, uid, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, uid, namespace, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowArchive_GetWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflow'
type WorkflowArchive_GetWorkflow_Call struct {
	*mock.Call
}

// GetWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - uid string
//   - namespace string
//   - name string
func (_e *WorkflowArchive_Expecter) GetWorkflow(ctx interface{}, uid interface{}, namespace interface{}, name interface{}) *WorkflowArchive_GetWorkflow_Call {
	return &WorkflowArchive_GetWorkflow_Call{Call: _e.mock.On("GetWorkflow", ctx, uid, namespace, name)}
}

func (_c *WorkflowArchive_GetWorkflow_Call) Run(run func(ctx context.Context, uid string, namespace string, name string)) *WorkflowArchive_GetWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *WorkflowArchive_GetWorkflow_Call) Return(workflow *v1alpha1.Workflow, err error) *WorkflowArchive_GetWorkflow_Call {
	_c.Call.Return(workflow, err)
	return _c
}

func (_c *WorkflowArchive_GetWorkflow_Call) RunAndReturn(run func(ctx context.Context, uid string, namespace string, name string) (*v1alpha1.Workflow, error)) *WorkflowArchive_GetWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowForEstimator provides a mock function for the type WorkflowArchive
func (_mock *WorkflowArchive) GetWorkflowForEstimator(ctx context.Context, namespace string, requirements []labels.Requirement) (*v1alpha1.Workflow, error) {
	ret := _mock.Called(ctx, namespace, requirements)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowForEstimator")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []labels.Requirement) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, namespace, requirements)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []labels.Requirement) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, namespace, requirements)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, []labels.Requirement) error); ok {
		r1 = returnFunc(ctx, namespace, requirements)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowArchive_GetWorkflowForEstimator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowForEstimator'
type WorkflowArchive_GetWorkflowForEstimator_Call struct {
	*mock.Call
}

// GetWorkflowForEstimator is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - requirements []labels.Requirement
func (_e *WorkflowArchive_Expecter) GetWorkflowForEstimator(ctx interface{}, namespace interface{}, requirements interface{}) *WorkflowArchive_GetWorkflowForEstimator_Call {
	return &WorkflowArchive_GetWorkflowForEstimator_Call{Call: _e.mock.On("GetWorkflowForEstimator", ctx, namespace, requirements)}
}

func (_c *WorkflowArchive_GetWorkflowForEstimator_Call) Run(run func(ctx context.Context, namespace string, requirements []labels.Requirement)) *WorkflowArchive_GetWorkflowForEstimator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []labels.Requirement
		if args[2] != nil {
			arg2 = args[2].([]labels.Requirement)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *WorkflowArchive_GetWorkflowForEstimator_Call) Return(workflow *v1alpha1.Workflow, err error) *WorkflowArchive_GetWorkflowForEstimator_Call {
	_c.Call.Return(workflow, err)
	return _c
}

func (_c *WorkflowArchive_GetWorkflowForEstimator_Call) RunAndReturn(run func(ctx context.Context, namespace string, requirements []labels.Requirement) (*v1alpha1.Workflow, error)) *WorkflowArchive_GetWorkflowForEstimator_Call {
	_c.Call.Return(run)
	return _c
}

// IsEnabled provides a mock function for the type WorkflowArchive
func (_mock *WorkflowArchive) IsEnabled() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsEnabled")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// WorkflowArchive_IsEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsEnabled'
type WorkflowArchive_IsEnabled_Call struct {
	*mock.Call
}

// IsEnabled is a helper method to define mock.On call
func (_e *WorkflowArchive_Expecter) IsEnabled() *WorkflowArchive_IsEnabled_Call {
	return &WorkflowArchive_IsEnabled_Call{Call: _e.mock.On("IsEnabled")}
}

func (_c *WorkflowArchive_IsEnabled_Call) Run(run func()) *WorkflowArchive_IsEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *WorkflowArchive_IsEnabled_Call) Return(b bool) *WorkflowArchive_IsEnabled_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *WorkflowArchive_IsEnabled_Call) RunAndReturn(run func() bool) *WorkflowArchive_IsEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// ListWorkflows provides a mock function for the type WorkflowArchive
func (_mock *WorkflowArchive) ListWorkflows(ctx context.Context, options utils.ListOptions) (v1alpha1.Workflows, error) {
	ret := _mock.Called(ctx, options)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflows")
	}

	var r0 v1alpha1.Workflows
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, utils.ListOptions) (v1alpha1.Workflows, error)); ok {
		return returnFunc(ctx, options)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, utils.ListOptions) v1alpha1.Workflows); ok {
		r0 = returnFunc(ctx, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.Workflows)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, utils.ListOptions) error); ok {
		r1 = returnFunc(ctx, options)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowArchive_ListWorkflows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWorkflows'
type WorkflowArchive_ListWorkflows_Call struct {
	*mock.Call
}

// ListWorkflows is a helper method to define mock.On call
//   - ctx context.Context
//   - options utils.ListOptions
func (_e *WorkflowArchive_Expecter) ListWorkflows(ctx interface{}, options interface{}) *WorkflowArchive_ListWorkflows_Call {
	return &WorkflowArchive_ListWorkflows_Call{Call: _e.mock.On("ListWorkflows", ctx, options)}
}

func (_c *WorkflowArchive_ListWorkflows_Call) Run(run func(ctx context.Context, options utils.ListOptions)) *WorkflowArchive_ListWorkflows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 utils.ListOptions
		if args[1] != nil {
			arg1 = args[1].(utils.ListOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowArchive_ListWorkflows_Call) Return(workflows v1alpha1.Workflows, err error) *WorkflowArchive_ListWorkflows_Call {
	_c.Call.Return(workflows, err)
	return _c
}

func (_c *WorkflowArchive_ListWorkflows_Call) RunAndReturn(run func(ctx context.Context, options utils.ListOptions) (v1alpha1.Workflows, error)) *WorkflowArchive_ListWorkflows_Call {
	_c.Call.Return(run)
	return _c
}

// ListWorkflowsLabelKeys provides a mock function for the type WorkflowArchive
func (_mock *WorkflowArchive) ListWorkflowsLabelKeys(ctx context.Context) (*v1alpha1.LabelKeys, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflowsLabelKeys")
	}

	var r0 *v1alpha1.LabelKeys
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*v1alpha1.LabelKeys, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *v1alpha1.LabelKeys); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.LabelKeys)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowArchive_ListWorkflowsLabelKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWorkflowsLabelKeys'
type WorkflowArchive_ListWorkflowsLabelKeys_Call struct {
	*mock.Call
}

// ListWorkflowsLabelKeys is a helper method to define mock.On call
//   - ctx context.Context
func (_e *WorkflowArchive_Expecter) ListWorkflowsLabelKeys(ctx interface{}) *WorkflowArchive_ListWorkflowsLabelKeys_Call {
	return &WorkflowArchive_ListWorkflowsLabelKeys_Call{Call: _e.mock.On("ListWorkflowsLabelKeys", ctx)}
}

func (_c *WorkflowArchive_ListWorkflowsLabelKeys_Call) Run(run func(ctx context.Context)) *WorkflowArchive_ListWorkflowsLabelKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *WorkflowArchive_ListWorkflowsLabelKeys_Call) Return(labelKeys *v1alpha1.LabelKeys, err error) *WorkflowArchive_ListWorkflowsLabelKeys_Call {
	_c.Call.Return(labelKeys, err)
	return _c
}

func (_c *WorkflowArchive_ListWorkflowsLabelKeys_Call) RunAndReturn(run func(ctx context.Context) (*v1alpha1.LabelKeys, error)) *WorkflowArchive_ListWorkflowsLabelKeys_Call {
	_c.Call.Return(run)
	return _c
}

// ListWorkflowsLabelValues provides a mock function for the type WorkflowArchive
func (_mock *WorkflowArchive) ListWorkflowsLabelValues(ctx context.Context, key string) (*v1alpha1.LabelValues, error) {
	ret := _mock.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflowsLabelValues")
	}

	var r0 *v1alpha1.LabelValues
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*v1alpha1.LabelValues, error)); ok {
		return returnFunc(ctx, key)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *v1alpha1.LabelValues); ok {
		r0 = returnFunc(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.LabelValues)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowArchive_ListWorkflowsLabelValues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWorkflowsLabelValues'
type WorkflowArchive_ListWorkflowsLabelValues_Call struct {
	*mock.Call
}

// ListWorkflowsLabelValues is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *WorkflowArchive_Expecter) ListWorkflowsLabelValues(ctx interface{}, key interface{}) *WorkflowArchive_ListWorkflowsLabelValues_Call {
	return &WorkflowArchive_ListWorkflowsLabelValues_Call{Call: _e.mock.On("ListWorkflowsLabelValues", ctx, key)}
}

func (_c *WorkflowArchive_ListWorkflowsLabelValues_Call) Run(run func(ctx context.Context, key string)) *WorkflowArchive_ListWorkflowsLabelValues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowArchive_ListWorkflowsLabelValues_Call) Return(labelValues *v1alpha1.LabelValues, err error) *WorkflowArchive_ListWorkflowsLabelValues_Call {
	_c.Call.Return(labelValues, err)
	return _c
}

func (_c *WorkflowArchive_ListWorkflowsLabelValues_Call) RunAndReturn(run func(ctx context.Context, key string) (*v1alpha1.LabelValues, error)) *WorkflowArchive_ListWorkflowsLabelValues_Call {
	_c.Call.Return(run)
	return _c
}
