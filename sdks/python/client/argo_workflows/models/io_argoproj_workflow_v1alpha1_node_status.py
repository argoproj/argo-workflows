# coding: utf-8

"""
    Argo Workflows API

    Argo Workflows is an open source container-native workflow engine for orchestrating parallel jobs on Kubernetes. For more information, please see https://argo-workflows.readthedocs.io/en/latest/

    The version of the OpenAPI document: VERSION
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from argo_workflows.models.io_argoproj_workflow_v1alpha1_inputs import IoArgoprojWorkflowV1alpha1Inputs
from argo_workflows.models.io_argoproj_workflow_v1alpha1_memoization_status import IoArgoprojWorkflowV1alpha1MemoizationStatus
from argo_workflows.models.io_argoproj_workflow_v1alpha1_node_flag import IoArgoprojWorkflowV1alpha1NodeFlag
from argo_workflows.models.io_argoproj_workflow_v1alpha1_node_synchronization_status import IoArgoprojWorkflowV1alpha1NodeSynchronizationStatus
from argo_workflows.models.io_argoproj_workflow_v1alpha1_outputs import IoArgoprojWorkflowV1alpha1Outputs
from argo_workflows.models.io_argoproj_workflow_v1alpha1_template_ref import IoArgoprojWorkflowV1alpha1TemplateRef
from typing import Optional, Set
from typing_extensions import Self

class IoArgoprojWorkflowV1alpha1NodeStatus(BaseModel):
    """
    NodeStatus contains status information about an individual node in the workflow
    """ # noqa: E501
    boundary_id: Optional[StrictStr] = Field(default=None, description="BoundaryID indicates the node ID of the associated template root node in which this node belongs to", alias="boundaryID")
    children: Optional[List[StrictStr]] = Field(default=None, description="Children is a list of child node IDs")
    daemoned: Optional[StrictBool] = Field(default=None, description="Daemoned tracks whether or not this node was daemoned and need to be terminated")
    display_name: Optional[StrictStr] = Field(default=None, description="DisplayName is a human readable representation of the node. Unique within a template boundary", alias="displayName")
    estimated_duration: Optional[StrictInt] = Field(default=None, description="EstimatedDuration in seconds.", alias="estimatedDuration")
    finished_at: Optional[datetime] = Field(default=None, description="Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.", alias="finishedAt")
    host_node_name: Optional[StrictStr] = Field(default=None, description="HostNodeName name of the Kubernetes node on which the Pod is running, if applicable", alias="hostNodeName")
    id: StrictStr = Field(description="ID is a unique identifier of a node within the worklow It is implemented as a hash of the node name, which makes the ID deterministic")
    inputs: Optional[IoArgoprojWorkflowV1alpha1Inputs] = None
    memoization_status: Optional[IoArgoprojWorkflowV1alpha1MemoizationStatus] = Field(default=None, alias="memoizationStatus")
    message: Optional[StrictStr] = Field(default=None, description="A human readable message indicating details about why the node is in this condition.")
    name: StrictStr = Field(description="Name is unique name in the node tree used to generate the node ID")
    node_flag: Optional[IoArgoprojWorkflowV1alpha1NodeFlag] = Field(default=None, alias="nodeFlag")
    outbound_nodes: Optional[List[StrictStr]] = Field(default=None, description="OutboundNodes tracks the node IDs which are considered \"outbound\" nodes to a template invocation. For every invocation of a template, there are nodes which we considered as \"outbound\". Essentially, these are last nodes in the execution sequence to run, before the template is considered completed. These nodes are then connected as parents to a following step.  In the case of single pod steps (i.e. container, script, resource templates), this list will be nil since the pod itself is already considered the \"outbound\" node. In the case of DAGs, outbound nodes are the \"target\" tasks (tasks with no children). In the case of steps, outbound nodes are all the containers involved in the last step group. NOTE: since templates are composable, the list of outbound nodes are carried upwards when a DAG/steps template invokes another DAG/steps template. In other words, the outbound nodes of a template, will be a superset of the outbound nodes of its last children.", alias="outboundNodes")
    outputs: Optional[IoArgoprojWorkflowV1alpha1Outputs] = None
    phase: Optional[StrictStr] = Field(default=None, description="Phase a simple, high-level summary of where the node is in its lifecycle. Can be used as a state machine. Will be one of these values \"Pending\", \"Running\" before the node is completed, or \"Succeeded\", \"Skipped\", \"Failed\", \"Error\", or \"Omitted\" as a final state.")
    pod_ip: Optional[StrictStr] = Field(default=None, description="PodIP captures the IP of the pod for daemoned steps", alias="podIP")
    progress: Optional[StrictStr] = Field(default=None, description="Progress to completion")
    resources_duration: Optional[Dict[str, StrictInt]] = Field(default=None, description="ResourcesDuration is indicative, but not accurate, resource duration. This is populated when the nodes completes.", alias="resourcesDuration")
    started_at: Optional[datetime] = Field(default=None, description="Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.", alias="startedAt")
    synchronization_status: Optional[IoArgoprojWorkflowV1alpha1NodeSynchronizationStatus] = Field(default=None, alias="synchronizationStatus")
    template_name: Optional[StrictStr] = Field(default=None, description="TemplateName is the template name which this node corresponds to. Not applicable to virtual nodes (e.g. Retry, StepGroup)", alias="templateName")
    template_ref: Optional[IoArgoprojWorkflowV1alpha1TemplateRef] = Field(default=None, alias="templateRef")
    template_scope: Optional[StrictStr] = Field(default=None, description="TemplateScope is the template scope in which the template of this node was retrieved.", alias="templateScope")
    type: StrictStr = Field(description="Type indicates type of node")
    __properties: ClassVar[List[str]] = ["boundaryID", "children", "daemoned", "displayName", "estimatedDuration", "finishedAt", "hostNodeName", "id", "inputs", "memoizationStatus", "message", "name", "nodeFlag", "outboundNodes", "outputs", "phase", "podIP", "progress", "resourcesDuration", "startedAt", "synchronizationStatus", "templateName", "templateRef", "templateScope", "type"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of IoArgoprojWorkflowV1alpha1NodeStatus from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of inputs
        if self.inputs:
            _dict['inputs'] = self.inputs.to_dict()
        # override the default output from pydantic by calling `to_dict()` of memoization_status
        if self.memoization_status:
            _dict['memoizationStatus'] = self.memoization_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of node_flag
        if self.node_flag:
            _dict['nodeFlag'] = self.node_flag.to_dict()
        # override the default output from pydantic by calling `to_dict()` of outputs
        if self.outputs:
            _dict['outputs'] = self.outputs.to_dict()
        # override the default output from pydantic by calling `to_dict()` of synchronization_status
        if self.synchronization_status:
            _dict['synchronizationStatus'] = self.synchronization_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of template_ref
        if self.template_ref:
            _dict['templateRef'] = self.template_ref.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of IoArgoprojWorkflowV1alpha1NodeStatus from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "boundaryID": obj.get("boundaryID"),
            "children": obj.get("children"),
            "daemoned": obj.get("daemoned"),
            "displayName": obj.get("displayName"),
            "estimatedDuration": obj.get("estimatedDuration"),
            "finishedAt": obj.get("finishedAt"),
            "hostNodeName": obj.get("hostNodeName"),
            "id": obj.get("id"),
            "inputs": IoArgoprojWorkflowV1alpha1Inputs.from_dict(obj["inputs"]) if obj.get("inputs") is not None else None,
            "memoizationStatus": IoArgoprojWorkflowV1alpha1MemoizationStatus.from_dict(obj["memoizationStatus"]) if obj.get("memoizationStatus") is not None else None,
            "message": obj.get("message"),
            "name": obj.get("name"),
            "nodeFlag": IoArgoprojWorkflowV1alpha1NodeFlag.from_dict(obj["nodeFlag"]) if obj.get("nodeFlag") is not None else None,
            "outboundNodes": obj.get("outboundNodes"),
            "outputs": IoArgoprojWorkflowV1alpha1Outputs.from_dict(obj["outputs"]) if obj.get("outputs") is not None else None,
            "phase": obj.get("phase"),
            "podIP": obj.get("podIP"),
            "progress": obj.get("progress"),
            "resourcesDuration": obj.get("resourcesDuration"),
            "startedAt": obj.get("startedAt"),
            "synchronizationStatus": IoArgoprojWorkflowV1alpha1NodeSynchronizationStatus.from_dict(obj["synchronizationStatus"]) if obj.get("synchronizationStatus") is not None else None,
            "templateName": obj.get("templateName"),
            "templateRef": IoArgoprojWorkflowV1alpha1TemplateRef.from_dict(obj["templateRef"]) if obj.get("templateRef") is not None else None,
            "templateScope": obj.get("templateScope"),
            "type": obj.get("type")
        })
        return _obj


