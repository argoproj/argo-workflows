# coding: utf-8

"""
    Argo Workflows API

    Argo Workflows is an open source container-native workflow engine for orchestrating parallel jobs on Kubernetes. For more information, please see https://argo-workflows.readthedocs.io/en/latest/

    The version of the OpenAPI document: VERSION
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from argo_workflows.models.affinity import Affinity
from argo_workflows.models.host_alias import HostAlias
from argo_workflows.models.io_argoproj_workflow_v1alpha1_arguments import IoArgoprojWorkflowV1alpha1Arguments
from argo_workflows.models.io_argoproj_workflow_v1alpha1_artifact_repository_ref import IoArgoprojWorkflowV1alpha1ArtifactRepositoryRef
from argo_workflows.models.io_argoproj_workflow_v1alpha1_executor_config import IoArgoprojWorkflowV1alpha1ExecutorConfig
from argo_workflows.models.io_argoproj_workflow_v1alpha1_lifecycle_hook import IoArgoprojWorkflowV1alpha1LifecycleHook
from argo_workflows.models.io_argoproj_workflow_v1alpha1_metadata import IoArgoprojWorkflowV1alpha1Metadata
from argo_workflows.models.io_argoproj_workflow_v1alpha1_metrics import IoArgoprojWorkflowV1alpha1Metrics
from argo_workflows.models.io_argoproj_workflow_v1alpha1_pod_gc import IoArgoprojWorkflowV1alpha1PodGC
from argo_workflows.models.io_argoproj_workflow_v1alpha1_retry_strategy import IoArgoprojWorkflowV1alpha1RetryStrategy
from argo_workflows.models.io_argoproj_workflow_v1alpha1_synchronization import IoArgoprojWorkflowV1alpha1Synchronization
from argo_workflows.models.io_argoproj_workflow_v1alpha1_template import IoArgoprojWorkflowV1alpha1Template
from argo_workflows.models.io_argoproj_workflow_v1alpha1_ttl_strategy import IoArgoprojWorkflowV1alpha1TTLStrategy
from argo_workflows.models.io_argoproj_workflow_v1alpha1_volume_claim_gc import IoArgoprojWorkflowV1alpha1VolumeClaimGC
from argo_workflows.models.io_argoproj_workflow_v1alpha1_workflow_level_artifact_gc import IoArgoprojWorkflowV1alpha1WorkflowLevelArtifactGC
from argo_workflows.models.io_argoproj_workflow_v1alpha1_workflow_metadata import IoArgoprojWorkflowV1alpha1WorkflowMetadata
from argo_workflows.models.io_argoproj_workflow_v1alpha1_workflow_template_ref import IoArgoprojWorkflowV1alpha1WorkflowTemplateRef
from argo_workflows.models.io_k8s_api_policy_v1_pod_disruption_budget_spec import IoK8sApiPolicyV1PodDisruptionBudgetSpec
from argo_workflows.models.local_object_reference import LocalObjectReference
from argo_workflows.models.persistent_volume_claim import PersistentVolumeClaim
from argo_workflows.models.pod_dns_config import PodDNSConfig
from argo_workflows.models.pod_security_context import PodSecurityContext
from argo_workflows.models.toleration import Toleration
from argo_workflows.models.volume import Volume
from typing import Optional, Set
from typing_extensions import Self

class IoArgoprojWorkflowV1alpha1WorkflowSpec(BaseModel):
    """
    WorkflowSpec is the specification of a Workflow.
    """ # noqa: E501
    active_deadline_seconds: Optional[StrictInt] = Field(default=None, description="Optional duration in seconds relative to the workflow start time which the workflow is allowed to run before the controller terminates the io.argoproj.workflow.v1alpha1. A value of zero is used to terminate a Running workflow", alias="activeDeadlineSeconds")
    affinity: Optional[Affinity] = None
    archive_logs: Optional[StrictBool] = Field(default=None, description="ArchiveLogs indicates if the container logs should be archived", alias="archiveLogs")
    arguments: Optional[IoArgoprojWorkflowV1alpha1Arguments] = None
    artifact_gc: Optional[IoArgoprojWorkflowV1alpha1WorkflowLevelArtifactGC] = Field(default=None, alias="artifactGC")
    artifact_repository_ref: Optional[IoArgoprojWorkflowV1alpha1ArtifactRepositoryRef] = Field(default=None, alias="artifactRepositoryRef")
    automount_service_account_token: Optional[StrictBool] = Field(default=None, description="AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods. ServiceAccountName of ExecutorConfig must be specified if this value is false.", alias="automountServiceAccountToken")
    dns_config: Optional[PodDNSConfig] = Field(default=None, alias="dnsConfig")
    dns_policy: Optional[StrictStr] = Field(default=None, description="Set DNS policy for workflow pods. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.", alias="dnsPolicy")
    entrypoint: Optional[StrictStr] = Field(default=None, description="Entrypoint is a template reference to the starting point of the io.argoproj.workflow.v1alpha1.")
    executor: Optional[IoArgoprojWorkflowV1alpha1ExecutorConfig] = None
    hooks: Optional[Dict[str, IoArgoprojWorkflowV1alpha1LifecycleHook]] = Field(default=None, description="Hooks holds the lifecycle hook which is invoked at lifecycle of step, irrespective of the success, failure, or error status of the primary step")
    host_aliases: Optional[List[HostAlias]] = Field(default=None, alias="hostAliases")
    host_network: Optional[StrictBool] = Field(default=None, description="Host networking requested for this workflow pod. Default to false.", alias="hostNetwork")
    image_pull_secrets: Optional[List[LocalObjectReference]] = Field(default=None, description="ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod", alias="imagePullSecrets")
    metrics: Optional[IoArgoprojWorkflowV1alpha1Metrics] = None
    node_selector: Optional[Dict[str, StrictStr]] = Field(default=None, description="NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.", alias="nodeSelector")
    on_exit: Optional[StrictStr] = Field(default=None, description="OnExit is a template reference which is invoked at the end of the workflow, irrespective of the success, failure, or error of the primary io.argoproj.workflow.v1alpha1.", alias="onExit")
    parallelism: Optional[StrictInt] = Field(default=None, description="Parallelism limits the max total parallel pods that can execute at the same time in a workflow")
    pod_disruption_budget: Optional[IoK8sApiPolicyV1PodDisruptionBudgetSpec] = Field(default=None, alias="podDisruptionBudget")
    pod_gc: Optional[IoArgoprojWorkflowV1alpha1PodGC] = Field(default=None, alias="podGC")
    pod_metadata: Optional[IoArgoprojWorkflowV1alpha1Metadata] = Field(default=None, alias="podMetadata")
    pod_priority: Optional[StrictInt] = Field(default=None, description="Priority to apply to workflow pods. DEPRECATED: Use PodPriorityClassName instead.", alias="podPriority")
    pod_priority_class_name: Optional[StrictStr] = Field(default=None, description="PriorityClassName to apply to workflow pods.", alias="podPriorityClassName")
    pod_spec_patch: Optional[StrictStr] = Field(default=None, description="PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of container fields which are not strings (e.g. resource limits).", alias="podSpecPatch")
    priority: Optional[StrictInt] = Field(default=None, description="Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first.")
    retry_strategy: Optional[IoArgoprojWorkflowV1alpha1RetryStrategy] = Field(default=None, alias="retryStrategy")
    scheduler_name: Optional[StrictStr] = Field(default=None, description="Set scheduler name for all pods. Will be overridden if container/script template's scheduler name is set. Default scheduler will be used if neither specified.", alias="schedulerName")
    security_context: Optional[PodSecurityContext] = Field(default=None, alias="securityContext")
    service_account_name: Optional[StrictStr] = Field(default=None, description="ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.", alias="serviceAccountName")
    shutdown: Optional[StrictStr] = Field(default=None, description="Shutdown will shutdown the workflow according to its ShutdownStrategy")
    suspend: Optional[StrictBool] = Field(default=None, description="Suspend will suspend the workflow and prevent execution of any future steps in the workflow")
    synchronization: Optional[IoArgoprojWorkflowV1alpha1Synchronization] = None
    template_defaults: Optional[IoArgoprojWorkflowV1alpha1Template] = Field(default=None, alias="templateDefaults")
    templates: Optional[List[IoArgoprojWorkflowV1alpha1Template]] = Field(default=None, description="Templates is a list of workflow templates used in a workflow")
    tolerations: Optional[List[Toleration]] = Field(default=None, description="Tolerations to apply to workflow pods.")
    ttl_strategy: Optional[IoArgoprojWorkflowV1alpha1TTLStrategy] = Field(default=None, alias="ttlStrategy")
    volume_claim_gc: Optional[IoArgoprojWorkflowV1alpha1VolumeClaimGC] = Field(default=None, alias="volumeClaimGC")
    volume_claim_templates: Optional[List[PersistentVolumeClaim]] = Field(default=None, description="VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow", alias="volumeClaimTemplates")
    volumes: Optional[List[Volume]] = Field(default=None, description="Volumes is a list of volumes that can be mounted by containers in a io.argoproj.workflow.v1alpha1.")
    workflow_metadata: Optional[IoArgoprojWorkflowV1alpha1WorkflowMetadata] = Field(default=None, alias="workflowMetadata")
    workflow_template_ref: Optional[IoArgoprojWorkflowV1alpha1WorkflowTemplateRef] = Field(default=None, alias="workflowTemplateRef")
    __properties: ClassVar[List[str]] = ["activeDeadlineSeconds", "affinity", "archiveLogs", "arguments", "artifactGC", "artifactRepositoryRef", "automountServiceAccountToken", "dnsConfig", "dnsPolicy", "entrypoint", "executor", "hooks", "hostAliases", "hostNetwork", "imagePullSecrets", "metrics", "nodeSelector", "onExit", "parallelism", "podDisruptionBudget", "podGC", "podMetadata", "podPriority", "podPriorityClassName", "podSpecPatch", "priority", "retryStrategy", "schedulerName", "securityContext", "serviceAccountName", "shutdown", "suspend", "synchronization", "templateDefaults", "templates", "tolerations", "ttlStrategy", "volumeClaimGC", "volumeClaimTemplates", "volumes", "workflowMetadata", "workflowTemplateRef"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of IoArgoprojWorkflowV1alpha1WorkflowSpec from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of affinity
        if self.affinity:
            _dict['affinity'] = self.affinity.to_dict()
        # override the default output from pydantic by calling `to_dict()` of arguments
        if self.arguments:
            _dict['arguments'] = self.arguments.to_dict()
        # override the default output from pydantic by calling `to_dict()` of artifact_gc
        if self.artifact_gc:
            _dict['artifactGC'] = self.artifact_gc.to_dict()
        # override the default output from pydantic by calling `to_dict()` of artifact_repository_ref
        if self.artifact_repository_ref:
            _dict['artifactRepositoryRef'] = self.artifact_repository_ref.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dns_config
        if self.dns_config:
            _dict['dnsConfig'] = self.dns_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of executor
        if self.executor:
            _dict['executor'] = self.executor.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in hooks (dict)
        _field_dict = {}
        if self.hooks:
            for _key in self.hooks:
                if self.hooks[_key]:
                    _field_dict[_key] = self.hooks[_key].to_dict()
            _dict['hooks'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each item in host_aliases (list)
        _items = []
        if self.host_aliases:
            for _item in self.host_aliases:
                if _item:
                    _items.append(_item.to_dict())
            _dict['hostAliases'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in image_pull_secrets (list)
        _items = []
        if self.image_pull_secrets:
            for _item in self.image_pull_secrets:
                if _item:
                    _items.append(_item.to_dict())
            _dict['imagePullSecrets'] = _items
        # override the default output from pydantic by calling `to_dict()` of metrics
        if self.metrics:
            _dict['metrics'] = self.metrics.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pod_disruption_budget
        if self.pod_disruption_budget:
            _dict['podDisruptionBudget'] = self.pod_disruption_budget.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pod_gc
        if self.pod_gc:
            _dict['podGC'] = self.pod_gc.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pod_metadata
        if self.pod_metadata:
            _dict['podMetadata'] = self.pod_metadata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of retry_strategy
        if self.retry_strategy:
            _dict['retryStrategy'] = self.retry_strategy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of security_context
        if self.security_context:
            _dict['securityContext'] = self.security_context.to_dict()
        # override the default output from pydantic by calling `to_dict()` of synchronization
        if self.synchronization:
            _dict['synchronization'] = self.synchronization.to_dict()
        # override the default output from pydantic by calling `to_dict()` of template_defaults
        if self.template_defaults:
            _dict['templateDefaults'] = self.template_defaults.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in templates (list)
        _items = []
        if self.templates:
            for _item in self.templates:
                if _item:
                    _items.append(_item.to_dict())
            _dict['templates'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in tolerations (list)
        _items = []
        if self.tolerations:
            for _item in self.tolerations:
                if _item:
                    _items.append(_item.to_dict())
            _dict['tolerations'] = _items
        # override the default output from pydantic by calling `to_dict()` of ttl_strategy
        if self.ttl_strategy:
            _dict['ttlStrategy'] = self.ttl_strategy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of volume_claim_gc
        if self.volume_claim_gc:
            _dict['volumeClaimGC'] = self.volume_claim_gc.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in volume_claim_templates (list)
        _items = []
        if self.volume_claim_templates:
            for _item in self.volume_claim_templates:
                if _item:
                    _items.append(_item.to_dict())
            _dict['volumeClaimTemplates'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in volumes (list)
        _items = []
        if self.volumes:
            for _item in self.volumes:
                if _item:
                    _items.append(_item.to_dict())
            _dict['volumes'] = _items
        # override the default output from pydantic by calling `to_dict()` of workflow_metadata
        if self.workflow_metadata:
            _dict['workflowMetadata'] = self.workflow_metadata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of workflow_template_ref
        if self.workflow_template_ref:
            _dict['workflowTemplateRef'] = self.workflow_template_ref.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of IoArgoprojWorkflowV1alpha1WorkflowSpec from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "activeDeadlineSeconds": obj.get("activeDeadlineSeconds"),
            "affinity": Affinity.from_dict(obj["affinity"]) if obj.get("affinity") is not None else None,
            "archiveLogs": obj.get("archiveLogs"),
            "arguments": IoArgoprojWorkflowV1alpha1Arguments.from_dict(obj["arguments"]) if obj.get("arguments") is not None else None,
            "artifactGC": IoArgoprojWorkflowV1alpha1WorkflowLevelArtifactGC.from_dict(obj["artifactGC"]) if obj.get("artifactGC") is not None else None,
            "artifactRepositoryRef": IoArgoprojWorkflowV1alpha1ArtifactRepositoryRef.from_dict(obj["artifactRepositoryRef"]) if obj.get("artifactRepositoryRef") is not None else None,
            "automountServiceAccountToken": obj.get("automountServiceAccountToken"),
            "dnsConfig": PodDNSConfig.from_dict(obj["dnsConfig"]) if obj.get("dnsConfig") is not None else None,
            "dnsPolicy": obj.get("dnsPolicy"),
            "entrypoint": obj.get("entrypoint"),
            "executor": IoArgoprojWorkflowV1alpha1ExecutorConfig.from_dict(obj["executor"]) if obj.get("executor") is not None else None,
            "hooks": dict(
                (_k, IoArgoprojWorkflowV1alpha1LifecycleHook.from_dict(_v))
                for _k, _v in obj["hooks"].items()
            )
            if obj.get("hooks") is not None
            else None,
            "hostAliases": [HostAlias.from_dict(_item) for _item in obj["hostAliases"]] if obj.get("hostAliases") is not None else None,
            "hostNetwork": obj.get("hostNetwork"),
            "imagePullSecrets": [LocalObjectReference.from_dict(_item) for _item in obj["imagePullSecrets"]] if obj.get("imagePullSecrets") is not None else None,
            "metrics": IoArgoprojWorkflowV1alpha1Metrics.from_dict(obj["metrics"]) if obj.get("metrics") is not None else None,
            "nodeSelector": obj.get("nodeSelector"),
            "onExit": obj.get("onExit"),
            "parallelism": obj.get("parallelism"),
            "podDisruptionBudget": IoK8sApiPolicyV1PodDisruptionBudgetSpec.from_dict(obj["podDisruptionBudget"]) if obj.get("podDisruptionBudget") is not None else None,
            "podGC": IoArgoprojWorkflowV1alpha1PodGC.from_dict(obj["podGC"]) if obj.get("podGC") is not None else None,
            "podMetadata": IoArgoprojWorkflowV1alpha1Metadata.from_dict(obj["podMetadata"]) if obj.get("podMetadata") is not None else None,
            "podPriority": obj.get("podPriority"),
            "podPriorityClassName": obj.get("podPriorityClassName"),
            "podSpecPatch": obj.get("podSpecPatch"),
            "priority": obj.get("priority"),
            "retryStrategy": IoArgoprojWorkflowV1alpha1RetryStrategy.from_dict(obj["retryStrategy"]) if obj.get("retryStrategy") is not None else None,
            "schedulerName": obj.get("schedulerName"),
            "securityContext": PodSecurityContext.from_dict(obj["securityContext"]) if obj.get("securityContext") is not None else None,
            "serviceAccountName": obj.get("serviceAccountName"),
            "shutdown": obj.get("shutdown"),
            "suspend": obj.get("suspend"),
            "synchronization": IoArgoprojWorkflowV1alpha1Synchronization.from_dict(obj["synchronization"]) if obj.get("synchronization") is not None else None,
            "templateDefaults": IoArgoprojWorkflowV1alpha1Template.from_dict(obj["templateDefaults"]) if obj.get("templateDefaults") is not None else None,
            "templates": [IoArgoprojWorkflowV1alpha1Template.from_dict(_item) for _item in obj["templates"]] if obj.get("templates") is not None else None,
            "tolerations": [Toleration.from_dict(_item) for _item in obj["tolerations"]] if obj.get("tolerations") is not None else None,
            "ttlStrategy": IoArgoprojWorkflowV1alpha1TTLStrategy.from_dict(obj["ttlStrategy"]) if obj.get("ttlStrategy") is not None else None,
            "volumeClaimGC": IoArgoprojWorkflowV1alpha1VolumeClaimGC.from_dict(obj["volumeClaimGC"]) if obj.get("volumeClaimGC") is not None else None,
            "volumeClaimTemplates": [PersistentVolumeClaim.from_dict(_item) for _item in obj["volumeClaimTemplates"]] if obj.get("volumeClaimTemplates") is not None else None,
            "volumes": [Volume.from_dict(_item) for _item in obj["volumes"]] if obj.get("volumes") is not None else None,
            "workflowMetadata": IoArgoprojWorkflowV1alpha1WorkflowMetadata.from_dict(obj["workflowMetadata"]) if obj.get("workflowMetadata") is not None else None,
            "workflowTemplateRef": IoArgoprojWorkflowV1alpha1WorkflowTemplateRef.from_dict(obj["workflowTemplateRef"]) if obj.get("workflowTemplateRef") is not None else None
        })
        return _obj


