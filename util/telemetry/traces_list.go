// Code generated by util/telemetry/builder. DO NOT EDIT.
//
//go:generate go run ./builder --tracingGo traces_list.go
package telemetry

import (
	"context"

	"go.opentelemetry.io/otel/attribute"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	"go.opentelemetry.io/otel/trace"

	"github.com/argoproj/argo-workflows/v4/util/logging"
)

func AllNoParentSpans() Spans {
	return append(Root, AnyParent...)
}

var Root = Spans{
	&SpanStartupController,
	&SpanWorkflow,
}

var AnyParent = Spans{
	&SpanWaitClientRateLimiter,
}

// NodePhaseSpanOption is a functional option for configuring optional attributes on NodePhase
type NodePhaseSpanOption func(*[]attribute.KeyValue)

// WithMessage sets the message attribute
func WithMessage(message string) NodePhaseSpanOption {
	return func(a *[]attribute.KeyValue) {
		*a = append(*a, attribute.String(
			AttribMessage,
			message,
		))
	}
}

var SpanArchiveArtifact = Span{
	name: "archiveArtifact",
}

// StartArchiveArtifact starts a archive_artifact span
func (t *Tracing) StartArchiveArtifact(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "saveArtifact" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartArchiveArtifact", "expectedParents": "saveArtifact", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "archiveArtifact", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanCaptureScriptResult = Span{
	name: "captureScriptResult",
}

// StartCaptureScriptResult starts a capture_script_result span
func (t *Tracing) StartCaptureScriptResult(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "runWaitContainer" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartCaptureScriptResult", "expectedParents": "runWaitContainer", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "captureScriptResult", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanCreateTaskResult = Span{
	name: "createTaskResult",
}

// StartCreateTaskResult starts a create_task_result span
func (t *Tracing) StartCreateTaskResult(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "runWaitContainer" && parentName != "runMainContainer" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartCreateTaskResult", "expectedParents": "runWaitContainer, runMainContainer", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "createTaskResult", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanCreateWorkflowPod = Span{
	name:     "createWorkflowPod",
	children: []*Span{&SpanRunInitContainer, &SpanRunMainContainer, &SpanRunWaitContainer},
	attributes: []BuiltinAttribute{
		{
			name: AttribNodeID,
		},
	},
}

// StartCreateWorkflowPod starts a create_workflow_pod span
func (t *Tracing) StartCreateWorkflowPod(ctx context.Context, nodeID string) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "node" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartCreateWorkflowPod", "expectedParents": "node", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribNodeID, nodeID),
	}

	return t.tracer.Start(ctx, "createWorkflowPod", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanLoadArtifact = Span{
	name:     "loadArtifact",
	children: []*Span{&SpanUnarchiveArtifact},
	attributes: []BuiltinAttribute{
		{
			name: AttribArtifactPath,
		},
	},
}

// StartLoadArtifact starts a load_artifact span
func (t *Tracing) StartLoadArtifact(ctx context.Context, artifactPath string) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "loadArtifacts" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartLoadArtifact", "expectedParents": "loadArtifacts", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribArtifactPath, artifactPath),
	}

	return t.tracer.Start(ctx, "loadArtifact", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanLoadArtifacts = Span{
	name:     "loadArtifacts",
	children: []*Span{&SpanLoadArtifact},
}

// StartLoadArtifacts starts a load_artifacts span
func (t *Tracing) StartLoadArtifacts(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "runInitContainer" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartLoadArtifacts", "expectedParents": "runInitContainer", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "loadArtifacts", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanNode = Span{
	name:     "node",
	children: []*Span{&SpanCreateWorkflowPod, &SpanNodePhase},
	attributes: []BuiltinAttribute{
		{
			name: AttribNodeID,
		},
		{
			name: AttribWorkflowName,
		},
		{
			name: AttribWorkflowNamespace,
		},
		{
			name: AttribNodeType,
		},
	},
}

// StartNode starts a node span
func (t *Tracing) StartNode(ctx context.Context, nodeID string, workflowName string, workflowNamespace string, nodeType string) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "workflow" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartNode", "expectedParents": "workflow", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribNodeID, nodeID),
		attribute.String(AttribWorkflowName, workflowName),
		attribute.String(AttribWorkflowNamespace, workflowNamespace),
		attribute.String(AttribNodeType, nodeType),
	}

	return t.tracer.Start(ctx, "node", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanNodePhase = Span{
	name: "nodePhase",
	attributes: []BuiltinAttribute{
		{
			name: AttribNodeID,
		},
		{
			name: AttribNodePhase,
		},
		{
			name:     AttribMessage,
			optional: true,
		},
	},
}

// StartNodePhase starts a node_phase span
func (t *Tracing) StartNodePhase(ctx context.Context, nodeID string, nodePhase string, opts ...NodePhaseSpanOption) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "node" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartNodePhase", "expectedParents": "node", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribNodeID, nodeID),
		attribute.String(AttribNodePhase, nodePhase),
	}
	for _, opt := range opts {
		opt(&attribs)
	}

	return t.tracer.Start(ctx, "nodePhase", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindProducer))
}

var SpanPatchTaskResult = Span{
	name: "patchTaskResult",
}

// StartPatchTaskResult starts a patch_task_result span
func (t *Tracing) StartPatchTaskResult(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "runWaitContainer" && parentName != "runMainContainer" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartPatchTaskResult", "expectedParents": "runWaitContainer, runMainContainer", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "patchTaskResult", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanPatchTaskResultLabels = Span{
	name: "patchTaskResultLabels",
}

// StartPatchTaskResultLabels starts a patch_task_result_labels span
func (t *Tracing) StartPatchTaskResultLabels(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "runWaitContainer" && parentName != "runMainContainer" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartPatchTaskResultLabels", "expectedParents": "runWaitContainer, runMainContainer", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "patchTaskResultLabels", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanPersistUpdates = Span{
	name: "persistUpdates",
}

// StartPersistUpdates starts a persist_updates span
func (t *Tracing) StartPersistUpdates(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "workflow" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartPersistUpdates", "expectedParents": "workflow", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "persistUpdates", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanPodReconciliation = Span{
	name: "podReconciliation",
}

// StartPodReconciliation starts a pod_reconciliation span
func (t *Tracing) StartPodReconciliation(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "reconcileWorkflow" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartPodReconciliation", "expectedParents": "reconcileWorkflow", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "podReconciliation", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanProcessDataTemplate = Span{
	name: "processDataTemplate",
}

// StartProcessDataTemplate starts a process_data_template span
func (t *Tracing) StartProcessDataTemplate(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "runMainContainer" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartProcessDataTemplate", "expectedParents": "runMainContainer", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "processDataTemplate", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanReconcileTaskResult = Span{
	name: "reconcileTaskResult",
	attributes: []BuiltinAttribute{
		{
			name: AttribTaskResultName,
		},
		{
			name: AttribTaskResultCompleted,
		},
	},
}

// StartReconcileTaskResult starts a reconcile_task_result span
func (t *Tracing) StartReconcileTaskResult(ctx context.Context, taskResultName string, taskResultCompleted bool) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "reconcileTaskResults" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartReconcileTaskResult", "expectedParents": "reconcileTaskResults", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribTaskResultName, taskResultName),
		attribute.Bool(AttribTaskResultCompleted, taskResultCompleted),
	}

	return t.tracer.Start(ctx, "reconcileTaskResult", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanReconcileTaskResults = Span{
	name:     "reconcileTaskResults",
	children: []*Span{&SpanReconcileTaskResult},
}

// StartReconcileTaskResults starts a reconcile_task_results span
func (t *Tracing) StartReconcileTaskResults(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "reconcileWorkflow" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartReconcileTaskResults", "expectedParents": "reconcileWorkflow", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "reconcileTaskResults", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanReconcileWorkflow = Span{
	name:     "reconcileWorkflow",
	children: []*Span{&SpanPodReconciliation, &SpanReconcileTaskResults},
}

// StartReconcileWorkflow starts a reconcile_workflow span
func (t *Tracing) StartReconcileWorkflow(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "workflow" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartReconcileWorkflow", "expectedParents": "workflow", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "reconcileWorkflow", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanRunInitContainer = Span{
	name:     "runInitContainer",
	children: []*Span{&SpanLoadArtifacts, &SpanStageFiles},
	attributes: []BuiltinAttribute{
		{
			name: AttribWorkflowName,
		},
		{
			name: AttribWorkflowNamespace,
		},
	},
}

// StartRunInitContainer starts a run_init_container span
func (t *Tracing) StartRunInitContainer(ctx context.Context, workflowName string, workflowNamespace string) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "createWorkflowPod" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartRunInitContainer", "expectedParents": "createWorkflowPod", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribWorkflowName, workflowName),
		attribute.String(AttribWorkflowNamespace, workflowNamespace),
	}

	return t.tracer.Start(ctx, "runInitContainer", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanRunMainContainer = Span{
	name:     "runMainContainer",
	children: []*Span{&SpanCreateTaskResult, &SpanPatchTaskResult, &SpanPatchTaskResultLabels, &SpanProcessDataTemplate},
	attributes: []BuiltinAttribute{
		{
			name: AttribWorkflowName,
		},
		{
			name: AttribWorkflowNamespace,
		},
	},
}

// StartRunMainContainer starts a run_main_container span
func (t *Tracing) StartRunMainContainer(ctx context.Context, workflowName string, workflowNamespace string) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "createWorkflowPod" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartRunMainContainer", "expectedParents": "createWorkflowPod", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribWorkflowName, workflowName),
		attribute.String(AttribWorkflowNamespace, workflowNamespace),
	}

	return t.tracer.Start(ctx, "runMainContainer", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanRunWaitContainer = Span{
	name:     "runWaitContainer",
	children: []*Span{&SpanCaptureScriptResult, &SpanCreateTaskResult, &SpanPatchTaskResult, &SpanPatchTaskResultLabels, &SpanSaveArtifacts, &SpanSaveLogs, &SpanWaitWorkload},
	attributes: []BuiltinAttribute{
		{
			name: AttribWorkflowName,
		},
		{
			name: AttribWorkflowNamespace,
		},
	},
}

// StartRunWaitContainer starts a run_wait_container span
func (t *Tracing) StartRunWaitContainer(ctx context.Context, workflowName string, workflowNamespace string) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "createWorkflowPod" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartRunWaitContainer", "expectedParents": "createWorkflowPod", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribWorkflowName, workflowName),
		attribute.String(AttribWorkflowNamespace, workflowNamespace),
	}

	return t.tracer.Start(ctx, "runWaitContainer", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanSaveArtifact = Span{
	name:     "saveArtifact",
	children: []*Span{&SpanArchiveArtifact},
}

// StartSaveArtifact starts a save_artifact span
func (t *Tracing) StartSaveArtifact(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "saveArtifacts" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartSaveArtifact", "expectedParents": "saveArtifacts", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "saveArtifact", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanSaveArtifacts = Span{
	name:     "saveArtifacts",
	children: []*Span{&SpanSaveArtifact},
}

// StartSaveArtifacts starts a save_artifacts span
func (t *Tracing) StartSaveArtifacts(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "runWaitContainer" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartSaveArtifacts", "expectedParents": "runWaitContainer", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "saveArtifacts", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanSaveContainerLogs = Span{
	name: "saveContainerLogs",
	attributes: []BuiltinAttribute{
		{
			name: AttribContainerName,
		},
	},
}

// StartSaveContainerLogs starts a save_container_logs span
func (t *Tracing) StartSaveContainerLogs(ctx context.Context, containerName string) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "saveLogs" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartSaveContainerLogs", "expectedParents": "saveLogs", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribContainerName, containerName),
	}

	return t.tracer.Start(ctx, "saveContainerLogs", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanSaveLogs = Span{
	name:     "saveLogs",
	children: []*Span{&SpanSaveContainerLogs},
}

// StartSaveLogs starts a save_logs span
func (t *Tracing) StartSaveLogs(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "runWaitContainer" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartSaveLogs", "expectedParents": "runWaitContainer", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "saveLogs", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanStageFiles = Span{
	name: "stageFiles",
}

// StartStageFiles starts a stage_files span
func (t *Tracing) StartStageFiles(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "runInitContainer" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartStageFiles", "expectedParents": "runInitContainer", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "stageFiles", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanStartupCacheSync = Span{
	name: "startupCacheSync",
}

// StartStartupCacheSync starts a startup_cache_sync span
func (t *Tracing) StartStartupCacheSync(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "startupController" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartStartupCacheSync", "expectedParents": "startupController", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "startupCacheSync", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanStartupController = Span{
	name:     "startupController",
	children: []*Span{&SpanStartupCacheSync},
}

// StartStartupController starts a startup_controller span
func (t *Tracing) StartStartupController(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartStartupController", "actualParent": parentName}).Info(ctx, "trace parent") // TODO remove
	}

	return t.tracer.Start(ctx, "startupController", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanTryAcquireLock = Span{
	name: "tryAcquireLock",
	attributes: []BuiltinAttribute{
		{
			name: AttribLockName,
		},
		{
			name: AttribLockAcquired,
		},
	},
}

// StartTryAcquireLock starts a try_acquire_lock span
func (t *Tracing) StartTryAcquireLock(ctx context.Context, lockName string, lockAcquired bool) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "workflow" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartTryAcquireLock", "expectedParents": "workflow", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribLockName, lockName),
		attribute.Bool(AttribLockAcquired, lockAcquired),
	}

	return t.tracer.Start(ctx, "tryAcquireLock", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanUnarchiveArtifact = Span{
	name: "unarchiveArtifact",
	attributes: []BuiltinAttribute{
		{
			name: AttribArtifactArchive,
		},
	},
}

// StartUnarchiveArtifact starts a unarchive_artifact span
func (t *Tracing) StartUnarchiveArtifact(ctx context.Context, artifactArchive string) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "loadArtifact" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartUnarchiveArtifact", "expectedParents": "loadArtifact", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribArtifactArchive, artifactArchive),
	}

	return t.tracer.Start(ctx, "unarchiveArtifact", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanWaitClientRateLimiter = Span{
	name: "waitClientRateLimiter",
}

// StartWaitClientRateLimiter starts a wait_client_rate_limiter span
func (t *Tracing) StartWaitClientRateLimiter(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartWaitClientRateLimiter", "actualParent": parentName}).Info(ctx, "trace parent") // TODO remove
	}

	return t.tracer.Start(ctx, "waitClientRateLimiter", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanWaitWorkload = Span{
	name: "waitWorkload",
}

// StartWaitWorkload starts a wait_workload span
func (t *Tracing) StartWaitWorkload(ctx context.Context) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "runWaitContainer" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartWaitWorkload", "expectedParents": "runWaitContainer", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}

	return t.tracer.Start(ctx, "waitWorkload", trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanWorkflow = Span{
	name:     "workflow",
	children: []*Span{&SpanNode, &SpanPersistUpdates, &SpanReconcileWorkflow, &SpanTryAcquireLock, &SpanWorkflowPhase},
	attributes: []BuiltinAttribute{
		{
			name: AttribWorkflowName,
		},
		{
			name: AttribWorkflowNamespace,
		},
	},
}

// StartWorkflow starts a workflow span
func (t *Tracing) StartWorkflow(ctx context.Context, workflowName string, workflowNamespace string) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartWorkflow", "actualParent": parentName}).Info(ctx, "trace parent") // TODO remove
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribWorkflowName, workflowName),
		attribute.String(AttribWorkflowNamespace, workflowNamespace),
	}

	return t.tracer.Start(ctx, "workflow", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindInternal))
}

var SpanWorkflowPhase = Span{
	name: "workflowPhase",
	attributes: []BuiltinAttribute{
		{
			name: AttribWorkflowPhase,
		},
	},
}

// StartWorkflowPhase starts a workflow_phase span
func (t *Tracing) StartWorkflowPhase(ctx context.Context, workflowPhase string) (context.Context, trace.Span) {
	parent := trace.SpanFromContext(ctx)
	if roParent, ok := parent.(sdktrace.ReadOnlySpan); ok {
		parentName := roParent.Name()
		if parentName != "workflow" {
			logging.RequireLoggerFromContext(ctx).WithFields(logging.Fields{"startMethod": "StartWorkflowPhase", "expectedParents": "workflow", "actualParent": parentName}).Error(ctx, "incorrect trace parentage")
		}
	}
	attribs := []attribute.KeyValue{
		attribute.String(AttribWorkflowPhase, workflowPhase),
	}

	return t.tracer.Start(ctx, "workflowPhase", trace.WithAttributes(attribs...), trace.WithSpanKind(trace.SpanKindInternal))
}
