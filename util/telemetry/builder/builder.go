package main

import (
	_ "embed"
	"flag"
	"fmt"
	"os"
	"regexp"
	"strings"
	"unicode"

	"sigs.k8s.io/yaml"
)

const generatedBanner string = "// Code generated by util/telemetry/builder. DO NOT EDIT."

const (
	// Words for distinguishing types
	spanType   string = "Span"
	metricType string = "Metric"
)

//go:embed values.yaml
var valuesYaml []byte

type attribute struct {
	Name        string `json:"name"`
	DisplayName string `json:"displayName,omitempty"`
	// Description is a markdown explanation for the documentation. One line only.
	Description string `json:"description"`
	// Type is the Go type of the attribute value: string, bool, int, int64, float64
	// Defaults to string if not specified
	Type string `json:"type,omitempty"`
}

type allowedAttribute struct {
	Name     string `json:"name"`
	Optional bool   `json:"optional,omitempty"`
}

func (a *allowedAttribute) AttribName() string {
	return fmt.Sprintf("Attrib%s", a.Name)
}

type common struct {
	// Name: Telemetry name, in CamelCaps
	// Will be snake cased for display purposes
	Name string `json:"name"`
	// Description: short description, emitted by telemetry and added to the documentation. Do not use marrkdown here.
	Description string `json:"description"`
	// ExtendedDescription: Markdown capable further description added to the documentation before attributes
	ExtendedDescription string `json:"extendedDescription,omitempty"`
	// Notes: Markdown capable further description added to the documentation after attributes
	Notes string `json:"notes,omitempty"`
	// Attributes: All attributes for this telemetry item
	Attributes allowedAttributeList `json:"attributes,omitempty"`
}

type metric struct {
	common
	// Unit: OpenTelemetry unit of measurement https://opentelemetry.io/docs/specs/otel/metrics/api/#instrument-unit
	Unit           string    `json:"unit"`
	Type           string    `json:"type"`
	DefaultBuckets []float64 `json:"defaultBuckets,omitempty"`
}

type span struct {
	common
	Kind      string   `json:"kind,omitempty"` // Internal if not supplied
	Root      bool     `json:"root,omitempty"`
	AnyParent bool     `json:"anyParent,omitempty"`
	Parents   []string `json:"parents,omitempty"` // Required if not a root span or anyParent
	DocsOnly  bool     `json:"docsOnly,omitempty"`
}

type hasCommon interface {
	Common() common
}

func (m metric) Common() common { return m.common }
func (s span) Common() common   { return s.common }

type attributesList []attribute
type allowedAttributeList []allowedAttribute
type metricsList []metric
type spansList []span

type values struct {
	Attributes attributesList `json:"attributes"`
	Metrics    metricsList    `json:"metrics"`
	Spans      spansList      `json:"spans"`
}

func load() values {
	var vals values
	err := yaml.UnmarshalStrict(valuesYaml, &vals)
	if err != nil {
		panic(err)
	}
	return vals
}

func main() {
	metricsDocs := flag.String("metricsDocs", "", "Path to metrics.md in the docs")
	attributesGo := flag.String("attributesGo", "", "Path to attributes.go in util/telemetry")
	metricsListGo := flag.String("metricsListGo", "", "Path to metrics_list.go in util/telemetry")
	metricsHelpersGo := flag.String("metricsHelpersGo", "", "Path to metrics_helpers.go in util/telemetry")
	tracingDocs := flag.String("tracingDocs", "", "Path to tracing.md in the docs")
	tracingGo := flag.String("tracingGo", "", "Path to traces_list.go util/telemetry")
	flag.Parse()
	vals := load()
	switch validator := validate(&vals); validator.valid() {
	case true:
		failed := false
		if metricsDocs != nil && *metricsDocs != "" {
			err := createMetricsDocs(*metricsDocs, &vals.Metrics, &vals.Attributes)
			if err != nil {
				failed = true
				fmt.Printf("createMetricsDocs: %v\n", err)
			}
		}
		if attributesGo != nil && *attributesGo != "" {
			err := createAttributesGo(*attributesGo, &vals.Attributes)
			if err != nil {
				failed = true
				fmt.Printf("createAttributesGo: %v\n", err)
			}
		}
		if metricsListGo != nil && *metricsListGo != "" {
			err := createMetricsListGo(*metricsListGo, &vals.Metrics)
			if err != nil {
				failed = true
				fmt.Printf("createMetricsListGo: %v\n", err)
			}
		}
		if metricsHelpersGo != nil && *metricsHelpersGo != "" {
			err := createMetricsHelpersGo(*metricsHelpersGo, &vals.Metrics, &vals.Attributes)
			if err != nil {
				failed = true
				fmt.Printf("createMetricsHelpersGo: %v\n", err)
			}
		}
		if tracingGo != nil && *tracingGo != "" {
			err := createTracingGo(*tracingGo, &vals.Spans, &vals.Attributes)
			if err != nil {
				failed = true
				fmt.Printf("createTracingGo: %v\n", err)
			}
		}
		if tracingDocs != nil && *tracingDocs != "" {
			err := createTracingDocs(*tracingDocs, &vals.Spans, &vals.Attributes)
			if err != nil {
				failed = true
				fmt.Printf("createTracingDocs: %v\n", err)
			}
		}
		if failed {
			fmt.Println("Failed")
			os.Exit(1)
		}
	case false:
		validator.printErrors()
		fmt.Println("Validation failed")
		os.Exit(1)
	}
}

func upperToSnake(in string) string {
	runes := []rune(in)
	in = string(append([]rune{unicode.ToLower(runes[0])}, runes[1:]...))
	re := regexp.MustCompile(`[A-Z]+`)
	return string(re.ReplaceAllFunc([]byte(in), func(in []byte) []byte {
		return fmt.Appendf(nil, "_%s", strings.ToLower(string(in)))
	}))
}

func (a *attribute) displayName() string {
	name := a.Name
	if a.DisplayName != "" {
		name = a.DisplayName
	}
	return upperToSnake(name)
}

func (m *metric) instrumentType() string {
	return m.Type
}

func (c *common) displayName() string {
	return upperToSnake(c.Name)
}

func getAttribByName(name string, attribs *attributesList) *attribute {
	for _, attrib := range *attribs {
		if name == attrib.Name {
			return &attrib
		}
	}
	return nil
}

func (a *attribute) attrType() string {
	if a.Type == "" {
		return "string"
	}
	return a.Type
}

func (a *attribute) kvConstructor() string {
	switch a.attrType() {
	case "string":
		return "attribute.String"
	case "bool":
		return "attribute.Bool"
	case "int64":
		return "attribute.Int64"
	case "float64":
		return "attribute.Float64"
	default:
		panic("Implement a kvConstrutor for this type")
	}
}
