{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='workflowTemplate', url='', help='WorkflowTemplate is the definition of a workflow template resource'),
  '#metadata':: d.obj(help='ObjectMeta is metadata that all persisted resources must have, which includes all objects\nusers must create.'),
  metadata: {
    '#creationTimestamp':: d.obj(help='Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false'),
    creationTimestamp: {
      '#withNanos':: d.fn(help='Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context.', args=[d.arg(name='nanos', type=d.T.integer)]),
      withNanos(nanos): { metadata+: { creationTimestamp+: { nanos: nanos } } },
      '#withSeconds':: d.fn(help='Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive.', args=[d.arg(name='seconds', type=d.T.string)]),
      withSeconds(seconds): { metadata+: { creationTimestamp+: { seconds: seconds } } },
    },
    '#deletionTimestamp':: d.obj(help='Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false'),
    deletionTimestamp: {
      '#withNanos':: d.fn(help='Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context.', args=[d.arg(name='nanos', type=d.T.integer)]),
      withNanos(nanos): { metadata+: { deletionTimestamp+: { nanos: nanos } } },
      '#withSeconds':: d.fn(help='Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive.', args=[d.arg(name='seconds', type=d.T.string)]),
      withSeconds(seconds): { metadata+: { deletionTimestamp+: { seconds: seconds } } },
    },
    '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.string)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withFinalizers':: d.fn(help='', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='GenerateName is an optional prefix, used by the server, to generate a unique\nname ONLY IF the Name field has not been provided.\nIf this field is used, the name returned to the client will be different\nthan the name passed. This value will also be combined with a unique suffix.\nThe provided value has the same validation rules as the Name field,\nand may be truncated by the length of the suffix required to make the value\nunique on the server.\n\nIf this field is specified and the generated name exists, the server will\nNOT return a 409 - instead, it will either return 201 Created or 500 with Reason\nServerTimeout indicating a unique name could not be found in the time allotted, and the client\nshould retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified.\nMore info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#idempotency\n+optional', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='', args=[d.arg(name='generation', type=d.T.string)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withManagedFields':: d.fn(help="ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that io.argoproj.workflow.v1alpha1. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n'ci-cd'. The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional", args=[d.arg(name='managedFields', type=d.T.array)]),
    withManagedFields(managedFields): { metadata+: { managedFields: if std.isArray(v=managedFields) then managedFields else [managedFields] } },
    '#withManagedFieldsMixin':: d.fn(help="ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that io.argoproj.workflow.v1alpha1. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n'ci-cd'. The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='managedFields', type=d.T.array)]),
    withManagedFieldsMixin(managedFields): { metadata+: { managedFields+: if std.isArray(v=managedFields) then managedFields else [managedFields] } },
    '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='Namespace defines the space within each name must be unique. An empty namespace is\nequivalent to the "default" namespace, but "default" is the canonical representation.\nNot all objects are required to be scoped to a namespace - the value of this field for\nthose objects will be empty.\n\nMust be a DNS_LABEL.\nCannot be updated.\nMore info: http://kubernetes.io/docs/user-guide/namespaces\n+optional', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='An opaque value that represents the internal version of this object that can\nbe used by clients to determine when objects have changed. May be used for optimistic\nconcurrency, change detection, and the watch operation on a resource or set of resources.\nClients must treat these values as opaque and passed unmodified back to the server.\nThey may only be valid for a particular resource or set of resources.\n\nPopulated by the system.\nRead-only.\nValue must be treated as opaque by clients and .\nMore info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='SelfLink is a URL representing this object.\nPopulated by the system.\nRead-only.\n\nDEPRECATED\nKubernetes will stop propagating this field in 1.20 release and the field is planned\nto be removed in 1.21 release.\n+optional', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='UID is the unique in time and space value for this object. It is typically generated by\nthe server on successful creation of a resource and is not allowed to change on PUT\noperations.\n\nPopulated by the system.\nRead-only.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#uids\n+optional', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#spec':: d.obj(help='WorkflowTemplateSpec is a spec of WorkflowTemplate.'),
  spec: {
    '#affinity':: d.obj(help='Affinity is a group of affinity scheduling rules.'),
    affinity: {
      '#nodeAffinity':: d.obj(help='Node affinity is a group of node affinity scheduling rules.'),
      nodeAffinity: {
        '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help='A node selector represents the union of the results of one or more label queries\nover a set of nodes; that is, it represents the OR of the selectors represented\nby the node selector terms.'),
        requiredDuringSchedulingIgnoredDuringExecution: {
          '#withNodeSelectorTerms':: d.fn(help='Required. A list of node selector terms. The terms are ORed.', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
          withNodeSelectorTerms(nodeSelectorTerms): { spec+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } },
          '#withNodeSelectorTermsMixin':: d.fn(help='Required. A list of node selector terms. The terms are ORed.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
          withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } },
        },
        '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
      },
      '#podAffinity':: d.obj(help='Pod affinity is a group of inter pod affinity scheduling rules.'),
      podAffinity: {
        '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } },
      },
      '#podAntiAffinity':: d.obj(help='Pod anti affinity is a group of inter pod anti affinity scheduling rules.'),
      podAntiAffinity: {
        '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } },
      },
    },
    '#arguments':: d.obj(help='Arguments to a template'),
    arguments: {
      '#withArtifacts':: d.fn(help='Artifacts is the list of artifacts to pass to the template or workflow', args=[d.arg(name='artifacts', type=d.T.array)]),
      withArtifacts(artifacts): { spec+: { arguments+: { artifacts: if std.isArray(v=artifacts) then artifacts else [artifacts] } } },
      '#withArtifactsMixin':: d.fn(help='Artifacts is the list of artifacts to pass to the template or workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='artifacts', type=d.T.array)]),
      withArtifactsMixin(artifacts): { spec+: { arguments+: { artifacts+: if std.isArray(v=artifacts) then artifacts else [artifacts] } } },
      '#withParameters':: d.fn(help='Parameters is the list of parameters to pass to the template or workflow', args=[d.arg(name='parameters', type=d.T.array)]),
      withParameters(parameters): { spec+: { arguments+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withParametersMixin':: d.fn(help='Parameters is the list of parameters to pass to the template or workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
      withParametersMixin(parameters): { spec+: { arguments+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } },
    },
    '#artifactRepositoryRef':: d.obj(help=''),
    artifactRepositoryRef: {
      '#withConfigMap':: d.fn(help='The name of the config map. Defaults to "artifact-repositories".', args=[d.arg(name='configMap', type=d.T.string)]),
      withConfigMap(configMap): { spec+: { artifactRepositoryRef+: { configMap: configMap } } },
      '#withKey':: d.fn(help='The config map key. Defaults to the value of the "workflows.argoproj.io/default-artifact-repository" annotation.', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { spec+: { artifactRepositoryRef+: { key: key } } },
    },
    '#dnsConfig':: d.obj(help='PodDNSConfig defines the DNS parameters of a pod in addition to\nthose generated from DNSPolicy.'),
    dnsConfig: {
      '#withNameservers':: d.fn(help='', args=[d.arg(name='nameservers', type=d.T.array)]),
      withNameservers(nameservers): { spec+: { dnsConfig+: { nameservers: if std.isArray(v=nameservers) then nameservers else [nameservers] } } },
      '#withNameserversMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nameservers', type=d.T.array)]),
      withNameserversMixin(nameservers): { spec+: { dnsConfig+: { nameservers+: if std.isArray(v=nameservers) then nameservers else [nameservers] } } },
      '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.array)]),
      withOptions(options): { spec+: { dnsConfig+: { options: if std.isArray(v=options) then options else [options] } } },
      '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.array)]),
      withOptionsMixin(options): { spec+: { dnsConfig+: { options+: if std.isArray(v=options) then options else [options] } } },
      '#withSearches':: d.fn(help='', args=[d.arg(name='searches', type=d.T.array)]),
      withSearches(searches): { spec+: { dnsConfig+: { searches: if std.isArray(v=searches) then searches else [searches] } } },
      '#withSearchesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='searches', type=d.T.array)]),
      withSearchesMixin(searches): { spec+: { dnsConfig+: { searches+: if std.isArray(v=searches) then searches else [searches] } } },
    },
    '#executor':: d.obj(help='ExecutorConfig holds configurations of an executor container.'),
    executor: {
      '#withServiceAccountName':: d.fn(help='ServiceAccountName specifies the service account name of the executor container.', args=[d.arg(name='serviceAccountName', type=d.T.string)]),
      withServiceAccountName(serviceAccountName): { spec+: { executor+: { serviceAccountName: serviceAccountName } } },
    },
    '#metrics':: d.obj(help='Metrics are a list of metrics emitted from a Workflow/Template'),
    metrics: {
      '#withPrometheus':: d.fn(help='Prometheus is a list of prometheus metrics to be emitted', args=[d.arg(name='prometheus', type=d.T.array)]),
      withPrometheus(prometheus): { spec+: { metrics+: { prometheus: if std.isArray(v=prometheus) then prometheus else [prometheus] } } },
      '#withPrometheusMixin':: d.fn(help='Prometheus is a list of prometheus metrics to be emitted\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='prometheus', type=d.T.array)]),
      withPrometheusMixin(prometheus): { spec+: { metrics+: { prometheus+: if std.isArray(v=prometheus) then prometheus else [prometheus] } } },
    },
    '#podDisruptionBudget':: d.obj(help='PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.'),
    podDisruptionBudget: {
      '#maxUnavailable':: d.obj(help='+protobuf=true\n+protobuf.options.(gogoproto.goproto_stringer)=false\n+k8s:openapi-gen=true'),
      maxUnavailable: {
        '#withIntVal':: d.fn(help='', args=[d.arg(name='intVal', type=d.T.integer)]),
        withIntVal(intVal): { spec+: { podDisruptionBudget+: { maxUnavailable+: { intVal: intVal } } } },
        '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
        withStrVal(strVal): { spec+: { podDisruptionBudget+: { maxUnavailable+: { strVal: strVal } } } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { podDisruptionBudget+: { maxUnavailable+: { type: type } } } },
      },
      '#minAvailable':: d.obj(help='+protobuf=true\n+protobuf.options.(gogoproto.goproto_stringer)=false\n+k8s:openapi-gen=true'),
      minAvailable: {
        '#withIntVal':: d.fn(help='', args=[d.arg(name='intVal', type=d.T.integer)]),
        withIntVal(intVal): { spec+: { podDisruptionBudget+: { minAvailable+: { intVal: intVal } } } },
        '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
        withStrVal(strVal): { spec+: { podDisruptionBudget+: { minAvailable+: { strVal: strVal } } } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { podDisruptionBudget+: { minAvailable+: { type: type } } } },
      },
      '#selector':: d.obj(help='A label selector is a label query over a set of resources. The result of matchLabels and\nmatchExpressions are ANDed. An empty label selector matches all objects. A null\nlabel selector matches no objects.'),
      selector: {
        '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
        withMatchExpressions(matchExpressions): { spec+: { podDisruptionBudget+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } },
        '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
        withMatchExpressionsMixin(matchExpressions): { spec+: { podDisruptionBudget+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } },
        '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { spec+: { podDisruptionBudget+: { selector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { spec+: { podDisruptionBudget+: { selector+: { matchLabels+: matchLabels } } } },
      },
    },
    '#podGC':: d.obj(help='PodGC describes how to delete completed pods as they complete'),
    podGC: {
      '#withStrategy':: d.fn(help='Strategy is the strategy to use. One of "OnPodCompletion", "OnPodSuccess", "OnWorkflowCompletion", "OnWorkflowSuccess"', args=[d.arg(name='strategy', type=d.T.string)]),
      withStrategy(strategy): { spec+: { podGC+: { strategy: strategy } } },
    },
    '#retryStrategy':: d.obj(help='RetryStrategy provides controls on how to retry a workflow step'),
    retryStrategy: {
      '#backoff':: d.obj(help='Backoff is a backoff strategy to use within retryStrategy'),
      backoff: {
        '#factor':: d.obj(help='+protobuf=true\n+protobuf.options.(gogoproto.goproto_stringer)=false\n+k8s:openapi-gen=true'),
        factor: {
          '#withIntVal':: d.fn(help='', args=[d.arg(name='intVal', type=d.T.integer)]),
          withIntVal(intVal): { spec+: { retryStrategy+: { backoff+: { factor+: { intVal: intVal } } } } },
          '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
          withStrVal(strVal): { spec+: { retryStrategy+: { backoff+: { factor+: { strVal: strVal } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { retryStrategy+: { backoff+: { factor+: { type: type } } } } },
        },
        '#withDuration':: d.fn(help='Duration is the amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h")', args=[d.arg(name='duration', type=d.T.string)]),
        withDuration(duration): { spec+: { retryStrategy+: { backoff+: { duration: duration } } } },
        '#withMaxDuration':: d.fn(help='MaxDuration is the maximum amount of time allowed for the backoff strategy', args=[d.arg(name='maxDuration', type=d.T.string)]),
        withMaxDuration(maxDuration): { spec+: { retryStrategy+: { backoff+: { maxDuration: maxDuration } } } },
      },
      '#limit':: d.obj(help='+protobuf=true\n+protobuf.options.(gogoproto.goproto_stringer)=false\n+k8s:openapi-gen=true'),
      limit: {
        '#withIntVal':: d.fn(help='', args=[d.arg(name='intVal', type=d.T.integer)]),
        withIntVal(intVal): { spec+: { retryStrategy+: { limit+: { intVal: intVal } } } },
        '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
        withStrVal(strVal): { spec+: { retryStrategy+: { limit+: { strVal: strVal } } } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { retryStrategy+: { limit+: { type: type } } } },
      },
      '#withRetryPolicy':: d.fn(help='RetryPolicy is a policy of NodePhase statuses that will be retried', args=[d.arg(name='retryPolicy', type=d.T.string)]),
      withRetryPolicy(retryPolicy): { spec+: { retryStrategy+: { retryPolicy: retryPolicy } } },
    },
    '#securityContext':: d.obj(help='PodSecurityContext holds pod-level security attributes and common container settings.\nSome fields are also present in container.securityContext.  Field values of\ncontainer.securityContext take precedence over field values of PodSecurityContext.'),
    securityContext: {
      '#seLinuxOptions':: d.obj(help=''),
      seLinuxOptions: {
        '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
        withLevel(level): { spec+: { securityContext+: { seLinuxOptions+: { level: level } } } },
        '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
        withRole(role): { spec+: { securityContext+: { seLinuxOptions+: { role: role } } } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { securityContext+: { seLinuxOptions+: { type: type } } } },
        '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
        withUser(user): { spec+: { securityContext+: { seLinuxOptions+: { user: user } } } },
      },
      '#windowsOptions':: d.obj(help='WindowsSecurityContextOptions contain Windows-specific options and credentials.'),
      windowsOptions: {
        '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
        withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } },
        '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
        withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } },
        '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
        withRunAsUserName(runAsUserName): { spec+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } },
      },
      '#withFsGroup':: d.fn(help="1. The owning GID will be the FSGroup\n2. The setgid bit is set (new files created in the volume will be owned by FSGroup)\n3. The permission bits are OR'd with rw-rw----\n\nIf unset, the Kubelet will not modify the ownership and permissions of any volume.\n+optional", args=[d.arg(name='fsGroup', type=d.T.string)]),
      withFsGroup(fsGroup): { spec+: { securityContext+: { fsGroup: fsGroup } } },
      '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.string)]),
      withRunAsGroup(runAsGroup): { spec+: { securityContext+: { runAsGroup: runAsGroup } } },
      '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
      withRunAsNonRoot(runAsNonRoot): { spec+: { securityContext+: { runAsNonRoot: runAsNonRoot } } },
      '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.string)]),
      withRunAsUser(runAsUser): { spec+: { securityContext+: { runAsUser: runAsUser } } },
      '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
      withSupplementalGroups(supplementalGroups): { spec+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } },
      '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
      withSupplementalGroupsMixin(supplementalGroups): { spec+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } },
      '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
      withSysctls(sysctls): { spec+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } },
      '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
      withSysctlsMixin(sysctls): { spec+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } },
    },
    '#synchronization':: d.obj(help='Synchronization holds synchronization lock configuration'),
    synchronization: {
      '#mutex':: d.obj(help='Mutex holds Mutex configuration'),
      mutex: {
        '#withName':: d.fn(help='name of the mutex', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { synchronization+: { mutex+: { name: name } } } },
      },
      '#semaphore':: d.obj(help='SemaphoreRef is a reference of Semaphore'),
      semaphore: {
        '#configMapKeyRef':: d.obj(help='Selects a key from a ConfigMap.'),
        configMapKeyRef: {
          '#localObjectReference':: d.obj(help='LocalObjectReference contains enough information to let you locate the\nreferenced object inside the same namespace.'),
          localObjectReference: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { synchronization+: { semaphore+: { configMapKeyRef+: { localObjectReference+: { name: name } } } } } },
          },
          '#withKey':: d.fn(help='The key to select.', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { spec+: { synchronization+: { semaphore+: { configMapKeyRef+: { key: key } } } } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { spec+: { synchronization+: { semaphore+: { configMapKeyRef+: { optional: optional } } } } },
        },
      },
    },
    '#ttlStrategy':: d.obj(help='TTLStrategy is the strategy for the time to live depending on if the workflow succeeded or failed'),
    ttlStrategy: {
      '#withSecondsAfterCompletion':: d.fn(help='SecondsAfterCompletion is the number of seconds to live after completion', args=[d.arg(name='secondsAfterCompletion', type=d.T.integer)]),
      withSecondsAfterCompletion(secondsAfterCompletion): { spec+: { ttlStrategy+: { secondsAfterCompletion: secondsAfterCompletion } } },
      '#withSecondsAfterFailure':: d.fn(help='SecondsAfterFailure is the number of seconds to live after failure', args=[d.arg(name='secondsAfterFailure', type=d.T.integer)]),
      withSecondsAfterFailure(secondsAfterFailure): { spec+: { ttlStrategy+: { secondsAfterFailure: secondsAfterFailure } } },
      '#withSecondsAfterSuccess':: d.fn(help='SecondsAfterSuccess is the number of seconds to live after success', args=[d.arg(name='secondsAfterSuccess', type=d.T.integer)]),
      withSecondsAfterSuccess(secondsAfterSuccess): { spec+: { ttlStrategy+: { secondsAfterSuccess: secondsAfterSuccess } } },
    },
    '#volumeClaimGC':: d.obj(help='VolumeClaimGC describes how to delete volumes from completed Workflows'),
    volumeClaimGC: {
      '#withStrategy':: d.fn(help='Strategy is the strategy to use. One of "OnWorkflowCompletion", "OnWorkflowSuccess"', args=[d.arg(name='strategy', type=d.T.string)]),
      withStrategy(strategy): { spec+: { volumeClaimGC+: { strategy: strategy } } },
    },
    '#withActiveDeadlineSeconds':: d.fn(help='Optional duration in seconds relative to the workflow start time which the workflow is allowed to run before the controller terminates the io.argoproj.workflow.v1alpha1. A value of zero is used to terminate a Running workflow', args=[d.arg(name='activeDeadlineSeconds', type=d.T.integer)]),
    withActiveDeadlineSeconds(activeDeadlineSeconds): { spec+: { activeDeadlineSeconds: activeDeadlineSeconds } },
    '#withAutomountServiceAccountToken':: d.fn(help='AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods. ServiceAccountName of ExecutorConfig must be specified if this value is false.', args=[d.arg(name='automountServiceAccountToken', type=d.T.boolean)]),
    withAutomountServiceAccountToken(automountServiceAccountToken): { spec+: { automountServiceAccountToken: automountServiceAccountToken } },
    '#withDnsPolicy':: d.fn(help="Set DNS policy for the pod. Defaults to 'ClusterFirst'. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.", args=[d.arg(name='dnsPolicy', type=d.T.string)]),
    withDnsPolicy(dnsPolicy): { spec+: { dnsPolicy: dnsPolicy } },
    '#withEntrypoint':: d.fn(help='Entrypoint is a template reference to the starting point of the io.argoproj.workflow.v1alpha1.', args=[d.arg(name='entrypoint', type=d.T.string)]),
    withEntrypoint(entrypoint): { spec+: { entrypoint: entrypoint } },
    '#withHostAliases':: d.fn(help='', args=[d.arg(name='hostAliases', type=d.T.array)]),
    withHostAliases(hostAliases): { spec+: { hostAliases: if std.isArray(v=hostAliases) then hostAliases else [hostAliases] } },
    '#withHostAliasesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='hostAliases', type=d.T.array)]),
    withHostAliasesMixin(hostAliases): { spec+: { hostAliases+: if std.isArray(v=hostAliases) then hostAliases else [hostAliases] } },
    '#withHostNetwork':: d.fn(help='Host networking requested for this workflow pod. Default to false.', args=[d.arg(name='hostNetwork', type=d.T.boolean)]),
    withHostNetwork(hostNetwork): { spec+: { hostNetwork: hostNetwork } },
    '#withImagePullSecrets':: d.fn(help='ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
    withImagePullSecrets(imagePullSecrets): { spec+: { imagePullSecrets: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
    '#withImagePullSecretsMixin':: d.fn(help='ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
    withImagePullSecretsMixin(imagePullSecrets): { spec+: { imagePullSecrets+: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
    '#withNodeSelector':: d.fn(help='NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.', args=[d.arg(name='nodeSelector', type=d.T.object)]),
    withNodeSelector(nodeSelector): { spec+: { nodeSelector: nodeSelector } },
    '#withNodeSelectorMixin':: d.fn(help='NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelector', type=d.T.object)]),
    withNodeSelectorMixin(nodeSelector): { spec+: { nodeSelector+: nodeSelector } },
    '#withOnExit':: d.fn(help='OnExit is a template reference which is invoked at the end of the workflow, irrespective of the success, failure, or error of the primary io.argoproj.workflow.v1alpha1.', args=[d.arg(name='onExit', type=d.T.string)]),
    withOnExit(onExit): { spec+: { onExit: onExit } },
    '#withParallelism':: d.fn(help='Parallelism limits the max total parallel pods that can execute at the same time in a workflow', args=[d.arg(name='parallelism', type=d.T.integer)]),
    withParallelism(parallelism): { spec+: { parallelism: parallelism } },
    '#withPodPriority':: d.fn(help='Priority to apply to workflow pods.', args=[d.arg(name='podPriority', type=d.T.integer)]),
    withPodPriority(podPriority): { spec+: { podPriority: podPriority } },
    '#withPodPriorityClassName':: d.fn(help='PriorityClassName to apply to workflow pods.', args=[d.arg(name='podPriorityClassName', type=d.T.string)]),
    withPodPriorityClassName(podPriorityClassName): { spec+: { podPriorityClassName: podPriorityClassName } },
    '#withPodSpecPatch':: d.fn(help='PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of container fields which are not strings (e.g. resource limits).', args=[d.arg(name='podSpecPatch', type=d.T.string)]),
    withPodSpecPatch(podSpecPatch): { spec+: { podSpecPatch: podSpecPatch } },
    '#withPriority':: d.fn(help='Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first.', args=[d.arg(name='priority', type=d.T.integer)]),
    withPriority(priority): { spec+: { priority: priority } },
    '#withSchedulerName':: d.fn(help="Set scheduler name for all pods. Will be overridden if container/script template's scheduler name is set. Default scheduler will be used if neither specified.", args=[d.arg(name='schedulerName', type=d.T.string)]),
    withSchedulerName(schedulerName): { spec+: { schedulerName: schedulerName } },
    '#withServiceAccountName':: d.fn(help='ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.', args=[d.arg(name='serviceAccountName', type=d.T.string)]),
    withServiceAccountName(serviceAccountName): { spec+: { serviceAccountName: serviceAccountName } },
    '#withShutdown':: d.fn(help='Shutdown will shutdown the workflow according to its ShutdownStrategy', args=[d.arg(name='shutdown', type=d.T.string)]),
    withShutdown(shutdown): { spec+: { shutdown: shutdown } },
    '#withSuspend':: d.fn(help='Suspend will suspend the workflow and prevent execution of any future steps in the workflow', args=[d.arg(name='suspend', type=d.T.boolean)]),
    withSuspend(suspend): { spec+: { suspend: suspend } },
    '#withTemplates':: d.fn(help='Templates is a list of workflow templates used in a workflow', args=[d.arg(name='templates', type=d.T.array)]),
    withTemplates(templates): { spec+: { templates: if std.isArray(v=templates) then templates else [templates] } },
    '#withTemplatesMixin':: d.fn(help='Templates is a list of workflow templates used in a workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='templates', type=d.T.array)]),
    withTemplatesMixin(templates): { spec+: { templates+: if std.isArray(v=templates) then templates else [templates] } },
    '#withTolerations':: d.fn(help='Tolerations to apply to workflow pods.', args=[d.arg(name='tolerations', type=d.T.array)]),
    withTolerations(tolerations): { spec+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } },
    '#withTolerationsMixin':: d.fn(help='Tolerations to apply to workflow pods.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
    withTolerationsMixin(tolerations): { spec+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } },
    '#withTtlSecondsAfterFinished':: d.fn(help='TTLSecondsAfterFinished limits the lifetime of a Workflow that has finished execution (Succeeded, Failed, Error). If this field is set, once the Workflow finishes, it will be deleted after ttlSecondsAfterFinished expires. If this field is unset, ttlSecondsAfterFinished will not expire. If this field is set to zero, ttlSecondsAfterFinished expires immediately after the Workflow finishes. DEPRECATED: Use TTLStrategy.SecondsAfterCompletion instead.', args=[d.arg(name='ttlSecondsAfterFinished', type=d.T.integer)]),
    withTtlSecondsAfterFinished(ttlSecondsAfterFinished): { spec+: { ttlSecondsAfterFinished: ttlSecondsAfterFinished } },
    '#withVolumeClaimTemplates':: d.fn(help='VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow', args=[d.arg(name='volumeClaimTemplates', type=d.T.array)]),
    withVolumeClaimTemplates(volumeClaimTemplates): { spec+: { volumeClaimTemplates: if std.isArray(v=volumeClaimTemplates) then volumeClaimTemplates else [volumeClaimTemplates] } },
    '#withVolumeClaimTemplatesMixin':: d.fn(help='VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeClaimTemplates', type=d.T.array)]),
    withVolumeClaimTemplatesMixin(volumeClaimTemplates): { spec+: { volumeClaimTemplates+: if std.isArray(v=volumeClaimTemplates) then volumeClaimTemplates else [volumeClaimTemplates] } },
    '#withVolumes':: d.fn(help='Volumes is a list of volumes that can be mounted by containers in a io.argoproj.workflow.v1alpha1.', args=[d.arg(name='volumes', type=d.T.array)]),
    withVolumes(volumes): { spec+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } },
    '#withVolumesMixin':: d.fn(help='Volumes is a list of volumes that can be mounted by containers in a io.argoproj.workflow.v1alpha1.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
    withVolumesMixin(volumes): { spec+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } },
    '#workflowMetadata':: d.obj(help='ObjectMeta is metadata that all persisted resources must have, which includes all objects\nusers must create.'),
    workflowMetadata: {
      '#creationTimestamp':: d.obj(help='Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false'),
      creationTimestamp: {
        '#withNanos':: d.fn(help='Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context.', args=[d.arg(name='nanos', type=d.T.integer)]),
        withNanos(nanos): { spec+: { workflowMetadata+: { creationTimestamp+: { nanos: nanos } } } },
        '#withSeconds':: d.fn(help='Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive.', args=[d.arg(name='seconds', type=d.T.string)]),
        withSeconds(seconds): { spec+: { workflowMetadata+: { creationTimestamp+: { seconds: seconds } } } },
      },
      '#deletionTimestamp':: d.obj(help='Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false'),
      deletionTimestamp: {
        '#withNanos':: d.fn(help='Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context.', args=[d.arg(name='nanos', type=d.T.integer)]),
        withNanos(nanos): { spec+: { workflowMetadata+: { deletionTimestamp+: { nanos: nanos } } } },
        '#withSeconds':: d.fn(help='Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive.', args=[d.arg(name='seconds', type=d.T.string)]),
        withSeconds(seconds): { spec+: { workflowMetadata+: { deletionTimestamp+: { seconds: seconds } } } },
      },
      '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotations(annotations): { spec+: { workflowMetadata+: { annotations: annotations } } },
      '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotationsMixin(annotations): { spec+: { workflowMetadata+: { annotations+: annotations } } },
      '#withClusterName':: d.fn(help='', args=[d.arg(name='clusterName', type=d.T.string)]),
      withClusterName(clusterName): { spec+: { workflowMetadata+: { clusterName: clusterName } } },
      '#withDeletionGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.string)]),
      withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { spec+: { workflowMetadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } } },
      '#withFinalizers':: d.fn(help='', args=[d.arg(name='finalizers', type=d.T.array)]),
      withFinalizers(finalizers): { spec+: { workflowMetadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } } },
      '#withFinalizersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
      withFinalizersMixin(finalizers): { spec+: { workflowMetadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } } },
      '#withGenerateName':: d.fn(help='GenerateName is an optional prefix, used by the server, to generate a unique\nname ONLY IF the Name field has not been provided.\nIf this field is used, the name returned to the client will be different\nthan the name passed. This value will also be combined with a unique suffix.\nThe provided value has the same validation rules as the Name field,\nand may be truncated by the length of the suffix required to make the value\nunique on the server.\n\nIf this field is specified and the generated name exists, the server will\nNOT return a 409 - instead, it will either return 201 Created or 500 with Reason\nServerTimeout indicating a unique name could not be found in the time allotted, and the client\nshould retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified.\nMore info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#idempotency\n+optional', args=[d.arg(name='generateName', type=d.T.string)]),
      withGenerateName(generateName): { spec+: { workflowMetadata+: { generateName: generateName } } },
      '#withGeneration':: d.fn(help='', args=[d.arg(name='generation', type=d.T.string)]),
      withGeneration(generation): { spec+: { workflowMetadata+: { generation: generation } } },
      '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
      withLabels(labels): { spec+: { workflowMetadata+: { labels: labels } } },
      '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
      withLabelsMixin(labels): { spec+: { workflowMetadata+: { labels+: labels } } },
      '#withManagedFields':: d.fn(help="ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that io.argoproj.workflow.v1alpha1. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n'ci-cd'. The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional", args=[d.arg(name='managedFields', type=d.T.array)]),
      withManagedFields(managedFields): { spec+: { workflowMetadata+: { managedFields: if std.isArray(v=managedFields) then managedFields else [managedFields] } } },
      '#withManagedFieldsMixin':: d.fn(help="ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that io.argoproj.workflow.v1alpha1. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n'ci-cd'. The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='managedFields', type=d.T.array)]),
      withManagedFieldsMixin(managedFields): { spec+: { workflowMetadata+: { managedFields+: if std.isArray(v=managedFields) then managedFields else [managedFields] } } },
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { workflowMetadata+: { name: name } } },
      '#withNamespace':: d.fn(help='Namespace defines the space within each name must be unique. An empty namespace is\nequivalent to the "default" namespace, but "default" is the canonical representation.\nNot all objects are required to be scoped to a namespace - the value of this field for\nthose objects will be empty.\n\nMust be a DNS_LABEL.\nCannot be updated.\nMore info: http://kubernetes.io/docs/user-guide/namespaces\n+optional', args=[d.arg(name='namespace', type=d.T.string)]),
      withNamespace(namespace): { spec+: { workflowMetadata+: { namespace: namespace } } },
      '#withOwnerReferences':: d.fn(help='', args=[d.arg(name='ownerReferences', type=d.T.array)]),
      withOwnerReferences(ownerReferences): { spec+: { workflowMetadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } } },
      '#withOwnerReferencesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
      withOwnerReferencesMixin(ownerReferences): { spec+: { workflowMetadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } } },
      '#withResourceVersion':: d.fn(help='An opaque value that represents the internal version of this object that can\nbe used by clients to determine when objects have changed. May be used for optimistic\nconcurrency, change detection, and the watch operation on a resource or set of resources.\nClients must treat these values as opaque and passed unmodified back to the server.\nThey may only be valid for a particular resource or set of resources.\n\nPopulated by the system.\nRead-only.\nValue must be treated as opaque by clients and .\nMore info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional', args=[d.arg(name='resourceVersion', type=d.T.string)]),
      withResourceVersion(resourceVersion): { spec+: { workflowMetadata+: { resourceVersion: resourceVersion } } },
      '#withSelfLink':: d.fn(help='SelfLink is a URL representing this object.\nPopulated by the system.\nRead-only.\n\nDEPRECATED\nKubernetes will stop propagating this field in 1.20 release and the field is planned\nto be removed in 1.21 release.\n+optional', args=[d.arg(name='selfLink', type=d.T.string)]),
      withSelfLink(selfLink): { spec+: { workflowMetadata+: { selfLink: selfLink } } },
      '#withUid':: d.fn(help='UID is the unique in time and space value for this object. It is typically generated by\nthe server on successful creation of a resource and is not allowed to change on PUT\noperations.\n\nPopulated by the system.\nRead-only.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#uids\n+optional', args=[d.arg(name='uid', type=d.T.string)]),
      withUid(uid): { spec+: { workflowMetadata+: { uid: uid } } },
    },
    '#workflowTemplateRef':: d.obj(help='WorkflowTemplateRef is a reference to a WorkflowTemplate resource.'),
    workflowTemplateRef: {
      '#withClusterScope':: d.fn(help='ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate).', args=[d.arg(name='clusterScope', type=d.T.boolean)]),
      withClusterScope(clusterScope): { spec+: { workflowTemplateRef+: { clusterScope: clusterScope } } },
      '#withName':: d.fn(help='Name is the resource name of the workflow template.', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { workflowTemplateRef+: { name: name } } },
    },
  },
  '#withKind':: d.fn(help='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds', args=[d.arg(name='kind', type=d.T.string)]),
  withKind(kind): { kind: kind },
  '#mixin': 'ignore',
  mixin: self,
}
