{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='workflowEventBinding', url='', help='WorkflowEventBinding is the definition of an event resource'),
  '#metadata':: d.obj(help='ObjectMeta is metadata that all persisted resources must have, which includes all objects\nusers must create.'),
  metadata: {
    '#creationTimestamp':: d.obj(help='Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false'),
    creationTimestamp: {
      '#withNanos':: d.fn(help='Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context.', args=[d.arg(name='nanos', type=d.T.integer)]),
      withNanos(nanos): { metadata+: { creationTimestamp+: { nanos: nanos } } },
      '#withSeconds':: d.fn(help='Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive.', args=[d.arg(name='seconds', type=d.T.string)]),
      withSeconds(seconds): { metadata+: { creationTimestamp+: { seconds: seconds } } },
    },
    '#deletionTimestamp':: d.obj(help='Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false'),
    deletionTimestamp: {
      '#withNanos':: d.fn(help='Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context.', args=[d.arg(name='nanos', type=d.T.integer)]),
      withNanos(nanos): { metadata+: { deletionTimestamp+: { nanos: nanos } } },
      '#withSeconds':: d.fn(help='Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive.', args=[d.arg(name='seconds', type=d.T.string)]),
      withSeconds(seconds): { metadata+: { deletionTimestamp+: { seconds: seconds } } },
    },
    '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.string)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withFinalizers':: d.fn(help='', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='GenerateName is an optional prefix, used by the server, to generate a unique\nname ONLY IF the Name field has not been provided.\nIf this field is used, the name returned to the client will be different\nthan the name passed. This value will also be combined with a unique suffix.\nThe provided value has the same validation rules as the Name field,\nand may be truncated by the length of the suffix required to make the value\nunique on the server.\n\nIf this field is specified and the generated name exists, the server will\nNOT return a 409 - instead, it will either return 201 Created or 500 with Reason\nServerTimeout indicating a unique name could not be found in the time allotted, and the client\nshould retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified.\nMore info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#idempotency\n+optional', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='', args=[d.arg(name='generation', type=d.T.string)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withManagedFields':: d.fn(help="ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that io.argoproj.workflow.v1alpha1. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n'ci-cd'. The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional", args=[d.arg(name='managedFields', type=d.T.array)]),
    withManagedFields(managedFields): { metadata+: { managedFields: if std.isArray(v=managedFields) then managedFields else [managedFields] } },
    '#withManagedFieldsMixin':: d.fn(help="ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that io.argoproj.workflow.v1alpha1. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n'ci-cd'. The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='managedFields', type=d.T.array)]),
    withManagedFieldsMixin(managedFields): { metadata+: { managedFields+: if std.isArray(v=managedFields) then managedFields else [managedFields] } },
    '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='Namespace defines the space within each name must be unique. An empty namespace is\nequivalent to the "default" namespace, but "default" is the canonical representation.\nNot all objects are required to be scoped to a namespace - the value of this field for\nthose objects will be empty.\n\nMust be a DNS_LABEL.\nCannot be updated.\nMore info: http://kubernetes.io/docs/user-guide/namespaces\n+optional', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='An opaque value that represents the internal version of this object that can\nbe used by clients to determine when objects have changed. May be used for optimistic\nconcurrency, change detection, and the watch operation on a resource or set of resources.\nClients must treat these values as opaque and passed unmodified back to the server.\nThey may only be valid for a particular resource or set of resources.\n\nPopulated by the system.\nRead-only.\nValue must be treated as opaque by clients and .\nMore info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='SelfLink is a URL representing this object.\nPopulated by the system.\nRead-only.\n\nDEPRECATED\nKubernetes will stop propagating this field in 1.20 release and the field is planned\nto be removed in 1.21 release.\n+optional', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='UID is the unique in time and space value for this object. It is typically generated by\nthe server on successful creation of a resource and is not allowed to change on PUT\noperations.\n\nPopulated by the system.\nRead-only.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#uids\n+optional', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#spec':: d.obj(help=''),
  spec: {
    '#event':: d.obj(help=''),
    event: {
      '#withSelector':: d.fn(help='Selector (https://github.com/antonmedv/expr) that we must must match the io.argoproj.workflow.v1alpha1. E.g. `payload.message == "test"`', args=[d.arg(name='selector', type=d.T.string)]),
      withSelector(selector): { spec+: { event+: { selector: selector } } },
    },
    '#submit':: d.obj(help=''),
    submit: {
      '#arguments':: d.obj(help='Arguments to a template'),
      arguments: {
        '#withArtifacts':: d.fn(help='Artifacts is the list of artifacts to pass to the template or workflow', args=[d.arg(name='artifacts', type=d.T.array)]),
        withArtifacts(artifacts): { spec+: { submit+: { arguments+: { artifacts: if std.isArray(v=artifacts) then artifacts else [artifacts] } } } },
        '#withArtifactsMixin':: d.fn(help='Artifacts is the list of artifacts to pass to the template or workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='artifacts', type=d.T.array)]),
        withArtifactsMixin(artifacts): { spec+: { submit+: { arguments+: { artifacts+: if std.isArray(v=artifacts) then artifacts else [artifacts] } } } },
        '#withParameters':: d.fn(help='Parameters is the list of parameters to pass to the template or workflow', args=[d.arg(name='parameters', type=d.T.array)]),
        withParameters(parameters): { spec+: { submit+: { arguments+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } } },
        '#withParametersMixin':: d.fn(help='Parameters is the list of parameters to pass to the template or workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
        withParametersMixin(parameters): { spec+: { submit+: { arguments+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } } },
      },
      '#metadata':: d.obj(help='ObjectMeta is metadata that all persisted resources must have, which includes all objects\nusers must create.'),
      metadata: {
        '#creationTimestamp':: d.obj(help='Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false'),
        creationTimestamp: {
          '#withNanos':: d.fn(help='Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context.', args=[d.arg(name='nanos', type=d.T.integer)]),
          withNanos(nanos): { spec+: { submit+: { metadata+: { creationTimestamp+: { nanos: nanos } } } } },
          '#withSeconds':: d.fn(help='Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive.', args=[d.arg(name='seconds', type=d.T.string)]),
          withSeconds(seconds): { spec+: { submit+: { metadata+: { creationTimestamp+: { seconds: seconds } } } } },
        },
        '#deletionTimestamp':: d.obj(help='Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false'),
        deletionTimestamp: {
          '#withNanos':: d.fn(help='Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context.', args=[d.arg(name='nanos', type=d.T.integer)]),
          withNanos(nanos): { spec+: { submit+: { metadata+: { deletionTimestamp+: { nanos: nanos } } } } },
          '#withSeconds':: d.fn(help='Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive.', args=[d.arg(name='seconds', type=d.T.string)]),
          withSeconds(seconds): { spec+: { submit+: { metadata+: { deletionTimestamp+: { seconds: seconds } } } } },
        },
        '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotations(annotations): { spec+: { submit+: { metadata+: { annotations: annotations } } } },
        '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotationsMixin(annotations): { spec+: { submit+: { metadata+: { annotations+: annotations } } } },
        '#withClusterName':: d.fn(help='', args=[d.arg(name='clusterName', type=d.T.string)]),
        withClusterName(clusterName): { spec+: { submit+: { metadata+: { clusterName: clusterName } } } },
        '#withDeletionGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.string)]),
        withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { spec+: { submit+: { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } } } },
        '#withFinalizers':: d.fn(help='', args=[d.arg(name='finalizers', type=d.T.array)]),
        withFinalizers(finalizers): { spec+: { submit+: { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } } } },
        '#withFinalizersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
        withFinalizersMixin(finalizers): { spec+: { submit+: { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } } } },
        '#withGenerateName':: d.fn(help='GenerateName is an optional prefix, used by the server, to generate a unique\nname ONLY IF the Name field has not been provided.\nIf this field is used, the name returned to the client will be different\nthan the name passed. This value will also be combined with a unique suffix.\nThe provided value has the same validation rules as the Name field,\nand may be truncated by the length of the suffix required to make the value\nunique on the server.\n\nIf this field is specified and the generated name exists, the server will\nNOT return a 409 - instead, it will either return 201 Created or 500 with Reason\nServerTimeout indicating a unique name could not be found in the time allotted, and the client\nshould retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified.\nMore info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#idempotency\n+optional', args=[d.arg(name='generateName', type=d.T.string)]),
        withGenerateName(generateName): { spec+: { submit+: { metadata+: { generateName: generateName } } } },
        '#withGeneration':: d.fn(help='', args=[d.arg(name='generation', type=d.T.string)]),
        withGeneration(generation): { spec+: { submit+: { metadata+: { generation: generation } } } },
        '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
        withLabels(labels): { spec+: { submit+: { metadata+: { labels: labels } } } },
        '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
        withLabelsMixin(labels): { spec+: { submit+: { metadata+: { labels+: labels } } } },
        '#withManagedFields':: d.fn(help="ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that io.argoproj.workflow.v1alpha1. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n'ci-cd'. The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional", args=[d.arg(name='managedFields', type=d.T.array)]),
        withManagedFields(managedFields): { spec+: { submit+: { metadata+: { managedFields: if std.isArray(v=managedFields) then managedFields else [managedFields] } } } },
        '#withManagedFieldsMixin':: d.fn(help="ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that io.argoproj.workflow.v1alpha1. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n'ci-cd'. The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='managedFields', type=d.T.array)]),
        withManagedFieldsMixin(managedFields): { spec+: { submit+: { metadata+: { managedFields+: if std.isArray(v=managedFields) then managedFields else [managedFields] } } } },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { submit+: { metadata+: { name: name } } } },
        '#withNamespace':: d.fn(help='Namespace defines the space within each name must be unique. An empty namespace is\nequivalent to the "default" namespace, but "default" is the canonical representation.\nNot all objects are required to be scoped to a namespace - the value of this field for\nthose objects will be empty.\n\nMust be a DNS_LABEL.\nCannot be updated.\nMore info: http://kubernetes.io/docs/user-guide/namespaces\n+optional', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { submit+: { metadata+: { namespace: namespace } } } },
        '#withOwnerReferences':: d.fn(help='', args=[d.arg(name='ownerReferences', type=d.T.array)]),
        withOwnerReferences(ownerReferences): { spec+: { submit+: { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } } } },
        '#withOwnerReferencesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
        withOwnerReferencesMixin(ownerReferences): { spec+: { submit+: { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } } } },
        '#withResourceVersion':: d.fn(help='An opaque value that represents the internal version of this object that can\nbe used by clients to determine when objects have changed. May be used for optimistic\nconcurrency, change detection, and the watch operation on a resource or set of resources.\nClients must treat these values as opaque and passed unmodified back to the server.\nThey may only be valid for a particular resource or set of resources.\n\nPopulated by the system.\nRead-only.\nValue must be treated as opaque by clients and .\nMore info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional', args=[d.arg(name='resourceVersion', type=d.T.string)]),
        withResourceVersion(resourceVersion): { spec+: { submit+: { metadata+: { resourceVersion: resourceVersion } } } },
        '#withSelfLink':: d.fn(help='SelfLink is a URL representing this object.\nPopulated by the system.\nRead-only.\n\nDEPRECATED\nKubernetes will stop propagating this field in 1.20 release and the field is planned\nto be removed in 1.21 release.\n+optional', args=[d.arg(name='selfLink', type=d.T.string)]),
        withSelfLink(selfLink): { spec+: { submit+: { metadata+: { selfLink: selfLink } } } },
        '#withUid':: d.fn(help='UID is the unique in time and space value for this object. It is typically generated by\nthe server on successful creation of a resource and is not allowed to change on PUT\noperations.\n\nPopulated by the system.\nRead-only.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#uids\n+optional', args=[d.arg(name='uid', type=d.T.string)]),
        withUid(uid): { spec+: { submit+: { metadata+: { uid: uid } } } },
      },
      '#workflowTemplateRef':: d.obj(help='WorkflowTemplateRef is a reference to a WorkflowTemplate resource.'),
      workflowTemplateRef: {
        '#withClusterScope':: d.fn(help='ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate).', args=[d.arg(name='clusterScope', type=d.T.boolean)]),
        withClusterScope(clusterScope): { spec+: { submit+: { workflowTemplateRef+: { clusterScope: clusterScope } } } },
        '#withName':: d.fn(help='Name is the resource name of the workflow template.', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { submit+: { workflowTemplateRef+: { name: name } } } },
      },
    },
  },
  '#withKind':: d.fn(help='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds', args=[d.arg(name='kind', type=d.T.string)]),
  withKind(kind): { kind: kind },
  '#mixin': 'ignore',
  mixin: self,
}
