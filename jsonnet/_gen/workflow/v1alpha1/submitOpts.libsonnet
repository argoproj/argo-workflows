{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='submitOpts', url='', help='SubmitOpts are workflow submission options'),
  '#ownerReference':: d.obj(help='OwnerReference contains enough information to let you identify an owning\nobject. An owning object must be in the same namespace as the dependent, or\nbe cluster-scoped, so there is no namespace field.'),
  ownerReference: {
    '#withBlockOwnerDeletion':: d.fn(help='', args=[d.arg(name='blockOwnerDeletion', type=d.T.boolean)]),
    withBlockOwnerDeletion(blockOwnerDeletion): { ownerReference+: { blockOwnerDeletion: blockOwnerDeletion } },
    '#withController':: d.fn(help='', args=[d.arg(name='controller', type=d.T.boolean)]),
    withController(controller): { ownerReference+: { controller: controller } },
    '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
    withKind(kind): { ownerReference+: { kind: kind } },
    '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { ownerReference+: { name: name } },
    '#withUid':: d.fn(help='', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { ownerReference+: { uid: uid } },
  },
  '#withDryRun':: d.fn(help='DryRun validates the workflow on the client-side without creating it. This option is not supported in API', args=[d.arg(name='dryRun', type=d.T.boolean)]),
  withDryRun(dryRun): { dryRun: dryRun },
  '#withEntryPoint':: d.fn(help='Entrypoint overrides spec.entrypoint', args=[d.arg(name='entryPoint', type=d.T.string)]),
  withEntryPoint(entryPoint): { entryPoint: entryPoint },
  '#withGenerateName':: d.fn(help='GenerateName overrides metadata.generateName', args=[d.arg(name='generateName', type=d.T.string)]),
  withGenerateName(generateName): { generateName: generateName },
  '#withLabels':: d.fn(help='Labels adds to metadata.labels', args=[d.arg(name='labels', type=d.T.string)]),
  withLabels(labels): { labels: labels },
  '#withName':: d.fn(help='Name overrides metadata.name', args=[d.arg(name='name', type=d.T.string)]),
  withName(name): { name: name },
  '#withParameterFile':: d.fn(help='ParameterFile holds a reference to a parameter file. This option is not supported in API', args=[d.arg(name='parameterFile', type=d.T.string)]),
  withParameterFile(parameterFile): { parameterFile: parameterFile },
  '#withParameters':: d.fn(help='Parameters passes input parameters to workflow', args=[d.arg(name='parameters', type=d.T.array)]),
  withParameters(parameters): { parameters: if std.isArray(v=parameters) then parameters else [parameters] },
  '#withParametersMixin':: d.fn(help='Parameters passes input parameters to workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
  withParametersMixin(parameters): { parameters+: if std.isArray(v=parameters) then parameters else [parameters] },
  '#withServerDryRun':: d.fn(help='ServerDryRun validates the workflow on the server-side without creating it', args=[d.arg(name='serverDryRun', type=d.T.boolean)]),
  withServerDryRun(serverDryRun): { serverDryRun: serverDryRun },
  '#withServiceAccount':: d.fn(help='ServiceAccount runs all pods in the workflow using specified ServiceAccount.', args=[d.arg(name='serviceAccount', type=d.T.string)]),
  withServiceAccount(serviceAccount): { serviceAccount: serviceAccount },
  '#mixin': 'ignore',
  mixin: self,
}
