{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='prometheus', url='', help='Prometheus is a prometheus metric to be emitted'),
  '#counter':: d.obj(help='Counter is a Counter prometheus metric'),
  counter: {
    '#withValue':: d.fn(help='Value is the value of the metric', args=[d.arg(name='value', type=d.T.string)]),
    withValue(value): { counter+: { value: value } },
  },
  '#gauge':: d.obj(help='Gauge is a Gauge prometheus metric'),
  gauge: {
    '#withRealtime':: d.fn(help='Realtime emits this metric in real time if applicable', args=[d.arg(name='realtime', type=d.T.boolean)]),
    withRealtime(realtime): { gauge+: { realtime: realtime } },
    '#withValue':: d.fn(help='Value is the value of the metric', args=[d.arg(name='value', type=d.T.string)]),
    withValue(value): { gauge+: { value: value } },
  },
  '#histogram':: d.obj(help='Histogram is a Histogram prometheus metric'),
  histogram: {
    '#withBuckets':: d.fn(help='Buckets is a list of bucket divisors for the histogram', args=[d.arg(name='buckets', type=d.T.array)]),
    withBuckets(buckets): { histogram+: { buckets: if std.isArray(v=buckets) then buckets else [buckets] } },
    '#withBucketsMixin':: d.fn(help='Buckets is a list of bucket divisors for the histogram\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='buckets', type=d.T.array)]),
    withBucketsMixin(buckets): { histogram+: { buckets+: if std.isArray(v=buckets) then buckets else [buckets] } },
    '#withValue':: d.fn(help='Value is the value of the metric', args=[d.arg(name='value', type=d.T.string)]),
    withValue(value): { histogram+: { value: value } },
  },
  '#withHelp':: d.fn(help='Help is a string that describes the metric', args=[d.arg(name='help', type=d.T.string)]),
  withHelp(help): { help: help },
  '#withLabels':: d.fn(help='Labels is a list of metric labels', args=[d.arg(name='labels', type=d.T.array)]),
  withLabels(labels): { labels: if std.isArray(v=labels) then labels else [labels] },
  '#withLabelsMixin':: d.fn(help='Labels is a list of metric labels\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.array)]),
  withLabelsMixin(labels): { labels+: if std.isArray(v=labels) then labels else [labels] },
  '#withName':: d.fn(help='Name is the name of the metric', args=[d.arg(name='name', type=d.T.string)]),
  withName(name): { name: name },
  '#withWhen':: d.fn(help='When is a conditional statement that decides when to emit the metric', args=[d.arg(name='when', type=d.T.string)]),
  withWhen(when): { when: when },
  '#mixin': 'ignore',
  mixin: self,
}
