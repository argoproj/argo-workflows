{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='workflowStep', url='', help='WorkflowStep is a reference to a template to execute in a series of step'),
  '#arguments':: d.obj(help='Arguments to a template'),
  arguments: {
    '#withArtifacts':: d.fn(help='Artifacts is the list of artifacts to pass to the template or workflow', args=[d.arg(name='artifacts', type=d.T.array)]),
    withArtifacts(artifacts): { arguments+: { artifacts: if std.isArray(v=artifacts) then artifacts else [artifacts] } },
    '#withArtifactsMixin':: d.fn(help='Artifacts is the list of artifacts to pass to the template or workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='artifacts', type=d.T.array)]),
    withArtifactsMixin(artifacts): { arguments+: { artifacts+: if std.isArray(v=artifacts) then artifacts else [artifacts] } },
    '#withParameters':: d.fn(help='Parameters is the list of parameters to pass to the template or workflow', args=[d.arg(name='parameters', type=d.T.array)]),
    withParameters(parameters): { arguments+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withParametersMixin':: d.fn(help='Parameters is the list of parameters to pass to the template or workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
    withParametersMixin(parameters): { arguments+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } },
  },
  '#continueOn':: d.obj(help='ContinueOn defines if a workflow should continue even if a task or step fails/errors. It can be specified if the workflow should continue when the pod errors, fails or both.'),
  continueOn: {
    '#withError':: d.fn(help='', args=[d.arg(name='err', type=d.T.boolean)]),
    withError(err): { continueOn+: { 'error': err } },
    '#withFailed':: d.fn(help='', args=[d.arg(name='failed', type=d.T.boolean)]),
    withFailed(failed): { continueOn+: { failed: failed } },
  },
  '#templateRef':: d.obj(help='TemplateRef is a reference of template resource.'),
  templateRef: {
    '#withClusterScope':: d.fn(help='ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate).', args=[d.arg(name='clusterScope', type=d.T.boolean)]),
    withClusterScope(clusterScope): { templateRef+: { clusterScope: clusterScope } },
    '#withName':: d.fn(help='Name is the resource name of the template.', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { templateRef+: { name: name } },
    '#withRuntimeResolution':: d.fn(help='RuntimeResolution skips validation at creation time. By enabling this option, you can create the referred workflow template before the actual runtime. DEPRECATED: This value is not used anymore and is ignored', args=[d.arg(name='runtimeResolution', type=d.T.boolean)]),
    withRuntimeResolution(runtimeResolution): { templateRef+: { runtimeResolution: runtimeResolution } },
    '#withTemplate':: d.fn(help='Template is the name of referred template in the resource.', args=[d.arg(name='template', type=d.T.string)]),
    withTemplate(template): { templateRef+: { template: template } },
  },
  '#withName':: d.fn(help='Name of the step', args=[d.arg(name='name', type=d.T.string)]),
  withName(name): { name: name },
  '#withOnExit':: d.fn(help='OnExit is a template reference which is invoked at the end of the template, irrespective of the success, failure, or error of the primary template.', args=[d.arg(name='onExit', type=d.T.string)]),
  withOnExit(onExit): { onExit: onExit },
  '#withSequence':: d.obj(help='Sequence expands a workflow step into numeric range'),
  withSequence: {
    '#count':: d.obj(help='+protobuf=true\n+protobuf.options.(gogoproto.goproto_stringer)=false\n+k8s:openapi-gen=true'),
    count: {
      '#withIntVal':: d.fn(help='', args=[d.arg(name='intVal', type=d.T.integer)]),
      withIntVal(intVal): { withSequence+: { count+: { intVal: intVal } } },
      '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
      withStrVal(strVal): { withSequence+: { count+: { strVal: strVal } } },
      '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { withSequence+: { count+: { type: type } } },
    },
    '#end':: d.obj(help='+protobuf=true\n+protobuf.options.(gogoproto.goproto_stringer)=false\n+k8s:openapi-gen=true'),
    end: {
      '#withIntVal':: d.fn(help='', args=[d.arg(name='intVal', type=d.T.integer)]),
      withIntVal(intVal): { withSequence+: { end+: { intVal: intVal } } },
      '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
      withStrVal(strVal): { withSequence+: { end+: { strVal: strVal } } },
      '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { withSequence+: { end+: { type: type } } },
    },
    '#start':: d.obj(help='+protobuf=true\n+protobuf.options.(gogoproto.goproto_stringer)=false\n+k8s:openapi-gen=true'),
    start: {
      '#withIntVal':: d.fn(help='', args=[d.arg(name='intVal', type=d.T.integer)]),
      withIntVal(intVal): { withSequence+: { start+: { intVal: intVal } } },
      '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
      withStrVal(strVal): { withSequence+: { start+: { strVal: strVal } } },
      '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { withSequence+: { start+: { type: type } } },
    },
    '#withFormat':: d.fn(help='Format is a printf format string to format the value in the sequence', args=[d.arg(name='format', type=d.T.string)]),
    withFormat(format): { withSequence+: { format: format } },
  },
  '#withTemplate':: d.fn(help='Template is the name of the template to execute as the step', args=[d.arg(name='template', type=d.T.string)]),
  withTemplate(template): { template: template },
  '#withWhen':: d.fn(help='When is an expression in which the step should conditionally execute', args=[d.arg(name='when', type=d.T.string)]),
  withWhen(when): { when: when },
  '#withWithItems':: d.fn(help='WithItems expands a step into multiple parallel steps from the items in the list', args=[d.arg(name='withItems', type=d.T.array)]),
  withWithItems(withItems): { withItems: if std.isArray(v=withItems) then withItems else [withItems] },
  '#withWithItemsMixin':: d.fn(help='WithItems expands a step into multiple parallel steps from the items in the list\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='withItems', type=d.T.array)]),
  withWithItemsMixin(withItems): { withItems+: if std.isArray(v=withItems) then withItems else [withItems] },
  '#withWithParam':: d.fn(help='WithParam expands a step into multiple parallel steps from the value in the parameter, which is expected to be a JSON list.', args=[d.arg(name='withParam', type=d.T.string)]),
  withWithParam(withParam): { withParam: withParam },
  '#mixin': 'ignore',
  mixin: self,
}
