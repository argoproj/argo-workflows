{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='workflowStatus', url='', help='WorkflowStatus contains overall status information about a workflow'),
  '#artifactRepositoryRef':: d.obj(help=''),
  artifactRepositoryRef: {
    '#withConfigMap':: d.fn(help='The name of the config map. Defaults to "artifact-repositories".', args=[d.arg(name='configMap', type=d.T.string)]),
    withConfigMap(configMap): { artifactRepositoryRef+: { configMap: configMap } },
    '#withDefault':: d.fn(help='If this ref represents the default artifact repository, rather than a config map.', args=[d.arg(name='default', type=d.T.boolean)]),
    withDefault(default): { artifactRepositoryRef+: { default: default } },
    '#withKey':: d.fn(help='The config map key. Defaults to the value of the "workflows.argoproj.io/default-artifact-repository" annotation.', args=[d.arg(name='key', type=d.T.string)]),
    withKey(key): { artifactRepositoryRef+: { key: key } },
    '#withNamespace':: d.fn(help="The namespace of the config map. Defaults to the workflow's namespace, or the controller's namespace (if found).", args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { artifactRepositoryRef+: { namespace: namespace } },
  },
  '#finishedAt':: d.obj(help='Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false'),
  finishedAt: {
    '#withNanos':: d.fn(help='Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context.', args=[d.arg(name='nanos', type=d.T.integer)]),
    withNanos(nanos): { finishedAt+: { nanos: nanos } },
    '#withSeconds':: d.fn(help='Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive.', args=[d.arg(name='seconds', type=d.T.string)]),
    withSeconds(seconds): { finishedAt+: { seconds: seconds } },
  },
  '#outputs':: d.obj(help='Outputs hold parameters, artifacts, and results from a step'),
  outputs: {
    '#withArtifacts':: d.fn(help='Artifacts holds the list of output artifacts produced by a step', args=[d.arg(name='artifacts', type=d.T.array)]),
    withArtifacts(artifacts): { outputs+: { artifacts: if std.isArray(v=artifacts) then artifacts else [artifacts] } },
    '#withArtifactsMixin':: d.fn(help='Artifacts holds the list of output artifacts produced by a step\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='artifacts', type=d.T.array)]),
    withArtifactsMixin(artifacts): { outputs+: { artifacts+: if std.isArray(v=artifacts) then artifacts else [artifacts] } },
    '#withExitCode':: d.fn(help='ExitCode holds the exit code of a script template', args=[d.arg(name='exitCode', type=d.T.string)]),
    withExitCode(exitCode): { outputs+: { exitCode: exitCode } },
    '#withParameters':: d.fn(help='Parameters holds the list of output parameters produced by a step', args=[d.arg(name='parameters', type=d.T.array)]),
    withParameters(parameters): { outputs+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withParametersMixin':: d.fn(help='Parameters holds the list of output parameters produced by a step\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
    withParametersMixin(parameters): { outputs+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } },
    '#withResult':: d.fn(help='Result holds the result (stdout) of a script template', args=[d.arg(name='result', type=d.T.string)]),
    withResult(result): { outputs+: { result: result } },
  },
  '#startedAt':: d.obj(help='Time is a wrapper around time.Time which supports correct\nmarshaling to YAML and JSON.  Wrappers are provided for many\nof the factory methods that the time package offers.\n\n+protobuf.options.marshal=false\n+protobuf.as=Timestamp\n+protobuf.options.(gogoproto.goproto_stringer)=false'),
  startedAt: {
    '#withNanos':: d.fn(help='Non-negative fractions of a second at nanosecond resolution. Negative\nsecond values with fractions must still have non-negative nanos values\nthat count forward in time. Must be from 0 to 999,999,999\ninclusive. This field may be limited in precision depending on context.', args=[d.arg(name='nanos', type=d.T.integer)]),
    withNanos(nanos): { startedAt+: { nanos: nanos } },
    '#withSeconds':: d.fn(help='Represents seconds of UTC time since Unix epoch\n1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n9999-12-31T23:59:59Z inclusive.', args=[d.arg(name='seconds', type=d.T.string)]),
    withSeconds(seconds): { startedAt+: { seconds: seconds } },
  },
  '#storedWorkflowTemplateSpec':: d.obj(help='WorkflowSpec is the specification of a Workflow.'),
  storedWorkflowTemplateSpec: {
    '#affinity':: d.obj(help='Affinity is a group of affinity scheduling rules.'),
    affinity: {
      '#nodeAffinity':: d.obj(help='Node affinity is a group of node affinity scheduling rules.'),
      nodeAffinity: {
        '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help='A node selector represents the union of the results of one or more label queries\nover a set of nodes; that is, it represents the OR of the selectors represented\nby the node selector terms.'),
        requiredDuringSchedulingIgnoredDuringExecution: {
          '#withNodeSelectorTerms':: d.fn(help='Required. A list of node selector terms. The terms are ORed.', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
          withNodeSelectorTerms(nodeSelectorTerms): { storedWorkflowTemplateSpec+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } },
          '#withNodeSelectorTermsMixin':: d.fn(help='Required. A list of node selector terms. The terms are ORed.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
          withNodeSelectorTermsMixin(nodeSelectorTerms): { storedWorkflowTemplateSpec+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } },
        },
        '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { storedWorkflowTemplateSpec+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { storedWorkflowTemplateSpec+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
      },
      '#podAffinity':: d.obj(help='Pod affinity is a group of inter pod affinity scheduling rules.'),
      podAffinity: {
        '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { storedWorkflowTemplateSpec+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { storedWorkflowTemplateSpec+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { storedWorkflowTemplateSpec+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { storedWorkflowTemplateSpec+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } },
      },
      '#podAntiAffinity':: d.obj(help='Pod anti affinity is a group of inter pod anti affinity scheduling rules.'),
      podAntiAffinity: {
        '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { storedWorkflowTemplateSpec+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { storedWorkflowTemplateSpec+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { storedWorkflowTemplateSpec+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } },
        '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
        withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { storedWorkflowTemplateSpec+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } },
      },
    },
    '#arguments':: d.obj(help='Arguments to a template'),
    arguments: {
      '#withArtifacts':: d.fn(help='Artifacts is the list of artifacts to pass to the template or workflow', args=[d.arg(name='artifacts', type=d.T.array)]),
      withArtifacts(artifacts): { storedWorkflowTemplateSpec+: { arguments+: { artifacts: if std.isArray(v=artifacts) then artifacts else [artifacts] } } },
      '#withArtifactsMixin':: d.fn(help='Artifacts is the list of artifacts to pass to the template or workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='artifacts', type=d.T.array)]),
      withArtifactsMixin(artifacts): { storedWorkflowTemplateSpec+: { arguments+: { artifacts+: if std.isArray(v=artifacts) then artifacts else [artifacts] } } },
      '#withParameters':: d.fn(help='Parameters is the list of parameters to pass to the template or workflow', args=[d.arg(name='parameters', type=d.T.array)]),
      withParameters(parameters): { storedWorkflowTemplateSpec+: { arguments+: { parameters: if std.isArray(v=parameters) then parameters else [parameters] } } },
      '#withParametersMixin':: d.fn(help='Parameters is the list of parameters to pass to the template or workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='parameters', type=d.T.array)]),
      withParametersMixin(parameters): { storedWorkflowTemplateSpec+: { arguments+: { parameters+: if std.isArray(v=parameters) then parameters else [parameters] } } },
    },
    '#artifactRepositoryRef':: d.obj(help=''),
    artifactRepositoryRef: {
      '#withConfigMap':: d.fn(help='The name of the config map. Defaults to "artifact-repositories".', args=[d.arg(name='configMap', type=d.T.string)]),
      withConfigMap(configMap): { storedWorkflowTemplateSpec+: { artifactRepositoryRef+: { configMap: configMap } } },
      '#withKey':: d.fn(help='The config map key. Defaults to the value of the "workflows.argoproj.io/default-artifact-repository" annotation.', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { storedWorkflowTemplateSpec+: { artifactRepositoryRef+: { key: key } } },
    },
    '#dnsConfig':: d.obj(help='PodDNSConfig defines the DNS parameters of a pod in addition to\nthose generated from DNSPolicy.'),
    dnsConfig: {
      '#withNameservers':: d.fn(help='', args=[d.arg(name='nameservers', type=d.T.array)]),
      withNameservers(nameservers): { storedWorkflowTemplateSpec+: { dnsConfig+: { nameservers: if std.isArray(v=nameservers) then nameservers else [nameservers] } } },
      '#withNameserversMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nameservers', type=d.T.array)]),
      withNameserversMixin(nameservers): { storedWorkflowTemplateSpec+: { dnsConfig+: { nameservers+: if std.isArray(v=nameservers) then nameservers else [nameservers] } } },
      '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.array)]),
      withOptions(options): { storedWorkflowTemplateSpec+: { dnsConfig+: { options: if std.isArray(v=options) then options else [options] } } },
      '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.array)]),
      withOptionsMixin(options): { storedWorkflowTemplateSpec+: { dnsConfig+: { options+: if std.isArray(v=options) then options else [options] } } },
      '#withSearches':: d.fn(help='', args=[d.arg(name='searches', type=d.T.array)]),
      withSearches(searches): { storedWorkflowTemplateSpec+: { dnsConfig+: { searches: if std.isArray(v=searches) then searches else [searches] } } },
      '#withSearchesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='searches', type=d.T.array)]),
      withSearchesMixin(searches): { storedWorkflowTemplateSpec+: { dnsConfig+: { searches+: if std.isArray(v=searches) then searches else [searches] } } },
    },
    '#executor':: d.obj(help='ExecutorConfig holds configurations of an executor container.'),
    executor: {
      '#withServiceAccountName':: d.fn(help='ServiceAccountName specifies the service account name of the executor container.', args=[d.arg(name='serviceAccountName', type=d.T.string)]),
      withServiceAccountName(serviceAccountName): { storedWorkflowTemplateSpec+: { executor+: { serviceAccountName: serviceAccountName } } },
    },
    '#metrics':: d.obj(help='Metrics are a list of metrics emitted from a Workflow/Template'),
    metrics: {
      '#withPrometheus':: d.fn(help='Prometheus is a list of prometheus metrics to be emitted', args=[d.arg(name='prometheus', type=d.T.array)]),
      withPrometheus(prometheus): { storedWorkflowTemplateSpec+: { metrics+: { prometheus: if std.isArray(v=prometheus) then prometheus else [prometheus] } } },
      '#withPrometheusMixin':: d.fn(help='Prometheus is a list of prometheus metrics to be emitted\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='prometheus', type=d.T.array)]),
      withPrometheusMixin(prometheus): { storedWorkflowTemplateSpec+: { metrics+: { prometheus+: if std.isArray(v=prometheus) then prometheus else [prometheus] } } },
    },
    '#podDisruptionBudget':: d.obj(help='PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.'),
    podDisruptionBudget: {
      '#maxUnavailable':: d.obj(help='+protobuf=true\n+protobuf.options.(gogoproto.goproto_stringer)=false\n+k8s:openapi-gen=true'),
      maxUnavailable: {
        '#withIntVal':: d.fn(help='', args=[d.arg(name='intVal', type=d.T.integer)]),
        withIntVal(intVal): { storedWorkflowTemplateSpec+: { podDisruptionBudget+: { maxUnavailable+: { intVal: intVal } } } },
        '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
        withStrVal(strVal): { storedWorkflowTemplateSpec+: { podDisruptionBudget+: { maxUnavailable+: { strVal: strVal } } } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { storedWorkflowTemplateSpec+: { podDisruptionBudget+: { maxUnavailable+: { type: type } } } },
      },
      '#minAvailable':: d.obj(help='+protobuf=true\n+protobuf.options.(gogoproto.goproto_stringer)=false\n+k8s:openapi-gen=true'),
      minAvailable: {
        '#withIntVal':: d.fn(help='', args=[d.arg(name='intVal', type=d.T.integer)]),
        withIntVal(intVal): { storedWorkflowTemplateSpec+: { podDisruptionBudget+: { minAvailable+: { intVal: intVal } } } },
        '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
        withStrVal(strVal): { storedWorkflowTemplateSpec+: { podDisruptionBudget+: { minAvailable+: { strVal: strVal } } } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { storedWorkflowTemplateSpec+: { podDisruptionBudget+: { minAvailable+: { type: type } } } },
      },
      '#selector':: d.obj(help='A label selector is a label query over a set of resources. The result of matchLabels and\nmatchExpressions are ANDed. An empty label selector matches all objects. A null\nlabel selector matches no objects.'),
      selector: {
        '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
        withMatchExpressions(matchExpressions): { storedWorkflowTemplateSpec+: { podDisruptionBudget+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } },
        '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
        withMatchExpressionsMixin(matchExpressions): { storedWorkflowTemplateSpec+: { podDisruptionBudget+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } },
        '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { storedWorkflowTemplateSpec+: { podDisruptionBudget+: { selector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { storedWorkflowTemplateSpec+: { podDisruptionBudget+: { selector+: { matchLabels+: matchLabels } } } },
      },
    },
    '#podGC':: d.obj(help='PodGC describes how to delete completed pods as they complete'),
    podGC: {
      '#withStrategy':: d.fn(help='Strategy is the strategy to use. One of "OnPodCompletion", "OnPodSuccess", "OnWorkflowCompletion", "OnWorkflowSuccess"', args=[d.arg(name='strategy', type=d.T.string)]),
      withStrategy(strategy): { storedWorkflowTemplateSpec+: { podGC+: { strategy: strategy } } },
    },
    '#retryStrategy':: d.obj(help='RetryStrategy provides controls on how to retry a workflow step'),
    retryStrategy: {
      '#backoff':: d.obj(help='Backoff is a backoff strategy to use within retryStrategy'),
      backoff: {
        '#factor':: d.obj(help='+protobuf=true\n+protobuf.options.(gogoproto.goproto_stringer)=false\n+k8s:openapi-gen=true'),
        factor: {
          '#withIntVal':: d.fn(help='', args=[d.arg(name='intVal', type=d.T.integer)]),
          withIntVal(intVal): { storedWorkflowTemplateSpec+: { retryStrategy+: { backoff+: { factor+: { intVal: intVal } } } } },
          '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
          withStrVal(strVal): { storedWorkflowTemplateSpec+: { retryStrategy+: { backoff+: { factor+: { strVal: strVal } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { storedWorkflowTemplateSpec+: { retryStrategy+: { backoff+: { factor+: { type: type } } } } },
        },
        '#withDuration':: d.fn(help='Duration is the amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h")', args=[d.arg(name='duration', type=d.T.string)]),
        withDuration(duration): { storedWorkflowTemplateSpec+: { retryStrategy+: { backoff+: { duration: duration } } } },
        '#withMaxDuration':: d.fn(help='MaxDuration is the maximum amount of time allowed for the backoff strategy', args=[d.arg(name='maxDuration', type=d.T.string)]),
        withMaxDuration(maxDuration): { storedWorkflowTemplateSpec+: { retryStrategy+: { backoff+: { maxDuration: maxDuration } } } },
      },
      '#limit':: d.obj(help='+protobuf=true\n+protobuf.options.(gogoproto.goproto_stringer)=false\n+k8s:openapi-gen=true'),
      limit: {
        '#withIntVal':: d.fn(help='', args=[d.arg(name='intVal', type=d.T.integer)]),
        withIntVal(intVal): { storedWorkflowTemplateSpec+: { retryStrategy+: { limit+: { intVal: intVal } } } },
        '#withStrVal':: d.fn(help='', args=[d.arg(name='strVal', type=d.T.string)]),
        withStrVal(strVal): { storedWorkflowTemplateSpec+: { retryStrategy+: { limit+: { strVal: strVal } } } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { storedWorkflowTemplateSpec+: { retryStrategy+: { limit+: { type: type } } } },
      },
      '#withRetryPolicy':: d.fn(help='RetryPolicy is a policy of NodePhase statuses that will be retried', args=[d.arg(name='retryPolicy', type=d.T.string)]),
      withRetryPolicy(retryPolicy): { storedWorkflowTemplateSpec+: { retryStrategy+: { retryPolicy: retryPolicy } } },
    },
    '#securityContext':: d.obj(help='PodSecurityContext holds pod-level security attributes and common container settings.\nSome fields are also present in container.securityContext.  Field values of\ncontainer.securityContext take precedence over field values of PodSecurityContext.'),
    securityContext: {
      '#seLinuxOptions':: d.obj(help=''),
      seLinuxOptions: {
        '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
        withLevel(level): { storedWorkflowTemplateSpec+: { securityContext+: { seLinuxOptions+: { level: level } } } },
        '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
        withRole(role): { storedWorkflowTemplateSpec+: { securityContext+: { seLinuxOptions+: { role: role } } } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { storedWorkflowTemplateSpec+: { securityContext+: { seLinuxOptions+: { type: type } } } },
        '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
        withUser(user): { storedWorkflowTemplateSpec+: { securityContext+: { seLinuxOptions+: { user: user } } } },
      },
      '#windowsOptions':: d.obj(help='WindowsSecurityContextOptions contain Windows-specific options and credentials.'),
      windowsOptions: {
        '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
        withGmsaCredentialSpec(gmsaCredentialSpec): { storedWorkflowTemplateSpec+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } },
        '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
        withGmsaCredentialSpecName(gmsaCredentialSpecName): { storedWorkflowTemplateSpec+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } },
        '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
        withRunAsUserName(runAsUserName): { storedWorkflowTemplateSpec+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } },
      },
      '#withFsGroup':: d.fn(help="1. The owning GID will be the FSGroup\n2. The setgid bit is set (new files created in the volume will be owned by FSGroup)\n3. The permission bits are OR'd with rw-rw----\n\nIf unset, the Kubelet will not modify the ownership and permissions of any volume.\n+optional", args=[d.arg(name='fsGroup', type=d.T.string)]),
      withFsGroup(fsGroup): { storedWorkflowTemplateSpec+: { securityContext+: { fsGroup: fsGroup } } },
      '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.string)]),
      withRunAsGroup(runAsGroup): { storedWorkflowTemplateSpec+: { securityContext+: { runAsGroup: runAsGroup } } },
      '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
      withRunAsNonRoot(runAsNonRoot): { storedWorkflowTemplateSpec+: { securityContext+: { runAsNonRoot: runAsNonRoot } } },
      '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.string)]),
      withRunAsUser(runAsUser): { storedWorkflowTemplateSpec+: { securityContext+: { runAsUser: runAsUser } } },
      '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
      withSupplementalGroups(supplementalGroups): { storedWorkflowTemplateSpec+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } },
      '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
      withSupplementalGroupsMixin(supplementalGroups): { storedWorkflowTemplateSpec+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } },
      '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
      withSysctls(sysctls): { storedWorkflowTemplateSpec+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } },
      '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
      withSysctlsMixin(sysctls): { storedWorkflowTemplateSpec+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } },
    },
    '#synchronization':: d.obj(help='Synchronization holds synchronization lock configuration'),
    synchronization: {
      '#mutex':: d.obj(help='Mutex holds Mutex configuration'),
      mutex: {
        '#withName':: d.fn(help='name of the mutex', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { storedWorkflowTemplateSpec+: { synchronization+: { mutex+: { name: name } } } },
      },
      '#semaphore':: d.obj(help='SemaphoreRef is a reference of Semaphore'),
      semaphore: {
        '#configMapKeyRef':: d.obj(help='Selects a key from a ConfigMap.'),
        configMapKeyRef: {
          '#localObjectReference':: d.obj(help='LocalObjectReference contains enough information to let you locate the\nreferenced object inside the same namespace.'),
          localObjectReference: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { storedWorkflowTemplateSpec+: { synchronization+: { semaphore+: { configMapKeyRef+: { localObjectReference+: { name: name } } } } } },
          },
          '#withKey':: d.fn(help='The key to select.', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { storedWorkflowTemplateSpec+: { synchronization+: { semaphore+: { configMapKeyRef+: { key: key } } } } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { storedWorkflowTemplateSpec+: { synchronization+: { semaphore+: { configMapKeyRef+: { optional: optional } } } } },
        },
      },
    },
    '#ttlStrategy':: d.obj(help='TTLStrategy is the strategy for the time to live depending on if the workflow succeeded or failed'),
    ttlStrategy: {
      '#withSecondsAfterCompletion':: d.fn(help='SecondsAfterCompletion is the number of seconds to live after completion', args=[d.arg(name='secondsAfterCompletion', type=d.T.integer)]),
      withSecondsAfterCompletion(secondsAfterCompletion): { storedWorkflowTemplateSpec+: { ttlStrategy+: { secondsAfterCompletion: secondsAfterCompletion } } },
      '#withSecondsAfterFailure':: d.fn(help='SecondsAfterFailure is the number of seconds to live after failure', args=[d.arg(name='secondsAfterFailure', type=d.T.integer)]),
      withSecondsAfterFailure(secondsAfterFailure): { storedWorkflowTemplateSpec+: { ttlStrategy+: { secondsAfterFailure: secondsAfterFailure } } },
      '#withSecondsAfterSuccess':: d.fn(help='SecondsAfterSuccess is the number of seconds to live after success', args=[d.arg(name='secondsAfterSuccess', type=d.T.integer)]),
      withSecondsAfterSuccess(secondsAfterSuccess): { storedWorkflowTemplateSpec+: { ttlStrategy+: { secondsAfterSuccess: secondsAfterSuccess } } },
    },
    '#volumeClaimGC':: d.obj(help='VolumeClaimGC describes how to delete volumes from completed Workflows'),
    volumeClaimGC: {
      '#withStrategy':: d.fn(help='Strategy is the strategy to use. One of "OnWorkflowCompletion", "OnWorkflowSuccess"', args=[d.arg(name='strategy', type=d.T.string)]),
      withStrategy(strategy): { storedWorkflowTemplateSpec+: { volumeClaimGC+: { strategy: strategy } } },
    },
    '#withActiveDeadlineSeconds':: d.fn(help='Optional duration in seconds relative to the workflow start time which the workflow is allowed to run before the controller terminates the io.argoproj.workflow.v1alpha1. A value of zero is used to terminate a Running workflow', args=[d.arg(name='activeDeadlineSeconds', type=d.T.integer)]),
    withActiveDeadlineSeconds(activeDeadlineSeconds): { storedWorkflowTemplateSpec+: { activeDeadlineSeconds: activeDeadlineSeconds } },
    '#withAutomountServiceAccountToken':: d.fn(help='AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods. ServiceAccountName of ExecutorConfig must be specified if this value is false.', args=[d.arg(name='automountServiceAccountToken', type=d.T.boolean)]),
    withAutomountServiceAccountToken(automountServiceAccountToken): { storedWorkflowTemplateSpec+: { automountServiceAccountToken: automountServiceAccountToken } },
    '#withDnsPolicy':: d.fn(help="Set DNS policy for the pod. Defaults to 'ClusterFirst'. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.", args=[d.arg(name='dnsPolicy', type=d.T.string)]),
    withDnsPolicy(dnsPolicy): { storedWorkflowTemplateSpec+: { dnsPolicy: dnsPolicy } },
    '#withEntrypoint':: d.fn(help='Entrypoint is a template reference to the starting point of the io.argoproj.workflow.v1alpha1.', args=[d.arg(name='entrypoint', type=d.T.string)]),
    withEntrypoint(entrypoint): { storedWorkflowTemplateSpec+: { entrypoint: entrypoint } },
    '#withHostAliases':: d.fn(help='', args=[d.arg(name='hostAliases', type=d.T.array)]),
    withHostAliases(hostAliases): { storedWorkflowTemplateSpec+: { hostAliases: if std.isArray(v=hostAliases) then hostAliases else [hostAliases] } },
    '#withHostAliasesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='hostAliases', type=d.T.array)]),
    withHostAliasesMixin(hostAliases): { storedWorkflowTemplateSpec+: { hostAliases+: if std.isArray(v=hostAliases) then hostAliases else [hostAliases] } },
    '#withHostNetwork':: d.fn(help='Host networking requested for this workflow pod. Default to false.', args=[d.arg(name='hostNetwork', type=d.T.boolean)]),
    withHostNetwork(hostNetwork): { storedWorkflowTemplateSpec+: { hostNetwork: hostNetwork } },
    '#withImagePullSecrets':: d.fn(help='ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
    withImagePullSecrets(imagePullSecrets): { storedWorkflowTemplateSpec+: { imagePullSecrets: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
    '#withImagePullSecretsMixin':: d.fn(help='ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
    withImagePullSecretsMixin(imagePullSecrets): { storedWorkflowTemplateSpec+: { imagePullSecrets+: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
    '#withNodeSelector':: d.fn(help='NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.', args=[d.arg(name='nodeSelector', type=d.T.object)]),
    withNodeSelector(nodeSelector): { storedWorkflowTemplateSpec+: { nodeSelector: nodeSelector } },
    '#withNodeSelectorMixin':: d.fn(help='NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelector', type=d.T.object)]),
    withNodeSelectorMixin(nodeSelector): { storedWorkflowTemplateSpec+: { nodeSelector+: nodeSelector } },
    '#withOnExit':: d.fn(help='OnExit is a template reference which is invoked at the end of the workflow, irrespective of the success, failure, or error of the primary io.argoproj.workflow.v1alpha1.', args=[d.arg(name='onExit', type=d.T.string)]),
    withOnExit(onExit): { storedWorkflowTemplateSpec+: { onExit: onExit } },
    '#withParallelism':: d.fn(help='Parallelism limits the max total parallel pods that can execute at the same time in a workflow', args=[d.arg(name='parallelism', type=d.T.integer)]),
    withParallelism(parallelism): { storedWorkflowTemplateSpec+: { parallelism: parallelism } },
    '#withPodPriority':: d.fn(help='Priority to apply to workflow pods.', args=[d.arg(name='podPriority', type=d.T.integer)]),
    withPodPriority(podPriority): { storedWorkflowTemplateSpec+: { podPriority: podPriority } },
    '#withPodPriorityClassName':: d.fn(help='PriorityClassName to apply to workflow pods.', args=[d.arg(name='podPriorityClassName', type=d.T.string)]),
    withPodPriorityClassName(podPriorityClassName): { storedWorkflowTemplateSpec+: { podPriorityClassName: podPriorityClassName } },
    '#withPodSpecPatch':: d.fn(help='PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of container fields which are not strings (e.g. resource limits).', args=[d.arg(name='podSpecPatch', type=d.T.string)]),
    withPodSpecPatch(podSpecPatch): { storedWorkflowTemplateSpec+: { podSpecPatch: podSpecPatch } },
    '#withPriority':: d.fn(help='Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first.', args=[d.arg(name='priority', type=d.T.integer)]),
    withPriority(priority): { storedWorkflowTemplateSpec+: { priority: priority } },
    '#withSchedulerName':: d.fn(help="Set scheduler name for all pods. Will be overridden if container/script template's scheduler name is set. Default scheduler will be used if neither specified.", args=[d.arg(name='schedulerName', type=d.T.string)]),
    withSchedulerName(schedulerName): { storedWorkflowTemplateSpec+: { schedulerName: schedulerName } },
    '#withServiceAccountName':: d.fn(help='ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.', args=[d.arg(name='serviceAccountName', type=d.T.string)]),
    withServiceAccountName(serviceAccountName): { storedWorkflowTemplateSpec+: { serviceAccountName: serviceAccountName } },
    '#withShutdown':: d.fn(help='Shutdown will shutdown the workflow according to its ShutdownStrategy', args=[d.arg(name='shutdown', type=d.T.string)]),
    withShutdown(shutdown): { storedWorkflowTemplateSpec+: { shutdown: shutdown } },
    '#withSuspend':: d.fn(help='Suspend will suspend the workflow and prevent execution of any future steps in the workflow', args=[d.arg(name='suspend', type=d.T.boolean)]),
    withSuspend(suspend): { storedWorkflowTemplateSpec+: { suspend: suspend } },
    '#withTemplates':: d.fn(help='Templates is a list of workflow templates used in a workflow', args=[d.arg(name='templates', type=d.T.array)]),
    withTemplates(templates): { storedWorkflowTemplateSpec+: { templates: if std.isArray(v=templates) then templates else [templates] } },
    '#withTemplatesMixin':: d.fn(help='Templates is a list of workflow templates used in a workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='templates', type=d.T.array)]),
    withTemplatesMixin(templates): { storedWorkflowTemplateSpec+: { templates+: if std.isArray(v=templates) then templates else [templates] } },
    '#withTolerations':: d.fn(help='Tolerations to apply to workflow pods.', args=[d.arg(name='tolerations', type=d.T.array)]),
    withTolerations(tolerations): { storedWorkflowTemplateSpec+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } },
    '#withTolerationsMixin':: d.fn(help='Tolerations to apply to workflow pods.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
    withTolerationsMixin(tolerations): { storedWorkflowTemplateSpec+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } },
    '#withTtlSecondsAfterFinished':: d.fn(help='TTLSecondsAfterFinished limits the lifetime of a Workflow that has finished execution (Succeeded, Failed, Error). If this field is set, once the Workflow finishes, it will be deleted after ttlSecondsAfterFinished expires. If this field is unset, ttlSecondsAfterFinished will not expire. If this field is set to zero, ttlSecondsAfterFinished expires immediately after the Workflow finishes. DEPRECATED: Use TTLStrategy.SecondsAfterCompletion instead.', args=[d.arg(name='ttlSecondsAfterFinished', type=d.T.integer)]),
    withTtlSecondsAfterFinished(ttlSecondsAfterFinished): { storedWorkflowTemplateSpec+: { ttlSecondsAfterFinished: ttlSecondsAfterFinished } },
    '#withVolumeClaimTemplates':: d.fn(help='VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow', args=[d.arg(name='volumeClaimTemplates', type=d.T.array)]),
    withVolumeClaimTemplates(volumeClaimTemplates): { storedWorkflowTemplateSpec+: { volumeClaimTemplates: if std.isArray(v=volumeClaimTemplates) then volumeClaimTemplates else [volumeClaimTemplates] } },
    '#withVolumeClaimTemplatesMixin':: d.fn(help='VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeClaimTemplates', type=d.T.array)]),
    withVolumeClaimTemplatesMixin(volumeClaimTemplates): { storedWorkflowTemplateSpec+: { volumeClaimTemplates+: if std.isArray(v=volumeClaimTemplates) then volumeClaimTemplates else [volumeClaimTemplates] } },
    '#withVolumes':: d.fn(help='Volumes is a list of volumes that can be mounted by containers in a io.argoproj.workflow.v1alpha1.', args=[d.arg(name='volumes', type=d.T.array)]),
    withVolumes(volumes): { storedWorkflowTemplateSpec+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } },
    '#withVolumesMixin':: d.fn(help='Volumes is a list of volumes that can be mounted by containers in a io.argoproj.workflow.v1alpha1.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
    withVolumesMixin(volumes): { storedWorkflowTemplateSpec+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } },
    '#workflowTemplateRef':: d.obj(help='WorkflowTemplateRef is a reference to a WorkflowTemplate resource.'),
    workflowTemplateRef: {
      '#withClusterScope':: d.fn(help='ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate).', args=[d.arg(name='clusterScope', type=d.T.boolean)]),
      withClusterScope(clusterScope): { storedWorkflowTemplateSpec+: { workflowTemplateRef+: { clusterScope: clusterScope } } },
      '#withName':: d.fn(help='Name is the resource name of the workflow template.', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { storedWorkflowTemplateSpec+: { workflowTemplateRef+: { name: name } } },
    },
  },
  '#synchronization':: d.obj(help='SynchronizationStatus stores the status of semaphore and mutex.'),
  synchronization: {
    '#mutex':: d.obj(help='MutexStatus contains which objects hold  mutex locks, and which objects this workflow is waiting on to release locks.'),
    mutex: {
      '#withHolding':: d.fn(help='Holding is a list of mutexes and their respective objects that are held by mutex lock for this io.argoproj.workflow.v1alpha1.', args=[d.arg(name='holding', type=d.T.array)]),
      withHolding(holding): { synchronization+: { mutex+: { holding: if std.isArray(v=holding) then holding else [holding] } } },
      '#withHoldingMixin':: d.fn(help='Holding is a list of mutexes and their respective objects that are held by mutex lock for this io.argoproj.workflow.v1alpha1.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='holding', type=d.T.array)]),
      withHoldingMixin(holding): { synchronization+: { mutex+: { holding+: if std.isArray(v=holding) then holding else [holding] } } },
      '#withWaiting':: d.fn(help='Waiting is a list of mutexes and their respective objects this workflow is waiting for.', args=[d.arg(name='waiting', type=d.T.array)]),
      withWaiting(waiting): { synchronization+: { mutex+: { waiting: if std.isArray(v=waiting) then waiting else [waiting] } } },
      '#withWaitingMixin':: d.fn(help='Waiting is a list of mutexes and their respective objects this workflow is waiting for.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='waiting', type=d.T.array)]),
      withWaitingMixin(waiting): { synchronization+: { mutex+: { waiting+: if std.isArray(v=waiting) then waiting else [waiting] } } },
    },
    '#semaphore':: d.obj(help=''),
    semaphore: {
      '#withHolding':: d.fn(help='Holding stores the list of resource acquired synchronization lock for workflows.', args=[d.arg(name='holding', type=d.T.array)]),
      withHolding(holding): { synchronization+: { semaphore+: { holding: if std.isArray(v=holding) then holding else [holding] } } },
      '#withHoldingMixin':: d.fn(help='Holding stores the list of resource acquired synchronization lock for workflows.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='holding', type=d.T.array)]),
      withHoldingMixin(holding): { synchronization+: { semaphore+: { holding+: if std.isArray(v=holding) then holding else [holding] } } },
      '#withWaiting':: d.fn(help='Waiting indicates the list of current synchronization lock holders.', args=[d.arg(name='waiting', type=d.T.array)]),
      withWaiting(waiting): { synchronization+: { semaphore+: { waiting: if std.isArray(v=waiting) then waiting else [waiting] } } },
      '#withWaitingMixin':: d.fn(help='Waiting indicates the list of current synchronization lock holders.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='waiting', type=d.T.array)]),
      withWaitingMixin(waiting): { synchronization+: { semaphore+: { waiting+: if std.isArray(v=waiting) then waiting else [waiting] } } },
    },
  },
  '#withCompressedNodes':: d.fn(help='Compressed and base64 decoded Nodes map', args=[d.arg(name='compressedNodes', type=d.T.string)]),
  withCompressedNodes(compressedNodes): { compressedNodes: compressedNodes },
  '#withConditions':: d.fn(help='Conditions is a list of conditions the Workflow may have', args=[d.arg(name='conditions', type=d.T.array)]),
  withConditions(conditions): { conditions: if std.isArray(v=conditions) then conditions else [conditions] },
  '#withConditionsMixin':: d.fn(help='Conditions is a list of conditions the Workflow may have\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='conditions', type=d.T.array)]),
  withConditionsMixin(conditions): { conditions+: if std.isArray(v=conditions) then conditions else [conditions] },
  '#withEstimatedDuration':: d.fn(help='EstimatedDuration in seconds.', args=[d.arg(name='estimatedDuration', type=d.T.integer)]),
  withEstimatedDuration(estimatedDuration): { estimatedDuration: estimatedDuration },
  '#withMessage':: d.fn(help='A human readable message indicating details about why the workflow is in this condition.', args=[d.arg(name='message', type=d.T.string)]),
  withMessage(message): { message: message },
  '#withNodes':: d.fn(help="Nodes is a mapping between a node ID and the node's status.", args=[d.arg(name='nodes', type=d.T.object)]),
  withNodes(nodes): { nodes: nodes },
  '#withNodesMixin':: d.fn(help="Nodes is a mapping between a node ID and the node's status.\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='nodes', type=d.T.object)]),
  withNodesMixin(nodes): { nodes+: nodes },
  '#withOffloadNodeStatusVersion':: d.fn(help='Whether on not node status has been offloaded to a database. If exists, then Nodes and CompressedNodes will be empty. This will actually be populated with a hash of the offloaded data.', args=[d.arg(name='offloadNodeStatusVersion', type=d.T.string)]),
  withOffloadNodeStatusVersion(offloadNodeStatusVersion): { offloadNodeStatusVersion: offloadNodeStatusVersion },
  '#withPersistentVolumeClaims':: d.fn(help='PersistentVolumeClaims tracks all PVCs that were created as part of the io.argoproj.workflow.v1alpha1. The contents of this list are drained at the end of the workflow.', args=[d.arg(name='persistentVolumeClaims', type=d.T.array)]),
  withPersistentVolumeClaims(persistentVolumeClaims): { persistentVolumeClaims: if std.isArray(v=persistentVolumeClaims) then persistentVolumeClaims else [persistentVolumeClaims] },
  '#withPersistentVolumeClaimsMixin':: d.fn(help='PersistentVolumeClaims tracks all PVCs that were created as part of the io.argoproj.workflow.v1alpha1. The contents of this list are drained at the end of the workflow.\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='persistentVolumeClaims', type=d.T.array)]),
  withPersistentVolumeClaimsMixin(persistentVolumeClaims): { persistentVolumeClaims+: if std.isArray(v=persistentVolumeClaims) then persistentVolumeClaims else [persistentVolumeClaims] },
  '#withPhase':: d.fn(help='Phase a simple, high-level summary of where the workflow is in its lifecycle.', args=[d.arg(name='phase', type=d.T.string)]),
  withPhase(phase): { phase: phase },
  '#withProgress':: d.fn(help='Progress to completion', args=[d.arg(name='progress', type=d.T.string)]),
  withProgress(progress): { progress: progress },
  '#withResourcesDuration':: d.fn(help='ResourcesDuration is the total for the workflow', args=[d.arg(name='resourcesDuration', type=d.T.object)]),
  withResourcesDuration(resourcesDuration): { resourcesDuration: resourcesDuration },
  '#withResourcesDurationMixin':: d.fn(help='ResourcesDuration is the total for the workflow\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourcesDuration', type=d.T.object)]),
  withResourcesDurationMixin(resourcesDuration): { resourcesDuration+: resourcesDuration },
  '#withStoredTemplates':: d.fn(help="StoredTemplates is a mapping between a template ref and the node's status.", args=[d.arg(name='storedTemplates', type=d.T.object)]),
  withStoredTemplates(storedTemplates): { storedTemplates: storedTemplates },
  '#withStoredTemplatesMixin':: d.fn(help="StoredTemplates is a mapping between a template ref and the node's status.\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='storedTemplates', type=d.T.object)]),
  withStoredTemplatesMixin(storedTemplates): { storedTemplates+: storedTemplates },
  '#mixin': 'ignore',
  mixin: self,
}
