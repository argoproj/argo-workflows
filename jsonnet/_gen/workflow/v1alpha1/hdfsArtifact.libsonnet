{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='hdfsArtifact', url='', help='HDFSArtifact is the location of an HDFS artifact'),
  '#krbCCacheSecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
  krbCCacheSecret: {
    '#localObjectReference':: d.obj(help='LocalObjectReference contains enough information to let you locate the\nreferenced object inside the same namespace.'),
    localObjectReference: {
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { krbCCacheSecret+: { localObjectReference+: { name: name } } },
    },
    '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
    withKey(key): { krbCCacheSecret+: { key: key } },
    '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
    withOptional(optional): { krbCCacheSecret+: { optional: optional } },
  },
  '#krbConfigConfigMap':: d.obj(help='Selects a key from a ConfigMap.'),
  krbConfigConfigMap: {
    '#localObjectReference':: d.obj(help='LocalObjectReference contains enough information to let you locate the\nreferenced object inside the same namespace.'),
    localObjectReference: {
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { krbConfigConfigMap+: { localObjectReference+: { name: name } } },
    },
    '#withKey':: d.fn(help='The key to select.', args=[d.arg(name='key', type=d.T.string)]),
    withKey(key): { krbConfigConfigMap+: { key: key } },
    '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
    withOptional(optional): { krbConfigConfigMap+: { optional: optional } },
  },
  '#krbKeytabSecret':: d.obj(help='SecretKeySelector selects a key of a Secret.'),
  krbKeytabSecret: {
    '#localObjectReference':: d.obj(help='LocalObjectReference contains enough information to let you locate the\nreferenced object inside the same namespace.'),
    localObjectReference: {
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { krbKeytabSecret+: { localObjectReference+: { name: name } } },
    },
    '#withKey':: d.fn(help='The key of the secret to select from.  Must be a valid secret key.', args=[d.arg(name='key', type=d.T.string)]),
    withKey(key): { krbKeytabSecret+: { key: key } },
    '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
    withOptional(optional): { krbKeytabSecret+: { optional: optional } },
  },
  '#withAddresses':: d.fn(help='Addresses is accessible addresses of HDFS name nodes', args=[d.arg(name='addresses', type=d.T.array)]),
  withAddresses(addresses): { addresses: if std.isArray(v=addresses) then addresses else [addresses] },
  '#withAddressesMixin':: d.fn(help='Addresses is accessible addresses of HDFS name nodes\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='addresses', type=d.T.array)]),
  withAddressesMixin(addresses): { addresses+: if std.isArray(v=addresses) then addresses else [addresses] },
  '#withForce':: d.fn(help='Force copies a file forcibly even if it exists (default: false)', args=[d.arg(name='force', type=d.T.boolean)]),
  withForce(force): { force: force },
  '#withHdfsUser':: d.fn(help='HDFSUser is the user to access HDFS file system. It is ignored if either ccache or keytab is used.', args=[d.arg(name='hdfsUser', type=d.T.string)]),
  withHdfsUser(hdfsUser): { hdfsUser: hdfsUser },
  '#withKrbRealm':: d.fn(help='KrbRealm is the Kerberos realm used with Kerberos keytab It must be set if keytab is used.', args=[d.arg(name='krbRealm', type=d.T.string)]),
  withKrbRealm(krbRealm): { krbRealm: krbRealm },
  '#withKrbServicePrincipalName':: d.fn(help='KrbServicePrincipalName is the principal name of Kerberos service It must be set if either ccache or keytab is used.', args=[d.arg(name='krbServicePrincipalName', type=d.T.string)]),
  withKrbServicePrincipalName(krbServicePrincipalName): { krbServicePrincipalName: krbServicePrincipalName },
  '#withKrbUsername':: d.fn(help='KrbUsername is the Kerberos username used with Kerberos keytab It must be set if keytab is used.', args=[d.arg(name='krbUsername', type=d.T.string)]),
  withKrbUsername(krbUsername): { krbUsername: krbUsername },
  '#withPath':: d.fn(help='Path is a file path in HDFS', args=[d.arg(name='path', type=d.T.string)]),
  withPath(path): { path: path },
  '#mixin': 'ignore',
  mixin: self,
}
