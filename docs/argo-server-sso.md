# Argo Server SSO

![GA](assets/ga.svg)

> v2.9 and after

It is possible to use [Dex](https://github.com/dexidp/dex) for authentication. 
[This document](argo-server-sso-argocd.md) describes how to set up ArgoWorkflows and ArgoCD so that ArgoWorkflows uses ArgoCD's Dex server for authentication.

## To start Argo Server with SSO.

Firstly, configure the settings [workflow-controller-configmap.yaml](workflow-controller-configmap.yaml) with the correct OAuth 2 values. 
If working towards an OIDC configuration, the ArgoCD project has [guides](https://argoproj.github.io/argo-cd/operator-manual/user-management/#existing-oidc-provider) on its similar (though different) process for setting up OIDC providers.

Next, create the k8s Secrets that hold the OAUTH2 `client-id` and `client-secret`. 
You may wish to refer to the Kubernetes [documentation on managing Secrets](https://kubernetes.io/docs/tasks/configmap-secret/). 

For example by using `kubectl` with literals:
```shell
kubectl create secret -n argo generic client-id-secret \
  --from-literal=client-id-key=foo

kubectl create secret -n argo generic client-secret-secret \
  --from-literal=client-secret-key=bar
```

Then, start the Argo Server using the SSO [auth mode](argo-server-auth-mode.md):

```shell
argo server --auth-mode sso --auth-mode ...
```

## Token Revocation

> v2.12 and after

As of v2.12 we issue a JWE token for users rather than give them the ID token from your OAuth2 provider. 
This token is opaque and has a longer expiry time (10h by default).

The token encryption key is automatically generated by the Argo Server and stored in a Kubernetes secret name "sso".

You can revoke all tokens by deleting the encryption key and restarting the Argo Server (so it generates a new key).

```shell
kubectl delete secret sso
```

!!! Warning
    The old key will be in the memory the any running Argo Server, and they will therefore accept and user with token encrypted using the old key. 
    Every Argo Server MUST be restarted.

All users will need to log in again. Sorry.

## SSO Login Time

> v2.12 and after

By default, your SSO session will expire after 10 hours. 
You can change this by adding a sessionExpiry value to your [workflow-controller-configmap.yaml](workflow-controller-configmap.yaml) under the SSO heading.

```yaml
sso:
  # Expiry defines how long your login is valid for in hours. (optional)
  sessionExpiry: 240h
```

## SSO Impersonate

> v3.3 and after

!!! Warning
    Only one of `sso.impersonate.enabled` or `sso.rbac.enabled` can be used `true`.

You can optionally have argo server use Kubernetes [SubjectAccessReviews](https://kubernetes.io/docs/reference/access-authn-authz/authorization/#checking-api-access) for each User request (based on their OIDC claims, like `email` or `sub`) and only provide the access defined in [RoleBinding and ClusterRoleBinding](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding) for that User.
This allows argo server to run with higher permissions than any specific User, and to effectively "impersonate" the required access. (NOTE: from the Kubernetes API's perspective, the argo server Pod's ServiceAccount will still be the "actor")

Here is an extract from [workflow-controller-configmap.yaml](workflow-controller-configmap.yaml) that enables this feature, specifying the `email` claim for the username:
```yaml
sso:
  # ...
  impersonate:
    enabled: true
    # one of: {"email", "sub"}
    usernameClaim: "email"
  rbac:
    # this MUST be false
    enabled: false
```

## SSO RBAC

> v2.12 and after

You can define rules that map users (based on their OIDC claims, like `groups`) to Kubernetes ServiceAccounts in the same namespace as argo server, by using annotations on the ServiceAccounts.
This allows you to give different users different access levels.

To allow a ServiceAccount to manage resources in another Namespace, create a Role and RoleBinding in the target namespace.

!!! Note
    Kubernetes [RBAC configs](https://kubernetes.io/docs/reference/access-authn-authz/rbac/) are cluster-configs, so any changes will probably need to be made by the team that installed Argo. 
    Many complex rules may be burdensome on that team, be kind!

Firstly, enable the `sso.rbac.enabled` setting in [workflow-controller-configmap.yaml](workflow-controller-configmap.yaml):

```yaml
sso:
  # ...
  scopes:
   # request the OIDC `group` scope to be able configure RBAC using groups
   - groups
  rbac:
    enabled: true
```

!!! Note
    Not all OIDC provider support the `groups` scope. 
    Please speak to your provider about their options.

Second, configure a ServiceAccount to be used by annotating it with `workflows.argoproj.io/rbac-rule`:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  annotations:
    # The rule is an expression used to determine if this service account
    # should be used.
    # * `groups` - an array of the OIDC groups
    # * `iss` - the issuer ("argo-server")
    # * `sub` - the subject (typically the username)
    # Must evaluate to a boolean.
    # If you want an account to be the default to use, this rule can be "true".
    # Details of the expression language are available in
    # https://github.com/antonmedv/expr/blob/master/docs/Language-Definition.md.
    workflows.argoproj.io/rbac-rule: "'admin' in groups"
    
    # The precedence is used to determine which service account to use whe
    # Precedence is an integer. It may be negative. If omitted, it defaults to "0".
    # Numerically higher values have higher precedence (not lower, which maybe
    # counter-intuitive to you).
    # If two rules match and have the same precedence, then which one used will
    # be arbitrary.
    workflows.argoproj.io/rbac-rule-precedence: "1"
```

!!! Note
    If no rule matches, we deny the user access.

!!! Tip
    You'll probably want to configure a default ServiceAccount to use if no other rule matches, e.g. a read-only account.

    You can do this as follows (the precedence must be the lowest of all your service accounts):

    ```yaml
    metadata:
      name: read-only
      annotations:
        workflows.argoproj.io/rbac-rule: "true"
        workflows.argoproj.io/rbac-rule-precedence: "0"
    ```    

#### Recommended usage

Configure a default ServiceAccount in the installation Namespace, the presence of this ServiceAccount allows all OIDC users to login to the cluster. 
You may then create a workflow read-only Role and RoleBinding for this ServiceAccount.

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: user-default-login
  # your argo installation namespace
  namespace: argo
  annotations:
    workflows.argoproj.io/rbac-rule: "true"
    workflows.argoproj.io/rbac-rule-precedence: "0"
```

Now, for `my-namespace`, configure a ServiceAccount which would allow members of your team to perform the required operations.

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-namespace-read-write-user
  namespace: my-namespace
  annotations:
    workflows.argoproj.io/rbac-rule: "'my-team' in groups"
    workflows.argoproj.io/rbac-rule-precedence: "1"
```

!!! Tip
    Make sure that the precedence of the Namespace ServiceAccount is HIGHER than the precedence of the default login ServiceAccount.

Using these configs, when an SSO user makes a request in 'my-namespace', and the `rbac-rule` matches, argo server uses the `my-namespace-read-write-user` ServiceAccount to access the Kubernetes API.
If no ServiceAccount matches in the Namespace, the default ServiceAccount (in this case, `user-default-login`) will be used to access the Kubernetes API.

#### Custom claims

> v3.1.4 and after

If your OIDC provider provides groups information with a claim name other than `groups`, you may configure [workflow-controller-configmap.yaml](workflow-controller-configmap.yaml) with the name of a custom claim. 

!!! Tip
    Any `customGroupClaimName` must still be an array of strings with group names as elements.

In this case, the custom claim `argo_groups` will be mapped to the `groups` key, so we still use the `groups` key in our RBAC expression annotations:

```yaml
sso:
  # Specify custom claim name for OIDC groups.
  customGroupClaimName: argo_groups
```

If your OIDC provider provides groups information using an OIDC `/userInfo` endpoint (e.g. Okta), you may configure `sso.userInfoPath` to specify the user info endpoint that contains the groups claim:

```yaml
sso:
  userInfoPath: /oauth2/v1/userinfo
```

#### Expr Language

> v3.1.4 and after

Argo server uses the [antonmedv/expr](https://github.com/antonmedv/expr) expression language in its `workflows.argoproj.io/rbac-rule` ServiceAccount annotations.

Please review the [Language Definition for Expr](https://github.com/antonmedv/expr/blob/master/docs/Language-Definition.md) for more details.

Here are some basic examples:

```yaml
metadata:
  annotations:
    workflows.argoproj.io/rbac-rule: "'argo_admins' in groups"
```

```yaml
metadata:
  annotations:
    workflows.argoproj.io/rbac-rule: "'authors' in groups && email == 'kilgore@kilgore.trout'"
```

### SSO RBAC Namespace Delegation

> v3.3 and after

You can optionally configure RBAC SSO to be per-Namespace by setting `SSO_DELEGATE_RBAC_TO_NAMESPACE=true` with your argo-server Deployment environment variables.

!!! Warning
    This feature is currently in beta, and subject to change.
