// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/argoproj/argo/pkg/apis/workflow/v1alpha1/generated.proto

package v1alpha1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	v1 "k8s.io/api/core/v1"
	v1beta1 "k8s.io/api/policy/v1beta1"
	v11 "k8s.io/apimachinery/pkg/apis/meta/v1"
	_ "k8s.io/apimachinery/pkg/runtime"
	_ "k8s.io/apimachinery/pkg/runtime/schema"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Amount represent a numeric amount.
// +kubebuilder:validation:Type=number
type Amount struct {
	Value                *string  `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Amount) Reset()         { *m = Amount{} }
func (m *Amount) String() string { return proto.CompactTextString(m) }
func (*Amount) ProtoMessage()    {}
func (*Amount) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{0}
}
func (m *Amount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Amount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Amount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Amount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Amount.Merge(m, src)
}
func (m *Amount) XXX_Size() int {
	return m.Size()
}
func (m *Amount) XXX_DiscardUnknown() {
	xxx_messageInfo_Amount.DiscardUnknown(m)
}

var xxx_messageInfo_Amount proto.InternalMessageInfo

func (m *Amount) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// ArchiveStrategy describes how to archive files/directory when saving artifacts
type ArchiveStrategy struct {
	Tar                  *TarStrategy  `protobuf:"bytes,1,opt,name=tar" json:"tar,omitempty"`
	None                 *NoneStrategy `protobuf:"bytes,2,opt,name=none" json:"none,omitempty"`
	Zip                  *ZipStrategy  `protobuf:"bytes,3,opt,name=zip" json:"zip,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ArchiveStrategy) Reset()         { *m = ArchiveStrategy{} }
func (m *ArchiveStrategy) String() string { return proto.CompactTextString(m) }
func (*ArchiveStrategy) ProtoMessage()    {}
func (*ArchiveStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{1}
}
func (m *ArchiveStrategy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArchiveStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArchiveStrategy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArchiveStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArchiveStrategy.Merge(m, src)
}
func (m *ArchiveStrategy) XXX_Size() int {
	return m.Size()
}
func (m *ArchiveStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_ArchiveStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_ArchiveStrategy proto.InternalMessageInfo

func (m *ArchiveStrategy) GetTar() *TarStrategy {
	if m != nil {
		return m.Tar
	}
	return nil
}

func (m *ArchiveStrategy) GetNone() *NoneStrategy {
	if m != nil {
		return m.None
	}
	return nil
}

func (m *ArchiveStrategy) GetZip() *ZipStrategy {
	if m != nil {
		return m.Zip
	}
	return nil
}

// Arguments to a template
type Arguments struct {
	// Parameters is the list of parameters to pass to the template or workflow
	// +patchStrategy=merge
	// +patchMergeKey=name
	Parameters []*Parameter `protobuf:"bytes,1,rep,name=parameters" json:"parameters,omitempty"`
	// Artifacts is the list of artifacts to pass to the template or workflow
	// +patchStrategy=merge
	// +patchMergeKey=name
	Artifacts            []*Artifact `protobuf:"bytes,2,rep,name=artifacts" json:"artifacts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Arguments) Reset()         { *m = Arguments{} }
func (m *Arguments) String() string { return proto.CompactTextString(m) }
func (*Arguments) ProtoMessage()    {}
func (*Arguments) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{2}
}
func (m *Arguments) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Arguments) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Arguments.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Arguments) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Arguments.Merge(m, src)
}
func (m *Arguments) XXX_Size() int {
	return m.Size()
}
func (m *Arguments) XXX_DiscardUnknown() {
	xxx_messageInfo_Arguments.DiscardUnknown(m)
}

var xxx_messageInfo_Arguments proto.InternalMessageInfo

func (m *Arguments) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Arguments) GetArtifacts() []*Artifact {
	if m != nil {
		return m.Artifacts
	}
	return nil
}

// Artifact indicates an artifact to place at a specified path
type Artifact struct {
	// name of the artifact. must be unique within a template's inputs/outputs.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Path is the container path to the artifact
	Path *string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// mode bits to use on this file, must be a value between 0 and 0777
	// set when loading input artifacts.
	Mode *int32 `protobuf:"varint,3,opt,name=mode" json:"mode,omitempty"`
	// From allows an artifact to reference an artifact from a previous step
	From *string `protobuf:"bytes,4,opt,name=from" json:"from,omitempty"`
	// ArtifactLocation contains the location of the artifact
	ArtifactLocation *ArtifactLocation `protobuf:"bytes,5,opt,name=artifactLocation" json:"artifactLocation,omitempty"`
	// GlobalName exports an output artifact to the global scope, making it available as
	// '{{workflow.outputs.artifacts.XXXX}} and in workflow.status.outputs.artifacts
	GlobalName *string `protobuf:"bytes,6,opt,name=globalName" json:"globalName,omitempty"`
	// Archive controls how the artifact will be saved to the artifact repository.
	Archive *ArchiveStrategy `protobuf:"bytes,7,opt,name=archive" json:"archive,omitempty"`
	// Make Artifacts optional, if Artifacts doesn't generate or exist
	Optional *bool `protobuf:"varint,8,opt,name=optional" json:"optional,omitempty"`
	// SubPath allows an artifact to be sourced from a subpath within the specified source
	SubPath *string `protobuf:"bytes,9,opt,name=subPath" json:"subPath,omitempty"`
	// If mode is set, apply the permission recursively into the artifact if it is a folder
	RecurseMode          *bool    `protobuf:"varint,10,opt,name=recurseMode" json:"recurseMode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Artifact) Reset()         { *m = Artifact{} }
func (m *Artifact) String() string { return proto.CompactTextString(m) }
func (*Artifact) ProtoMessage()    {}
func (*Artifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{3}
}
func (m *Artifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Artifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Artifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Artifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Artifact.Merge(m, src)
}
func (m *Artifact) XXX_Size() int {
	return m.Size()
}
func (m *Artifact) XXX_DiscardUnknown() {
	xxx_messageInfo_Artifact.DiscardUnknown(m)
}

var xxx_messageInfo_Artifact proto.InternalMessageInfo

func (m *Artifact) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Artifact) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *Artifact) GetMode() int32 {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return 0
}

func (m *Artifact) GetFrom() string {
	if m != nil && m.From != nil {
		return *m.From
	}
	return ""
}

func (m *Artifact) GetArtifactLocation() *ArtifactLocation {
	if m != nil {
		return m.ArtifactLocation
	}
	return nil
}

func (m *Artifact) GetGlobalName() string {
	if m != nil && m.GlobalName != nil {
		return *m.GlobalName
	}
	return ""
}

func (m *Artifact) GetArchive() *ArchiveStrategy {
	if m != nil {
		return m.Archive
	}
	return nil
}

func (m *Artifact) GetOptional() bool {
	if m != nil && m.Optional != nil {
		return *m.Optional
	}
	return false
}

func (m *Artifact) GetSubPath() string {
	if m != nil && m.SubPath != nil {
		return *m.SubPath
	}
	return ""
}

func (m *Artifact) GetRecurseMode() bool {
	if m != nil && m.RecurseMode != nil {
		return *m.RecurseMode
	}
	return false
}

// ArtifactLocation describes a location for a single or multiple artifacts.
// It is used as single artifact in the context of inputs/outputs (e.g. outputs.artifacts.artname).
// It is also used to describe the location of multiple artifacts such as the archive location
// of a single workflow step, which the executor will use as a default location to store its files.
type ArtifactLocation struct {
	// ArchiveLogs indicates if the container logs should be archived
	ArchiveLogs *bool `protobuf:"varint,1,opt,name=archiveLogs" json:"archiveLogs,omitempty"`
	// S3 contains S3 artifact location details
	S3 *S3Artifact `protobuf:"bytes,2,opt,name=s3" json:"s3,omitempty"`
	// Git contains git artifact location details
	Git *GitArtifact `protobuf:"bytes,3,opt,name=git" json:"git,omitempty"`
	// HTTP contains HTTP artifact location details
	Http *HTTPArtifact `protobuf:"bytes,4,opt,name=http" json:"http,omitempty"`
	// Artifactory contains artifactory artifact location details
	Artifactory *ArtifactoryArtifact `protobuf:"bytes,5,opt,name=artifactory" json:"artifactory,omitempty"`
	// HDFS contains HDFS artifact location details
	Hdfs *HDFSArtifact `protobuf:"bytes,6,opt,name=hdfs" json:"hdfs,omitempty"`
	// Raw contains raw artifact location details
	Raw *RawArtifact `protobuf:"bytes,7,opt,name=raw" json:"raw,omitempty"`
	// OSS contains OSS artifact location details
	Oss *OSSArtifact `protobuf:"bytes,8,opt,name=oss" json:"oss,omitempty"`
	// GCS contains GCS artifact location details
	Gcs                  *GCSArtifact `protobuf:"bytes,9,opt,name=gcs" json:"gcs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ArtifactLocation) Reset()         { *m = ArtifactLocation{} }
func (m *ArtifactLocation) String() string { return proto.CompactTextString(m) }
func (*ArtifactLocation) ProtoMessage()    {}
func (*ArtifactLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{4}
}
func (m *ArtifactLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArtifactLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArtifactLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArtifactLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArtifactLocation.Merge(m, src)
}
func (m *ArtifactLocation) XXX_Size() int {
	return m.Size()
}
func (m *ArtifactLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_ArtifactLocation.DiscardUnknown(m)
}

var xxx_messageInfo_ArtifactLocation proto.InternalMessageInfo

func (m *ArtifactLocation) GetArchiveLogs() bool {
	if m != nil && m.ArchiveLogs != nil {
		return *m.ArchiveLogs
	}
	return false
}

func (m *ArtifactLocation) GetS3() *S3Artifact {
	if m != nil {
		return m.S3
	}
	return nil
}

func (m *ArtifactLocation) GetGit() *GitArtifact {
	if m != nil {
		return m.Git
	}
	return nil
}

func (m *ArtifactLocation) GetHttp() *HTTPArtifact {
	if m != nil {
		return m.Http
	}
	return nil
}

func (m *ArtifactLocation) GetArtifactory() *ArtifactoryArtifact {
	if m != nil {
		return m.Artifactory
	}
	return nil
}

func (m *ArtifactLocation) GetHdfs() *HDFSArtifact {
	if m != nil {
		return m.Hdfs
	}
	return nil
}

func (m *ArtifactLocation) GetRaw() *RawArtifact {
	if m != nil {
		return m.Raw
	}
	return nil
}

func (m *ArtifactLocation) GetOss() *OSSArtifact {
	if m != nil {
		return m.Oss
	}
	return nil
}

func (m *ArtifactLocation) GetGcs() *GCSArtifact {
	if m != nil {
		return m.Gcs
	}
	return nil
}

type ArtifactRepositoryRef struct {
	ConfigMap            *string  `protobuf:"bytes,1,opt,name=configMap" json:"configMap,omitempty"`
	Key                  *string  `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArtifactRepositoryRef) Reset()         { *m = ArtifactRepositoryRef{} }
func (m *ArtifactRepositoryRef) String() string { return proto.CompactTextString(m) }
func (*ArtifactRepositoryRef) ProtoMessage()    {}
func (*ArtifactRepositoryRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{5}
}
func (m *ArtifactRepositoryRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArtifactRepositoryRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArtifactRepositoryRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArtifactRepositoryRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArtifactRepositoryRef.Merge(m, src)
}
func (m *ArtifactRepositoryRef) XXX_Size() int {
	return m.Size()
}
func (m *ArtifactRepositoryRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ArtifactRepositoryRef.DiscardUnknown(m)
}

var xxx_messageInfo_ArtifactRepositoryRef proto.InternalMessageInfo

func (m *ArtifactRepositoryRef) GetConfigMap() string {
	if m != nil && m.ConfigMap != nil {
		return *m.ConfigMap
	}
	return ""
}

func (m *ArtifactRepositoryRef) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

// ArtifactoryArtifact is the location of an artifactory artifact
type ArtifactoryArtifact struct {
	// URL of the artifact
	Url                  *string          `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	ArtifactoryAuth      *ArtifactoryAuth `protobuf:"bytes,2,opt,name=artifactoryAuth" json:"artifactoryAuth,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ArtifactoryArtifact) Reset()         { *m = ArtifactoryArtifact{} }
func (m *ArtifactoryArtifact) String() string { return proto.CompactTextString(m) }
func (*ArtifactoryArtifact) ProtoMessage()    {}
func (*ArtifactoryArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{6}
}
func (m *ArtifactoryArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArtifactoryArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArtifactoryArtifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArtifactoryArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArtifactoryArtifact.Merge(m, src)
}
func (m *ArtifactoryArtifact) XXX_Size() int {
	return m.Size()
}
func (m *ArtifactoryArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_ArtifactoryArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_ArtifactoryArtifact proto.InternalMessageInfo

func (m *ArtifactoryArtifact) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *ArtifactoryArtifact) GetArtifactoryAuth() *ArtifactoryAuth {
	if m != nil {
		return m.ArtifactoryAuth
	}
	return nil
}

// ArtifactoryAuth describes the secret selectors required for authenticating to artifactory
type ArtifactoryAuth struct {
	// UsernameSecret is the secret selector to the repository username
	UsernameSecret *v1.SecretKeySelector `protobuf:"bytes,1,opt,name=usernameSecret" json:"usernameSecret,omitempty"`
	// PasswordSecret is the secret selector to the repository password
	PasswordSecret       *v1.SecretKeySelector `protobuf:"bytes,2,opt,name=passwordSecret" json:"passwordSecret,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ArtifactoryAuth) Reset()         { *m = ArtifactoryAuth{} }
func (m *ArtifactoryAuth) String() string { return proto.CompactTextString(m) }
func (*ArtifactoryAuth) ProtoMessage()    {}
func (*ArtifactoryAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{7}
}
func (m *ArtifactoryAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArtifactoryAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArtifactoryAuth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArtifactoryAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArtifactoryAuth.Merge(m, src)
}
func (m *ArtifactoryAuth) XXX_Size() int {
	return m.Size()
}
func (m *ArtifactoryAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_ArtifactoryAuth.DiscardUnknown(m)
}

var xxx_messageInfo_ArtifactoryAuth proto.InternalMessageInfo

func (m *ArtifactoryAuth) GetUsernameSecret() *v1.SecretKeySelector {
	if m != nil {
		return m.UsernameSecret
	}
	return nil
}

func (m *ArtifactoryAuth) GetPasswordSecret() *v1.SecretKeySelector {
	if m != nil {
		return m.PasswordSecret
	}
	return nil
}

// Backoff is a backoff strategy to use within retryStrategy
type Backoff struct {
	// Duration is the amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h")
	Duration *string `protobuf:"bytes,1,opt,name=duration" json:"duration,omitempty"`
	// Factor is a factor to multiply the base duration after each failed retry
	Factor *intstr.IntOrString `protobuf:"bytes,2,opt,name=factor" json:"factor,omitempty"`
	// MaxDuration is the maximum amount of time allowed for the backoff strategy
	MaxDuration          *string  `protobuf:"bytes,3,opt,name=maxDuration" json:"maxDuration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Backoff) Reset()         { *m = Backoff{} }
func (m *Backoff) String() string { return proto.CompactTextString(m) }
func (*Backoff) ProtoMessage()    {}
func (*Backoff) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{8}
}
func (m *Backoff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Backoff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Backoff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Backoff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Backoff.Merge(m, src)
}
func (m *Backoff) XXX_Size() int {
	return m.Size()
}
func (m *Backoff) XXX_DiscardUnknown() {
	xxx_messageInfo_Backoff.DiscardUnknown(m)
}

var xxx_messageInfo_Backoff proto.InternalMessageInfo

func (m *Backoff) GetDuration() string {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return ""
}

func (m *Backoff) GetFactor() *intstr.IntOrString {
	if m != nil {
		return m.Factor
	}
	return nil
}

func (m *Backoff) GetMaxDuration() string {
	if m != nil && m.MaxDuration != nil {
		return *m.MaxDuration
	}
	return ""
}

// Cache is the configuration for the type of cache to be used
type Cache struct {
	// ConfigMap sets a ConfigMap-based cache
	ConfigMap            *v1.ConfigMapKeySelector `protobuf:"bytes,1,opt,name=configMap" json:"configMap,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Cache) Reset()         { *m = Cache{} }
func (m *Cache) String() string { return proto.CompactTextString(m) }
func (*Cache) ProtoMessage()    {}
func (*Cache) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{9}
}
func (m *Cache) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cache) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cache.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cache) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cache.Merge(m, src)
}
func (m *Cache) XXX_Size() int {
	return m.Size()
}
func (m *Cache) XXX_DiscardUnknown() {
	xxx_messageInfo_Cache.DiscardUnknown(m)
}

var xxx_messageInfo_Cache proto.InternalMessageInfo

func (m *Cache) GetConfigMap() *v1.ConfigMapKeySelector {
	if m != nil {
		return m.ConfigMap
	}
	return nil
}

// ClusterWorkflowTemplate is the definition of a workflow template resource in cluster scope
// +genclient
// +genclient:noStatus
// +genclient:nonNamespaced
// +kubebuilder:resource:scope=Cluster,shortName=clusterwftmpl;cwft
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type ClusterWorkflowTemplate struct {
	Metadata             *v11.ObjectMeta       `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec                 *WorkflowTemplateSpec `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ClusterWorkflowTemplate) Reset()         { *m = ClusterWorkflowTemplate{} }
func (m *ClusterWorkflowTemplate) String() string { return proto.CompactTextString(m) }
func (*ClusterWorkflowTemplate) ProtoMessage()    {}
func (*ClusterWorkflowTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{10}
}
func (m *ClusterWorkflowTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterWorkflowTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterWorkflowTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterWorkflowTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterWorkflowTemplate.Merge(m, src)
}
func (m *ClusterWorkflowTemplate) XXX_Size() int {
	return m.Size()
}
func (m *ClusterWorkflowTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterWorkflowTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterWorkflowTemplate proto.InternalMessageInfo

func (m *ClusterWorkflowTemplate) GetMetadata() *v11.ObjectMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ClusterWorkflowTemplate) GetSpec() *WorkflowTemplateSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// ClusterWorkflowTemplateList is list of ClusterWorkflowTemplate resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type ClusterWorkflowTemplateList struct {
	Metadata             *v11.ListMeta              `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Items                []*ClusterWorkflowTemplate `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *ClusterWorkflowTemplateList) Reset()         { *m = ClusterWorkflowTemplateList{} }
func (m *ClusterWorkflowTemplateList) String() string { return proto.CompactTextString(m) }
func (*ClusterWorkflowTemplateList) ProtoMessage()    {}
func (*ClusterWorkflowTemplateList) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{11}
}
func (m *ClusterWorkflowTemplateList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterWorkflowTemplateList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterWorkflowTemplateList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterWorkflowTemplateList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterWorkflowTemplateList.Merge(m, src)
}
func (m *ClusterWorkflowTemplateList) XXX_Size() int {
	return m.Size()
}
func (m *ClusterWorkflowTemplateList) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterWorkflowTemplateList.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterWorkflowTemplateList proto.InternalMessageInfo

func (m *ClusterWorkflowTemplateList) GetMetadata() *v11.ListMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ClusterWorkflowTemplateList) GetItems() []*ClusterWorkflowTemplate {
	if m != nil {
		return m.Items
	}
	return nil
}

type Condition struct {
	// Type is the type of condition
	Type *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// Status is the status of the condition
	Status *string `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	// Message is the condition message
	Message              *string  `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Condition) Reset()         { *m = Condition{} }
func (m *Condition) String() string { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()    {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{12}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

func (m *Condition) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *Condition) GetStatus() string {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return ""
}

func (m *Condition) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

// ContinueOn defines if a workflow should continue even if a task or step fails/errors.
// It can be specified if the workflow should continue when the pod errors, fails or both.
type ContinueOn struct {
	// +optional
	Error *bool `protobuf:"varint,1,opt,name=error" json:"error,omitempty"`
	// +optional
	Failed               *bool    `protobuf:"varint,2,opt,name=failed" json:"failed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContinueOn) Reset()         { *m = ContinueOn{} }
func (m *ContinueOn) String() string { return proto.CompactTextString(m) }
func (*ContinueOn) ProtoMessage()    {}
func (*ContinueOn) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{13}
}
func (m *ContinueOn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContinueOn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContinueOn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContinueOn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContinueOn.Merge(m, src)
}
func (m *ContinueOn) XXX_Size() int {
	return m.Size()
}
func (m *ContinueOn) XXX_DiscardUnknown() {
	xxx_messageInfo_ContinueOn.DiscardUnknown(m)
}

var xxx_messageInfo_ContinueOn proto.InternalMessageInfo

func (m *ContinueOn) GetError() bool {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return false
}

func (m *ContinueOn) GetFailed() bool {
	if m != nil && m.Failed != nil {
		return *m.Failed
	}
	return false
}

// Counter is a Counter prometheus metric
type Counter struct {
	// Value is the value of the metric
	Value                *string  `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Counter) Reset()         { *m = Counter{} }
func (m *Counter) String() string { return proto.CompactTextString(m) }
func (*Counter) ProtoMessage()    {}
func (*Counter) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{14}
}
func (m *Counter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Counter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Counter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Counter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Counter.Merge(m, src)
}
func (m *Counter) XXX_Size() int {
	return m.Size()
}
func (m *Counter) XXX_DiscardUnknown() {
	xxx_messageInfo_Counter.DiscardUnknown(m)
}

var xxx_messageInfo_Counter proto.InternalMessageInfo

func (m *Counter) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// CronWorkflow is the definition of a scheduled workflow resource
// +genclient
// +genclient:noStatus
// +kubebuilder:resource:shortName=cwf;cronwf
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type CronWorkflow struct {
	Metadata             *v11.ObjectMeta     `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec                 *CronWorkflowSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status               *CronWorkflowStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CronWorkflow) Reset()         { *m = CronWorkflow{} }
func (m *CronWorkflow) String() string { return proto.CompactTextString(m) }
func (*CronWorkflow) ProtoMessage()    {}
func (*CronWorkflow) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{15}
}
func (m *CronWorkflow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronWorkflow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CronWorkflow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CronWorkflow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronWorkflow.Merge(m, src)
}
func (m *CronWorkflow) XXX_Size() int {
	return m.Size()
}
func (m *CronWorkflow) XXX_DiscardUnknown() {
	xxx_messageInfo_CronWorkflow.DiscardUnknown(m)
}

var xxx_messageInfo_CronWorkflow proto.InternalMessageInfo

func (m *CronWorkflow) GetMetadata() *v11.ObjectMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CronWorkflow) GetSpec() *CronWorkflowSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CronWorkflow) GetStatus() *CronWorkflowStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// CronWorkflowList is list of CronWorkflow resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type CronWorkflowList struct {
	Metadata             *v11.ListMeta   `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Items                []*CronWorkflow `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CronWorkflowList) Reset()         { *m = CronWorkflowList{} }
func (m *CronWorkflowList) String() string { return proto.CompactTextString(m) }
func (*CronWorkflowList) ProtoMessage()    {}
func (*CronWorkflowList) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{16}
}
func (m *CronWorkflowList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronWorkflowList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CronWorkflowList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CronWorkflowList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronWorkflowList.Merge(m, src)
}
func (m *CronWorkflowList) XXX_Size() int {
	return m.Size()
}
func (m *CronWorkflowList) XXX_DiscardUnknown() {
	xxx_messageInfo_CronWorkflowList.DiscardUnknown(m)
}

var xxx_messageInfo_CronWorkflowList proto.InternalMessageInfo

func (m *CronWorkflowList) GetMetadata() *v11.ListMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CronWorkflowList) GetItems() []*CronWorkflow {
	if m != nil {
		return m.Items
	}
	return nil
}

// CronWorkflowSpec is the specification of a CronWorkflow
type CronWorkflowSpec struct {
	// WorkflowSpec is the spec of the workflow to be run
	WorkflowSpec *WorkflowSpec `protobuf:"bytes,1,opt,name=workflowSpec" json:"workflowSpec,omitempty"`
	// Schedule is a schedule to run the Workflow in Cron format
	Schedule *string `protobuf:"bytes,2,opt,name=schedule" json:"schedule,omitempty"`
	// ConcurrencyPolicy is the K8s-style concurrency policy that will be used
	ConcurrencyPolicy *string `protobuf:"bytes,3,opt,name=concurrencyPolicy" json:"concurrencyPolicy,omitempty"`
	// Suspend is a flag that will stop new CronWorkflows from running if set to true
	Suspend *bool `protobuf:"varint,4,opt,name=suspend" json:"suspend,omitempty"`
	// StartingDeadlineSeconds is the K8s-style deadline that will limit the time a CronWorkflow will be run after its
	// original scheduled time if it is missed.
	StartingDeadlineSeconds *int64 `protobuf:"varint,5,opt,name=startingDeadlineSeconds" json:"startingDeadlineSeconds,omitempty"`
	// SuccessfulJobsHistoryLimit is the number of successful jobs to be kept at a time
	SuccessfulJobsHistoryLimit *int32 `protobuf:"varint,6,opt,name=successfulJobsHistoryLimit" json:"successfulJobsHistoryLimit,omitempty"`
	// FailedJobsHistoryLimit is the number of successful jobs to be kept at a time
	FailedJobsHistoryLimit *int32 `protobuf:"varint,7,opt,name=failedJobsHistoryLimit" json:"failedJobsHistoryLimit,omitempty"`
	// Timezone is the timezone against which the cron schedule will be calculated, e.g. "Asia/Tokyo". Default is machine's local time.
	Timezone *string `protobuf:"bytes,8,opt,name=timezone" json:"timezone,omitempty"`
	// WorkflowMetadata contains some metadata of the workflow to be run
	WorkflowMeta         *v11.ObjectMeta `protobuf:"bytes,9,opt,name=workflowMeta" json:"workflowMeta,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CronWorkflowSpec) Reset()         { *m = CronWorkflowSpec{} }
func (m *CronWorkflowSpec) String() string { return proto.CompactTextString(m) }
func (*CronWorkflowSpec) ProtoMessage()    {}
func (*CronWorkflowSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{17}
}
func (m *CronWorkflowSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronWorkflowSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CronWorkflowSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CronWorkflowSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronWorkflowSpec.Merge(m, src)
}
func (m *CronWorkflowSpec) XXX_Size() int {
	return m.Size()
}
func (m *CronWorkflowSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CronWorkflowSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CronWorkflowSpec proto.InternalMessageInfo

func (m *CronWorkflowSpec) GetWorkflowSpec() *WorkflowSpec {
	if m != nil {
		return m.WorkflowSpec
	}
	return nil
}

func (m *CronWorkflowSpec) GetSchedule() string {
	if m != nil && m.Schedule != nil {
		return *m.Schedule
	}
	return ""
}

func (m *CronWorkflowSpec) GetConcurrencyPolicy() string {
	if m != nil && m.ConcurrencyPolicy != nil {
		return *m.ConcurrencyPolicy
	}
	return ""
}

func (m *CronWorkflowSpec) GetSuspend() bool {
	if m != nil && m.Suspend != nil {
		return *m.Suspend
	}
	return false
}

func (m *CronWorkflowSpec) GetStartingDeadlineSeconds() int64 {
	if m != nil && m.StartingDeadlineSeconds != nil {
		return *m.StartingDeadlineSeconds
	}
	return 0
}

func (m *CronWorkflowSpec) GetSuccessfulJobsHistoryLimit() int32 {
	if m != nil && m.SuccessfulJobsHistoryLimit != nil {
		return *m.SuccessfulJobsHistoryLimit
	}
	return 0
}

func (m *CronWorkflowSpec) GetFailedJobsHistoryLimit() int32 {
	if m != nil && m.FailedJobsHistoryLimit != nil {
		return *m.FailedJobsHistoryLimit
	}
	return 0
}

func (m *CronWorkflowSpec) GetTimezone() string {
	if m != nil && m.Timezone != nil {
		return *m.Timezone
	}
	return ""
}

func (m *CronWorkflowSpec) GetWorkflowMeta() *v11.ObjectMeta {
	if m != nil {
		return m.WorkflowMeta
	}
	return nil
}

// CronWorkflowStatus is the status of a CronWorkflow
type CronWorkflowStatus struct {
	// Active is a list of active workflows stemming from this CronWorkflow
	Active []*v1.ObjectReference `protobuf:"bytes,1,rep,name=active" json:"active,omitempty"`
	// LastScheduleTime is the last time the CronWorkflow was scheduled
	LastScheduledTime *v11.Time `protobuf:"bytes,2,opt,name=lastScheduledTime" json:"lastScheduledTime,omitempty"`
	// Conditions is a list of conditions the CronWorkflow may have
	Conditions           []*Condition `protobuf:"bytes,3,rep,name=conditions" json:"conditions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CronWorkflowStatus) Reset()         { *m = CronWorkflowStatus{} }
func (m *CronWorkflowStatus) String() string { return proto.CompactTextString(m) }
func (*CronWorkflowStatus) ProtoMessage()    {}
func (*CronWorkflowStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{18}
}
func (m *CronWorkflowStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronWorkflowStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CronWorkflowStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CronWorkflowStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronWorkflowStatus.Merge(m, src)
}
func (m *CronWorkflowStatus) XXX_Size() int {
	return m.Size()
}
func (m *CronWorkflowStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_CronWorkflowStatus.DiscardUnknown(m)
}

var xxx_messageInfo_CronWorkflowStatus proto.InternalMessageInfo

func (m *CronWorkflowStatus) GetActive() []*v1.ObjectReference {
	if m != nil {
		return m.Active
	}
	return nil
}

func (m *CronWorkflowStatus) GetLastScheduledTime() *v11.Time {
	if m != nil {
		return m.LastScheduledTime
	}
	return nil
}

func (m *CronWorkflowStatus) GetConditions() []*Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// DAGTask represents a node in the graph during DAG execution
type DAGTask struct {
	// Name is the name of the target
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Name of template to execute
	Template *string `protobuf:"bytes,2,opt,name=template" json:"template,omitempty"`
	// Arguments are the parameter and artifact arguments to the template
	Arguments *Arguments `protobuf:"bytes,3,opt,name=arguments" json:"arguments,omitempty"`
	// TemplateRef is the reference to the template resource to execute.
	TemplateRef *TemplateRef `protobuf:"bytes,4,opt,name=templateRef" json:"templateRef,omitempty"`
	// Dependencies are name of other targets which this depends on
	Dependencies []string `protobuf:"bytes,5,rep,name=dependencies" json:"dependencies,omitempty"`
	// WithItems expands a task into multiple parallel tasks from the items in the list
	WithItems []*Item `protobuf:"bytes,6,rep,name=withItems" json:"withItems,omitempty"`
	// WithParam expands a task into multiple parallel tasks from the value in the parameter,
	// which is expected to be a JSON list.
	WithParam *string `protobuf:"bytes,7,opt,name=withParam" json:"withParam,omitempty"`
	// WithSequence expands a task into a numeric sequence
	WithSequence *Sequence `protobuf:"bytes,8,opt,name=withSequence" json:"withSequence,omitempty"`
	// When is an expression in which the task should conditionally execute
	When *string `protobuf:"bytes,9,opt,name=when" json:"when,omitempty"`
	// ContinueOn makes argo to proceed with the following step even if this step fails.
	// Errors and Failed states can be specified
	ContinueOn *ContinueOn `protobuf:"bytes,10,opt,name=continueOn" json:"continueOn,omitempty"`
	// OnExit is a template reference which is invoked at the end of the
	// template, irrespective of the success, failure, or error of the
	// primary template.
	OnExit *string `protobuf:"bytes,11,opt,name=onExit" json:"onExit,omitempty"`
	// Depends are name of other targets which this depends on
	Depends              *string  `protobuf:"bytes,12,opt,name=depends" json:"depends,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DAGTask) Reset()         { *m = DAGTask{} }
func (m *DAGTask) String() string { return proto.CompactTextString(m) }
func (*DAGTask) ProtoMessage()    {}
func (*DAGTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{19}
}
func (m *DAGTask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DAGTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DAGTask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DAGTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DAGTask.Merge(m, src)
}
func (m *DAGTask) XXX_Size() int {
	return m.Size()
}
func (m *DAGTask) XXX_DiscardUnknown() {
	xxx_messageInfo_DAGTask.DiscardUnknown(m)
}

var xxx_messageInfo_DAGTask proto.InternalMessageInfo

func (m *DAGTask) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DAGTask) GetTemplate() string {
	if m != nil && m.Template != nil {
		return *m.Template
	}
	return ""
}

func (m *DAGTask) GetArguments() *Arguments {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *DAGTask) GetTemplateRef() *TemplateRef {
	if m != nil {
		return m.TemplateRef
	}
	return nil
}

func (m *DAGTask) GetDependencies() []string {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

func (m *DAGTask) GetWithItems() []*Item {
	if m != nil {
		return m.WithItems
	}
	return nil
}

func (m *DAGTask) GetWithParam() string {
	if m != nil && m.WithParam != nil {
		return *m.WithParam
	}
	return ""
}

func (m *DAGTask) GetWithSequence() *Sequence {
	if m != nil {
		return m.WithSequence
	}
	return nil
}

func (m *DAGTask) GetWhen() string {
	if m != nil && m.When != nil {
		return *m.When
	}
	return ""
}

func (m *DAGTask) GetContinueOn() *ContinueOn {
	if m != nil {
		return m.ContinueOn
	}
	return nil
}

func (m *DAGTask) GetOnExit() string {
	if m != nil && m.OnExit != nil {
		return *m.OnExit
	}
	return ""
}

func (m *DAGTask) GetDepends() string {
	if m != nil && m.Depends != nil {
		return *m.Depends
	}
	return ""
}

// DAGTemplate is a template subtype for directed acyclic graph templates
type DAGTemplate struct {
	// Target are one or more names of targets to execute in a DAG
	Target *string `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	// Tasks are a list of DAG tasks
	// +patchStrategy=merge
	// +patchMergeKey=name
	Tasks []*DAGTask `protobuf:"bytes,2,rep,name=tasks" json:"tasks,omitempty"`
	// This flag is for DAG logic. The DAG logic has a built-in "fail fast" feature to stop scheduling new steps,
	// as soon as it detects that one of the DAG nodes is failed. Then it waits until all DAG nodes are completed
	// before failing the DAG itself.
	// The FailFast flag default is true,  if set to false, it will allow a DAG to run all branches of the DAG to
	// completion (either success or failure), regardless of the failed outcomes of branches in the DAG.
	// More info and example about this feature at https://github.com/argoproj/argo/issues/1442
	FailFast             *bool    `protobuf:"varint,3,opt,name=failFast" json:"failFast,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DAGTemplate) Reset()         { *m = DAGTemplate{} }
func (m *DAGTemplate) String() string { return proto.CompactTextString(m) }
func (*DAGTemplate) ProtoMessage()    {}
func (*DAGTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{20}
}
func (m *DAGTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DAGTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DAGTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DAGTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DAGTemplate.Merge(m, src)
}
func (m *DAGTemplate) XXX_Size() int {
	return m.Size()
}
func (m *DAGTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_DAGTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_DAGTemplate proto.InternalMessageInfo

func (m *DAGTemplate) GetTarget() string {
	if m != nil && m.Target != nil {
		return *m.Target
	}
	return ""
}

func (m *DAGTemplate) GetTasks() []*DAGTask {
	if m != nil {
		return m.Tasks
	}
	return nil
}

func (m *DAGTemplate) GetFailFast() bool {
	if m != nil && m.FailFast != nil {
		return *m.FailFast
	}
	return false
}

type Event struct {
	// Selector (https://github.com/antonmedv/expr) that we must must match the event. E.g. `payload.message == "test"`
	Selector             *string  `protobuf:"bytes,1,opt,name=selector" json:"selector,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{21}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetSelector() string {
	if m != nil && m.Selector != nil {
		return *m.Selector
	}
	return ""
}

// ExecutorConfig holds configurations of an executor container.
type ExecutorConfig struct {
	// ServiceAccountName specifies the service account name of the executor container.
	ServiceAccountName   *string  `protobuf:"bytes,1,opt,name=serviceAccountName" json:"serviceAccountName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecutorConfig) Reset()         { *m = ExecutorConfig{} }
func (m *ExecutorConfig) String() string { return proto.CompactTextString(m) }
func (*ExecutorConfig) ProtoMessage()    {}
func (*ExecutorConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{22}
}
func (m *ExecutorConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutorConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutorConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutorConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutorConfig.Merge(m, src)
}
func (m *ExecutorConfig) XXX_Size() int {
	return m.Size()
}
func (m *ExecutorConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutorConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutorConfig proto.InternalMessageInfo

func (m *ExecutorConfig) GetServiceAccountName() string {
	if m != nil && m.ServiceAccountName != nil {
		return *m.ServiceAccountName
	}
	return ""
}

// GCSArtifact is the location of a GCS artifact
type GCSArtifact struct {
	GCSBucket *GCSBucket `protobuf:"bytes,1,opt,name=gCSBucket" json:"gCSBucket,omitempty"`
	// Key is the path in the bucket where the artifact resides
	Key                  *string  `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GCSArtifact) Reset()         { *m = GCSArtifact{} }
func (m *GCSArtifact) String() string { return proto.CompactTextString(m) }
func (*GCSArtifact) ProtoMessage()    {}
func (*GCSArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{23}
}
func (m *GCSArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCSArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GCSArtifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GCSArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCSArtifact.Merge(m, src)
}
func (m *GCSArtifact) XXX_Size() int {
	return m.Size()
}
func (m *GCSArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_GCSArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_GCSArtifact proto.InternalMessageInfo

func (m *GCSArtifact) GetGCSBucket() *GCSBucket {
	if m != nil {
		return m.GCSBucket
	}
	return nil
}

func (m *GCSArtifact) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

// GCSBucket contains the access information for interfacring with a GCS bucket
type GCSBucket struct {
	// Bucket is the name of the bucket
	Bucket *string `protobuf:"bytes,1,opt,name=bucket" json:"bucket,omitempty"`
	// ServiceAccountKeySecret is the secret selector to the bucket's service account key
	ServiceAccountKeySecret *v1.SecretKeySelector `protobuf:"bytes,2,opt,name=serviceAccountKeySecret" json:"serviceAccountKeySecret,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}              `json:"-"`
	XXX_unrecognized        []byte                `json:"-"`
	XXX_sizecache           int32                 `json:"-"`
}

func (m *GCSBucket) Reset()         { *m = GCSBucket{} }
func (m *GCSBucket) String() string { return proto.CompactTextString(m) }
func (*GCSBucket) ProtoMessage()    {}
func (*GCSBucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{24}
}
func (m *GCSBucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCSBucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GCSBucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GCSBucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCSBucket.Merge(m, src)
}
func (m *GCSBucket) XXX_Size() int {
	return m.Size()
}
func (m *GCSBucket) XXX_DiscardUnknown() {
	xxx_messageInfo_GCSBucket.DiscardUnknown(m)
}

var xxx_messageInfo_GCSBucket proto.InternalMessageInfo

func (m *GCSBucket) GetBucket() string {
	if m != nil && m.Bucket != nil {
		return *m.Bucket
	}
	return ""
}

func (m *GCSBucket) GetServiceAccountKeySecret() *v1.SecretKeySelector {
	if m != nil {
		return m.ServiceAccountKeySecret
	}
	return nil
}

// Gauge is a Gauge prometheus metric
type Gauge struct {
	// Value is the value of the metric
	Value *string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	// Realtime emits this metric in real time if applicable
	Realtime             *bool    `protobuf:"varint,2,opt,name=realtime" json:"realtime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Gauge) Reset()         { *m = Gauge{} }
func (m *Gauge) String() string { return proto.CompactTextString(m) }
func (*Gauge) ProtoMessage()    {}
func (*Gauge) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{25}
}
func (m *Gauge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Gauge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Gauge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Gauge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Gauge.Merge(m, src)
}
func (m *Gauge) XXX_Size() int {
	return m.Size()
}
func (m *Gauge) XXX_DiscardUnknown() {
	xxx_messageInfo_Gauge.DiscardUnknown(m)
}

var xxx_messageInfo_Gauge proto.InternalMessageInfo

func (m *Gauge) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *Gauge) GetRealtime() bool {
	if m != nil && m.Realtime != nil {
		return *m.Realtime
	}
	return false
}

// GitArtifact is the location of an git artifact
type GitArtifact struct {
	// Repo is the git repository
	Repo *string `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
	// Revision is the git commit, tag, branch to checkout
	Revision *string `protobuf:"bytes,2,opt,name=revision" json:"revision,omitempty"`
	// Depth specifies clones/fetches should be shallow and include the given
	// number of commits from the branch tip
	Depth *uint64 `protobuf:"varint,3,opt,name=depth" json:"depth,omitempty"`
	// Fetch specifies a number of refs that should be fetched before checkout
	Fetch []string `protobuf:"bytes,4,rep,name=fetch" json:"fetch,omitempty"`
	// UsernameSecret is the secret selector to the repository username
	UsernameSecret *v1.SecretKeySelector `protobuf:"bytes,5,opt,name=usernameSecret" json:"usernameSecret,omitempty"`
	// PasswordSecret is the secret selector to the repository password
	PasswordSecret *v1.SecretKeySelector `protobuf:"bytes,6,opt,name=passwordSecret" json:"passwordSecret,omitempty"`
	// SSHPrivateKeySecret is the secret selector to the repository ssh private key
	SshPrivateKeySecret *v1.SecretKeySelector `protobuf:"bytes,7,opt,name=sshPrivateKeySecret" json:"sshPrivateKeySecret,omitempty"`
	// InsecureIgnoreHostKey disables SSH strict host key checking during git clone
	InsecureIgnoreHostKey *bool    `protobuf:"varint,8,opt,name=insecureIgnoreHostKey" json:"insecureIgnoreHostKey,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *GitArtifact) Reset()         { *m = GitArtifact{} }
func (m *GitArtifact) String() string { return proto.CompactTextString(m) }
func (*GitArtifact) ProtoMessage()    {}
func (*GitArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{26}
}
func (m *GitArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GitArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GitArtifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GitArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GitArtifact.Merge(m, src)
}
func (m *GitArtifact) XXX_Size() int {
	return m.Size()
}
func (m *GitArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_GitArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_GitArtifact proto.InternalMessageInfo

func (m *GitArtifact) GetRepo() string {
	if m != nil && m.Repo != nil {
		return *m.Repo
	}
	return ""
}

func (m *GitArtifact) GetRevision() string {
	if m != nil && m.Revision != nil {
		return *m.Revision
	}
	return ""
}

func (m *GitArtifact) GetDepth() uint64 {
	if m != nil && m.Depth != nil {
		return *m.Depth
	}
	return 0
}

func (m *GitArtifact) GetFetch() []string {
	if m != nil {
		return m.Fetch
	}
	return nil
}

func (m *GitArtifact) GetUsernameSecret() *v1.SecretKeySelector {
	if m != nil {
		return m.UsernameSecret
	}
	return nil
}

func (m *GitArtifact) GetPasswordSecret() *v1.SecretKeySelector {
	if m != nil {
		return m.PasswordSecret
	}
	return nil
}

func (m *GitArtifact) GetSshPrivateKeySecret() *v1.SecretKeySelector {
	if m != nil {
		return m.SshPrivateKeySecret
	}
	return nil
}

func (m *GitArtifact) GetInsecureIgnoreHostKey() bool {
	if m != nil && m.InsecureIgnoreHostKey != nil {
		return *m.InsecureIgnoreHostKey
	}
	return false
}

// HDFSArtifact is the location of an HDFS artifact
type HDFSArtifact struct {
	HDFSConfig *HDFSConfig `protobuf:"bytes,1,opt,name=hDFSConfig" json:"hDFSConfig,omitempty"`
	// Path is a file path in HDFS
	Path *string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// Force copies a file forcibly even if it exists (default: false)
	Force                *bool    `protobuf:"varint,3,opt,name=force" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HDFSArtifact) Reset()         { *m = HDFSArtifact{} }
func (m *HDFSArtifact) String() string { return proto.CompactTextString(m) }
func (*HDFSArtifact) ProtoMessage()    {}
func (*HDFSArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{27}
}
func (m *HDFSArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HDFSArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HDFSArtifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HDFSArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HDFSArtifact.Merge(m, src)
}
func (m *HDFSArtifact) XXX_Size() int {
	return m.Size()
}
func (m *HDFSArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_HDFSArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_HDFSArtifact proto.InternalMessageInfo

func (m *HDFSArtifact) GetHDFSConfig() *HDFSConfig {
	if m != nil {
		return m.HDFSConfig
	}
	return nil
}

func (m *HDFSArtifact) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *HDFSArtifact) GetForce() bool {
	if m != nil && m.Force != nil {
		return *m.Force
	}
	return false
}

// HDFSConfig is configurations for HDFS
type HDFSConfig struct {
	HDFSKrbConfig *HDFSKrbConfig `protobuf:"bytes,1,opt,name=hDFSKrbConfig" json:"hDFSKrbConfig,omitempty"`
	// Addresses is accessible addresses of HDFS name nodes
	Addresses []string `protobuf:"bytes,2,rep,name=addresses" json:"addresses,omitempty"`
	// HDFSUser is the user to access HDFS file system.
	// It is ignored if either ccache or keytab is used.
	HdfsUser             *string  `protobuf:"bytes,3,opt,name=hdfsUser" json:"hdfsUser,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HDFSConfig) Reset()         { *m = HDFSConfig{} }
func (m *HDFSConfig) String() string { return proto.CompactTextString(m) }
func (*HDFSConfig) ProtoMessage()    {}
func (*HDFSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{28}
}
func (m *HDFSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HDFSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HDFSConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HDFSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HDFSConfig.Merge(m, src)
}
func (m *HDFSConfig) XXX_Size() int {
	return m.Size()
}
func (m *HDFSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HDFSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HDFSConfig proto.InternalMessageInfo

func (m *HDFSConfig) GetHDFSKrbConfig() *HDFSKrbConfig {
	if m != nil {
		return m.HDFSKrbConfig
	}
	return nil
}

func (m *HDFSConfig) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *HDFSConfig) GetHdfsUser() string {
	if m != nil && m.HdfsUser != nil {
		return *m.HdfsUser
	}
	return ""
}

// HDFSKrbConfig is auth configurations for Kerberos
type HDFSKrbConfig struct {
	// KrbCCacheSecret is the secret selector for Kerberos ccache
	// Either ccache or keytab can be set to use Kerberos.
	KrbCCacheSecret *v1.SecretKeySelector `protobuf:"bytes,1,opt,name=krbCCacheSecret" json:"krbCCacheSecret,omitempty"`
	// KrbKeytabSecret is the secret selector for Kerberos keytab
	// Either ccache or keytab can be set to use Kerberos.
	KrbKeytabSecret *v1.SecretKeySelector `protobuf:"bytes,2,opt,name=krbKeytabSecret" json:"krbKeytabSecret,omitempty"`
	// KrbUsername is the Kerberos username used with Kerberos keytab
	// It must be set if keytab is used.
	KrbUsername *string `protobuf:"bytes,3,opt,name=krbUsername" json:"krbUsername,omitempty"`
	// KrbRealm is the Kerberos realm used with Kerberos keytab
	// It must be set if keytab is used.
	KrbRealm *string `protobuf:"bytes,4,opt,name=krbRealm" json:"krbRealm,omitempty"`
	// KrbConfig is the configmap selector for Kerberos config as string
	// It must be set if either ccache or keytab is used.
	KrbConfigConfigMap *v1.ConfigMapKeySelector `protobuf:"bytes,5,opt,name=krbConfigConfigMap" json:"krbConfigConfigMap,omitempty"`
	// KrbServicePrincipalName is the principal name of Kerberos service
	// It must be set if either ccache or keytab is used.
	KrbServicePrincipalName *string  `protobuf:"bytes,6,opt,name=krbServicePrincipalName" json:"krbServicePrincipalName,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *HDFSKrbConfig) Reset()         { *m = HDFSKrbConfig{} }
func (m *HDFSKrbConfig) String() string { return proto.CompactTextString(m) }
func (*HDFSKrbConfig) ProtoMessage()    {}
func (*HDFSKrbConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{29}
}
func (m *HDFSKrbConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HDFSKrbConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HDFSKrbConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HDFSKrbConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HDFSKrbConfig.Merge(m, src)
}
func (m *HDFSKrbConfig) XXX_Size() int {
	return m.Size()
}
func (m *HDFSKrbConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HDFSKrbConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HDFSKrbConfig proto.InternalMessageInfo

func (m *HDFSKrbConfig) GetKrbCCacheSecret() *v1.SecretKeySelector {
	if m != nil {
		return m.KrbCCacheSecret
	}
	return nil
}

func (m *HDFSKrbConfig) GetKrbKeytabSecret() *v1.SecretKeySelector {
	if m != nil {
		return m.KrbKeytabSecret
	}
	return nil
}

func (m *HDFSKrbConfig) GetKrbUsername() string {
	if m != nil && m.KrbUsername != nil {
		return *m.KrbUsername
	}
	return ""
}

func (m *HDFSKrbConfig) GetKrbRealm() string {
	if m != nil && m.KrbRealm != nil {
		return *m.KrbRealm
	}
	return ""
}

func (m *HDFSKrbConfig) GetKrbConfigConfigMap() *v1.ConfigMapKeySelector {
	if m != nil {
		return m.KrbConfigConfigMap
	}
	return nil
}

func (m *HDFSKrbConfig) GetKrbServicePrincipalName() string {
	if m != nil && m.KrbServicePrincipalName != nil {
		return *m.KrbServicePrincipalName
	}
	return ""
}

// HTTPArtifact allows an file served on HTTP to be placed as an input artifact in a container
type HTTPArtifact struct {
	// URL of the artifact
	Url *string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	// Headers are an optional list of headers to send with HTTP requests for artifacts
	Headers              []*Header `protobuf:"bytes,2,rep,name=headers" json:"headers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *HTTPArtifact) Reset()         { *m = HTTPArtifact{} }
func (m *HTTPArtifact) String() string { return proto.CompactTextString(m) }
func (*HTTPArtifact) ProtoMessage()    {}
func (*HTTPArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{30}
}
func (m *HTTPArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPArtifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HTTPArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPArtifact.Merge(m, src)
}
func (m *HTTPArtifact) XXX_Size() int {
	return m.Size()
}
func (m *HTTPArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPArtifact proto.InternalMessageInfo

func (m *HTTPArtifact) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *HTTPArtifact) GetHeaders() []*Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

// Header indicate a key-value request header to be used when fetching artifacts over HTTP
type Header struct {
	// Name is the header name
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Value is the literal value to use for the header
	Value                *string  `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{31}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Header) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// Histogram is a Histogram prometheus metric
type Histogram struct {
	// Value is the value of the metric
	Value *string `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	// Buckets is a list of bucket divisors for the histogram
	Buckets              []*Amount `protobuf:"bytes,4,rep,name=buckets" json:"buckets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Histogram) Reset()         { *m = Histogram{} }
func (m *Histogram) String() string { return proto.CompactTextString(m) }
func (*Histogram) ProtoMessage()    {}
func (*Histogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{32}
}
func (m *Histogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Histogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Histogram.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Histogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Histogram.Merge(m, src)
}
func (m *Histogram) XXX_Size() int {
	return m.Size()
}
func (m *Histogram) XXX_DiscardUnknown() {
	xxx_messageInfo_Histogram.DiscardUnknown(m)
}

var xxx_messageInfo_Histogram proto.InternalMessageInfo

func (m *Histogram) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *Histogram) GetBuckets() []*Amount {
	if m != nil {
		return m.Buckets
	}
	return nil
}

// Inputs are the mechanism for passing parameters, artifacts, volumes from one template to another
type Inputs struct {
	// Parameters are a list of parameters passed as inputs
	// +patchStrategy=merge
	// +patchMergeKey=name
	Parameters []*Parameter `protobuf:"bytes,1,rep,name=parameters" json:"parameters,omitempty"`
	// Artifact are a list of artifacts passed as inputs
	// +patchStrategy=merge
	// +patchMergeKey=name
	Artifacts            []*Artifact `protobuf:"bytes,2,rep,name=artifacts" json:"artifacts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Inputs) Reset()         { *m = Inputs{} }
func (m *Inputs) String() string { return proto.CompactTextString(m) }
func (*Inputs) ProtoMessage()    {}
func (*Inputs) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{33}
}
func (m *Inputs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Inputs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Inputs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Inputs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Inputs.Merge(m, src)
}
func (m *Inputs) XXX_Size() int {
	return m.Size()
}
func (m *Inputs) XXX_DiscardUnknown() {
	xxx_messageInfo_Inputs.DiscardUnknown(m)
}

var xxx_messageInfo_Inputs proto.InternalMessageInfo

func (m *Inputs) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Inputs) GetArtifacts() []*Artifact {
	if m != nil {
		return m.Artifacts
	}
	return nil
}

// Item expands a single workflow step into multiple parallel steps
// The value of Item can be a map, string, bool, or number
//
// +protobuf.options.(gogoproto.goproto_stringer)=false
// +kubebuilder:validation:Type=object
type Item struct {
	Value                []byte   `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{34}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// A link to another app.
// +patchStrategy=merge
// +patchMergeKey=name
type Link struct {
	// The name of the link, E.g. "Workflow Logs" or "Pod Logs"
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Either "workflow" or "pod"
	Scope *string `protobuf:"bytes,2,opt,name=scope" json:"scope,omitempty"`
	// The URL. May contain "${metadata.namespace}", "${metadata.name}", "${status.startedAt}" and "${status.finishedAt}".
	Url                  *string  `protobuf:"bytes,3,opt,name=url" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{35}
}
func (m *Link) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Link.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return m.Size()
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

func (m *Link) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Link) GetScope() string {
	if m != nil && m.Scope != nil {
		return *m.Scope
	}
	return ""
}

func (m *Link) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

// MemoizationStatus is the status of this memoized node
type MemoizationStatus struct {
	// Hit indicates whether this node was created from a cache entry
	Hit *bool `protobuf:"varint,1,opt,name=hit" json:"hit,omitempty"`
	// Key is the name of the key used for this node's cache
	Key *string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	// Cache is the name of the cache that was used
	CacheName            *string  `protobuf:"bytes,3,opt,name=cacheName" json:"cacheName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemoizationStatus) Reset()         { *m = MemoizationStatus{} }
func (m *MemoizationStatus) String() string { return proto.CompactTextString(m) }
func (*MemoizationStatus) ProtoMessage()    {}
func (*MemoizationStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{36}
}
func (m *MemoizationStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoizationStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoizationStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoizationStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoizationStatus.Merge(m, src)
}
func (m *MemoizationStatus) XXX_Size() int {
	return m.Size()
}
func (m *MemoizationStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoizationStatus.DiscardUnknown(m)
}

var xxx_messageInfo_MemoizationStatus proto.InternalMessageInfo

func (m *MemoizationStatus) GetHit() bool {
	if m != nil && m.Hit != nil {
		return *m.Hit
	}
	return false
}

func (m *MemoizationStatus) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *MemoizationStatus) GetCacheName() string {
	if m != nil && m.CacheName != nil {
		return *m.CacheName
	}
	return ""
}

// Memoization enables caching for the Outputs of the template
type Memoize struct {
	// Key is the key to use as the caching key
	Key *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Cache sets and configures the kind of cache
	Cache *Cache `protobuf:"bytes,2,opt,name=cache" json:"cache,omitempty"`
	// MaxAge is the maximum age (e.g. "180s", "24h") of an entry that is still considered valid. If an entry is older
	// than the MaxAge, it will be ignored.
	MaxAge               *string  `protobuf:"bytes,3,opt,name=maxAge" json:"maxAge,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Memoize) Reset()         { *m = Memoize{} }
func (m *Memoize) String() string { return proto.CompactTextString(m) }
func (*Memoize) ProtoMessage()    {}
func (*Memoize) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{37}
}
func (m *Memoize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Memoize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Memoize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Memoize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Memoize.Merge(m, src)
}
func (m *Memoize) XXX_Size() int {
	return m.Size()
}
func (m *Memoize) XXX_DiscardUnknown() {
	xxx_messageInfo_Memoize.DiscardUnknown(m)
}

var xxx_messageInfo_Memoize proto.InternalMessageInfo

func (m *Memoize) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Memoize) GetCache() *Cache {
	if m != nil {
		return m.Cache
	}
	return nil
}

func (m *Memoize) GetMaxAge() string {
	if m != nil && m.MaxAge != nil {
		return *m.MaxAge
	}
	return ""
}

// Pod metdata
type Metadata struct {
	Annotations          map[string]string `protobuf:"bytes,1,rep,name=annotations" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Labels               map[string]string `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{38}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Metadata) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// MetricLabel is a single label for a prometheus metric
type MetricLabel struct {
	Key                  *string  `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value                *string  `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetricLabel) Reset()         { *m = MetricLabel{} }
func (m *MetricLabel) String() string { return proto.CompactTextString(m) }
func (*MetricLabel) ProtoMessage()    {}
func (*MetricLabel) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{39}
}
func (m *MetricLabel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricLabel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricLabel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricLabel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricLabel.Merge(m, src)
}
func (m *MetricLabel) XXX_Size() int {
	return m.Size()
}
func (m *MetricLabel) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricLabel.DiscardUnknown(m)
}

var xxx_messageInfo_MetricLabel proto.InternalMessageInfo

func (m *MetricLabel) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *MetricLabel) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// Metrics are a list of metrics emitted from a Workflow/Template
type Metrics struct {
	// Prometheus is a list of prometheus metrics to be emitted
	Prometheus           []*Prometheus `protobuf:"bytes,1,rep,name=prometheus" json:"prometheus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Metrics) Reset()         { *m = Metrics{} }
func (m *Metrics) String() string { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()    {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{40}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func (m *Metrics) GetPrometheus() []*Prometheus {
	if m != nil {
		return m.Prometheus
	}
	return nil
}

// Mutex holds Mutex configuration
type Mutex struct {
	// name of the mutex
	Name                 *string  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Mutex) Reset()         { *m = Mutex{} }
func (m *Mutex) String() string { return proto.CompactTextString(m) }
func (*Mutex) ProtoMessage()    {}
func (*Mutex) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{41}
}
func (m *Mutex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mutex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mutex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mutex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mutex.Merge(m, src)
}
func (m *Mutex) XXX_Size() int {
	return m.Size()
}
func (m *Mutex) XXX_DiscardUnknown() {
	xxx_messageInfo_Mutex.DiscardUnknown(m)
}

var xxx_messageInfo_Mutex proto.InternalMessageInfo

func (m *Mutex) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

// MutexHolding describes the mutex and the object which is holding it.
type MutexHolding struct {
	// Reference for the mutex
	// e.g: ${namespace}/mutex/${mutexName}
	Mutex *string `protobuf:"bytes,1,opt,name=mutex" json:"mutex,omitempty"`
	// Holder is a reference to the object which holds the Mutex.
	// Holding Scenario:
	//   1. Current workflow's NodeID which is holding the lock.
	//      e.g: ${NodeID}
	// Waiting Scenario:
	//   1. Current workflow or other workflow NodeID which is holding the lock.
	//      e.g: ${WorkflowName}/${NodeID}
	Holder               *string  `protobuf:"bytes,2,opt,name=holder" json:"holder,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MutexHolding) Reset()         { *m = MutexHolding{} }
func (m *MutexHolding) String() string { return proto.CompactTextString(m) }
func (*MutexHolding) ProtoMessage()    {}
func (*MutexHolding) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{42}
}
func (m *MutexHolding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MutexHolding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MutexHolding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MutexHolding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MutexHolding.Merge(m, src)
}
func (m *MutexHolding) XXX_Size() int {
	return m.Size()
}
func (m *MutexHolding) XXX_DiscardUnknown() {
	xxx_messageInfo_MutexHolding.DiscardUnknown(m)
}

var xxx_messageInfo_MutexHolding proto.InternalMessageInfo

func (m *MutexHolding) GetMutex() string {
	if m != nil && m.Mutex != nil {
		return *m.Mutex
	}
	return ""
}

func (m *MutexHolding) GetHolder() string {
	if m != nil && m.Holder != nil {
		return *m.Holder
	}
	return ""
}

// MutexStatus contains which objects hold  mutex locks, and which objects this workflow is waiting on to release locks.
type MutexStatus struct {
	// Holding is a list of mutexes and their respective objects that are held by mutex lock for this workflow.
	// +listType=atomic
	Holding []*MutexHolding `protobuf:"bytes,1,rep,name=holding" json:"holding,omitempty"`
	// Waiting is a list of mutexes and their respective objects this workflow is waiting for.
	// +listType=atomic
	Waiting              []*MutexHolding `protobuf:"bytes,2,rep,name=waiting" json:"waiting,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MutexStatus) Reset()         { *m = MutexStatus{} }
func (m *MutexStatus) String() string { return proto.CompactTextString(m) }
func (*MutexStatus) ProtoMessage()    {}
func (*MutexStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{43}
}
func (m *MutexStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MutexStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MutexStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MutexStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MutexStatus.Merge(m, src)
}
func (m *MutexStatus) XXX_Size() int {
	return m.Size()
}
func (m *MutexStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_MutexStatus.DiscardUnknown(m)
}

var xxx_messageInfo_MutexStatus proto.InternalMessageInfo

func (m *MutexStatus) GetHolding() []*MutexHolding {
	if m != nil {
		return m.Holding
	}
	return nil
}

func (m *MutexStatus) GetWaiting() []*MutexHolding {
	if m != nil {
		return m.Waiting
	}
	return nil
}

// NodeStatus contains status information about an individual node in the workflow
type NodeStatus struct {
	// ID is a unique identifier of a node within the worklow
	// It is implemented as a hash of the node name, which makes the ID deterministic
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Name is unique name in the node tree used to generate the node ID
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// DisplayName is a human readable representation of the node. Unique within a template boundary
	DisplayName *string `protobuf:"bytes,3,opt,name=displayName" json:"displayName,omitempty"`
	// Type indicates type of node
	Type *string `protobuf:"bytes,4,opt,name=type" json:"type,omitempty"`
	// TemplateName is the template name which this node corresponds to.
	// Not applicable to virtual nodes (e.g. Retry, StepGroup)
	TemplateName *string `protobuf:"bytes,5,opt,name=templateName" json:"templateName,omitempty"`
	// TemplateRef is the reference to the template resource which this node corresponds to.
	// Not applicable to virtual nodes (e.g. Retry, StepGroup)
	TemplateRef *TemplateRef `protobuf:"bytes,6,opt,name=templateRef" json:"templateRef,omitempty"`
	// StoredTemplateID is the ID of stored template.
	// DEPRECATED: This value is not used anymore.
	StoredTemplateID *string `protobuf:"bytes,18,opt,name=storedTemplateID" json:"storedTemplateID,omitempty"`
	// WorkflowTemplateName is the WorkflowTemplate resource name on which the resolved template of this node is retrieved.
	// DEPRECATED: This value is not used anymore.
	WorkflowTemplateName *string `protobuf:"bytes,19,opt,name=workflowTemplateName" json:"workflowTemplateName,omitempty"`
	// TemplateScope is the template scope in which the template of this node was retrieved.
	TemplateScope *string `protobuf:"bytes,20,opt,name=templateScope" json:"templateScope,omitempty"`
	// Phase a simple, high-level summary of where the node is in its lifecycle.
	// Can be used as a state machine.
	Phase *string `protobuf:"bytes,7,opt,name=phase" json:"phase,omitempty"`
	// BoundaryID indicates the node ID of the associated template root node in which this node belongs to
	BoundaryID *string `protobuf:"bytes,8,opt,name=boundaryID" json:"boundaryID,omitempty"`
	// A human readable message indicating details about why the node is in this condition.
	Message *string `protobuf:"bytes,9,opt,name=message" json:"message,omitempty"`
	// Time at which this node started
	StartedAt *v11.Time `protobuf:"bytes,10,opt,name=startedAt" json:"startedAt,omitempty"`
	// Time at which this node completed
	FinishedAt *v11.Time `protobuf:"bytes,11,opt,name=finishedAt" json:"finishedAt,omitempty"`
	// EstimatedDuration in seconds.
	EstimatedDuration *int64 `protobuf:"varint,24,opt,name=estimatedDuration" json:"estimatedDuration,omitempty"`
	// ResourcesDuration is indicative, but not accurate, resource duration. This is populated when the nodes completes.
	ResourcesDuration map[string]int64 `protobuf:"bytes,21,rep,name=resourcesDuration" json:"resourcesDuration,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// PodIP captures the IP of the pod for daemoned steps
	PodIP *string `protobuf:"bytes,12,opt,name=podIP" json:"podIP,omitempty"`
	// Daemoned tracks whether or not this node was daemoned and need to be terminated
	Daemoned *bool `protobuf:"varint,13,opt,name=daemoned" json:"daemoned,omitempty"`
	// Inputs captures input parameter values and artifact locations supplied to this template invocation
	Inputs *Inputs `protobuf:"bytes,14,opt,name=inputs" json:"inputs,omitempty"`
	// Outputs captures output parameter values and artifact locations produced by this template invocation
	Outputs *Outputs `protobuf:"bytes,15,opt,name=outputs" json:"outputs,omitempty"`
	// Children is a list of child node IDs
	Children []string `protobuf:"bytes,16,rep,name=children" json:"children,omitempty"`
	// OutboundNodes tracks the node IDs which are considered "outbound" nodes to a template invocation.
	// For every invocation of a template, there are nodes which we considered as "outbound". Essentially,
	// these are last nodes in the execution sequence to run, before the template is considered completed.
	// These nodes are then connected as parents to a following step.
	//
	// In the case of single pod steps (i.e. container, script, resource templates), this list will be nil
	// since the pod itself is already considered the "outbound" node.
	// In the case of DAGs, outbound nodes are the "target" tasks (tasks with no children).
	// In the case of steps, outbound nodes are all the containers involved in the last step group.
	// NOTE: since templates are composable, the list of outbound nodes are carried upwards when
	// a DAG/steps template invokes another DAG/steps template. In other words, the outbound nodes of
	// a template, will be a superset of the outbound nodes of its last children.
	OutboundNodes []string `protobuf:"bytes,17,rep,name=outboundNodes" json:"outboundNodes,omitempty"`
	// HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
	HostNodeName *string `protobuf:"bytes,22,opt,name=hostNodeName" json:"hostNodeName,omitempty"`
	// MemoizationStatus holds information about cached nodes
	MemoizationStatus *MemoizationStatus `protobuf:"bytes,23,opt,name=memoizationStatus" json:"memoizationStatus,omitempty"`
	// SynchronizationStatus is the synchronization status of the node
	SynchronizationStatus *NodeSynchronizationStatus `protobuf:"bytes,25,opt,name=synchronizationStatus" json:"synchronizationStatus,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                   `json:"-"`
	XXX_unrecognized      []byte                     `json:"-"`
	XXX_sizecache         int32                      `json:"-"`
}

func (m *NodeStatus) Reset()         { *m = NodeStatus{} }
func (m *NodeStatus) String() string { return proto.CompactTextString(m) }
func (*NodeStatus) ProtoMessage()    {}
func (*NodeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{44}
}
func (m *NodeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeStatus.Merge(m, src)
}
func (m *NodeStatus) XXX_Size() int {
	return m.Size()
}
func (m *NodeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NodeStatus proto.InternalMessageInfo

func (m *NodeStatus) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *NodeStatus) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NodeStatus) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *NodeStatus) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *NodeStatus) GetTemplateName() string {
	if m != nil && m.TemplateName != nil {
		return *m.TemplateName
	}
	return ""
}

func (m *NodeStatus) GetTemplateRef() *TemplateRef {
	if m != nil {
		return m.TemplateRef
	}
	return nil
}

func (m *NodeStatus) GetStoredTemplateID() string {
	if m != nil && m.StoredTemplateID != nil {
		return *m.StoredTemplateID
	}
	return ""
}

func (m *NodeStatus) GetWorkflowTemplateName() string {
	if m != nil && m.WorkflowTemplateName != nil {
		return *m.WorkflowTemplateName
	}
	return ""
}

func (m *NodeStatus) GetTemplateScope() string {
	if m != nil && m.TemplateScope != nil {
		return *m.TemplateScope
	}
	return ""
}

func (m *NodeStatus) GetPhase() string {
	if m != nil && m.Phase != nil {
		return *m.Phase
	}
	return ""
}

func (m *NodeStatus) GetBoundaryID() string {
	if m != nil && m.BoundaryID != nil {
		return *m.BoundaryID
	}
	return ""
}

func (m *NodeStatus) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *NodeStatus) GetStartedAt() *v11.Time {
	if m != nil {
		return m.StartedAt
	}
	return nil
}

func (m *NodeStatus) GetFinishedAt() *v11.Time {
	if m != nil {
		return m.FinishedAt
	}
	return nil
}

func (m *NodeStatus) GetEstimatedDuration() int64 {
	if m != nil && m.EstimatedDuration != nil {
		return *m.EstimatedDuration
	}
	return 0
}

func (m *NodeStatus) GetResourcesDuration() map[string]int64 {
	if m != nil {
		return m.ResourcesDuration
	}
	return nil
}

func (m *NodeStatus) GetPodIP() string {
	if m != nil && m.PodIP != nil {
		return *m.PodIP
	}
	return ""
}

func (m *NodeStatus) GetDaemoned() bool {
	if m != nil && m.Daemoned != nil {
		return *m.Daemoned
	}
	return false
}

func (m *NodeStatus) GetInputs() *Inputs {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *NodeStatus) GetOutputs() *Outputs {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *NodeStatus) GetChildren() []string {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *NodeStatus) GetOutboundNodes() []string {
	if m != nil {
		return m.OutboundNodes
	}
	return nil
}

func (m *NodeStatus) GetHostNodeName() string {
	if m != nil && m.HostNodeName != nil {
		return *m.HostNodeName
	}
	return ""
}

func (m *NodeStatus) GetMemoizationStatus() *MemoizationStatus {
	if m != nil {
		return m.MemoizationStatus
	}
	return nil
}

func (m *NodeStatus) GetSynchronizationStatus() *NodeSynchronizationStatus {
	if m != nil {
		return m.SynchronizationStatus
	}
	return nil
}

// NodeSynchronizationStatus stores the status of a node
type NodeSynchronizationStatus struct {
	// Waiting is the name of the lock that this node is waiting for
	Waiting              *string  `protobuf:"bytes,1,opt,name=waiting" json:"waiting,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeSynchronizationStatus) Reset()         { *m = NodeSynchronizationStatus{} }
func (m *NodeSynchronizationStatus) String() string { return proto.CompactTextString(m) }
func (*NodeSynchronizationStatus) ProtoMessage()    {}
func (*NodeSynchronizationStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{45}
}
func (m *NodeSynchronizationStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeSynchronizationStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeSynchronizationStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeSynchronizationStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeSynchronizationStatus.Merge(m, src)
}
func (m *NodeSynchronizationStatus) XXX_Size() int {
	return m.Size()
}
func (m *NodeSynchronizationStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeSynchronizationStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NodeSynchronizationStatus proto.InternalMessageInfo

func (m *NodeSynchronizationStatus) GetWaiting() string {
	if m != nil && m.Waiting != nil {
		return *m.Waiting
	}
	return ""
}

// NoneStrategy indicates to skip tar process and upload the files or directory tree as independent
// files. Note that if the artifact is a directory, the artifact driver must support the ability to
// save/load the directory appropriately.
type NoneStrategy struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoneStrategy) Reset()         { *m = NoneStrategy{} }
func (m *NoneStrategy) String() string { return proto.CompactTextString(m) }
func (*NoneStrategy) ProtoMessage()    {}
func (*NoneStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{46}
}
func (m *NoneStrategy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoneStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoneStrategy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoneStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoneStrategy.Merge(m, src)
}
func (m *NoneStrategy) XXX_Size() int {
	return m.Size()
}
func (m *NoneStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_NoneStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_NoneStrategy proto.InternalMessageInfo

// OSSArtifact is the location of an Alibaba Cloud OSS artifact
type OSSArtifact struct {
	OSSBucket *OSSBucket `protobuf:"bytes,1,opt,name=oSSBucket" json:"oSSBucket,omitempty"`
	// Key is the path in the bucket where the artifact resides
	Key                  *string  `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OSSArtifact) Reset()         { *m = OSSArtifact{} }
func (m *OSSArtifact) String() string { return proto.CompactTextString(m) }
func (*OSSArtifact) ProtoMessage()    {}
func (*OSSArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{47}
}
func (m *OSSArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSSArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSSArtifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSSArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSSArtifact.Merge(m, src)
}
func (m *OSSArtifact) XXX_Size() int {
	return m.Size()
}
func (m *OSSArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_OSSArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_OSSArtifact proto.InternalMessageInfo

func (m *OSSArtifact) GetOSSBucket() *OSSBucket {
	if m != nil {
		return m.OSSBucket
	}
	return nil
}

func (m *OSSArtifact) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

// OSSBucket contains the access information required for interfacing with an Alibaba Cloud OSS bucket
type OSSBucket struct {
	// Endpoint is the hostname of the bucket endpoint
	Endpoint *string `protobuf:"bytes,1,opt,name=endpoint" json:"endpoint,omitempty"`
	// Bucket is the name of the bucket
	Bucket *string `protobuf:"bytes,2,opt,name=bucket" json:"bucket,omitempty"`
	// AccessKeySecret is the secret selector to the bucket's access key
	AccessKeySecret *v1.SecretKeySelector `protobuf:"bytes,3,opt,name=accessKeySecret" json:"accessKeySecret,omitempty"`
	// SecretKeySecret is the secret selector to the bucket's secret key
	SecretKeySecret      *v1.SecretKeySelector `protobuf:"bytes,4,opt,name=secretKeySecret" json:"secretKeySecret,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *OSSBucket) Reset()         { *m = OSSBucket{} }
func (m *OSSBucket) String() string { return proto.CompactTextString(m) }
func (*OSSBucket) ProtoMessage()    {}
func (*OSSBucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{48}
}
func (m *OSSBucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSSBucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSSBucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSSBucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSSBucket.Merge(m, src)
}
func (m *OSSBucket) XXX_Size() int {
	return m.Size()
}
func (m *OSSBucket) XXX_DiscardUnknown() {
	xxx_messageInfo_OSSBucket.DiscardUnknown(m)
}

var xxx_messageInfo_OSSBucket proto.InternalMessageInfo

func (m *OSSBucket) GetEndpoint() string {
	if m != nil && m.Endpoint != nil {
		return *m.Endpoint
	}
	return ""
}

func (m *OSSBucket) GetBucket() string {
	if m != nil && m.Bucket != nil {
		return *m.Bucket
	}
	return ""
}

func (m *OSSBucket) GetAccessKeySecret() *v1.SecretKeySelector {
	if m != nil {
		return m.AccessKeySecret
	}
	return nil
}

func (m *OSSBucket) GetSecretKeySecret() *v1.SecretKeySelector {
	if m != nil {
		return m.SecretKeySecret
	}
	return nil
}

// Outputs hold parameters, artifacts, and results from a step
type Outputs struct {
	// Parameters holds the list of output parameters produced by a step
	// +patchStrategy=merge
	// +patchMergeKey=name
	Parameters []*Parameter `protobuf:"bytes,1,rep,name=parameters" json:"parameters,omitempty"`
	// Artifacts holds the list of output artifacts produced by a step
	// +patchStrategy=merge
	// +patchMergeKey=name
	Artifacts []*Artifact `protobuf:"bytes,2,rep,name=artifacts" json:"artifacts,omitempty"`
	// Result holds the result (stdout) of a script template
	Result *string `protobuf:"bytes,3,opt,name=result" json:"result,omitempty"`
	// ExitCode holds the exit code of a script template
	ExitCode             *string  `protobuf:"bytes,4,opt,name=exitCode" json:"exitCode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Outputs) Reset()         { *m = Outputs{} }
func (m *Outputs) String() string { return proto.CompactTextString(m) }
func (*Outputs) ProtoMessage()    {}
func (*Outputs) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{49}
}
func (m *Outputs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Outputs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Outputs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Outputs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Outputs.Merge(m, src)
}
func (m *Outputs) XXX_Size() int {
	return m.Size()
}
func (m *Outputs) XXX_DiscardUnknown() {
	xxx_messageInfo_Outputs.DiscardUnknown(m)
}

var xxx_messageInfo_Outputs proto.InternalMessageInfo

func (m *Outputs) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Outputs) GetArtifacts() []*Artifact {
	if m != nil {
		return m.Artifacts
	}
	return nil
}

func (m *Outputs) GetResult() string {
	if m != nil && m.Result != nil {
		return *m.Result
	}
	return ""
}

func (m *Outputs) GetExitCode() string {
	if m != nil && m.ExitCode != nil {
		return *m.ExitCode
	}
	return ""
}

// +kubebuilder:validation:Type=array
type ParallelSteps struct {
	Steps                []*WorkflowStep `protobuf:"bytes,1,rep,name=steps" json:"steps,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ParallelSteps) Reset()         { *m = ParallelSteps{} }
func (m *ParallelSteps) String() string { return proto.CompactTextString(m) }
func (*ParallelSteps) ProtoMessage()    {}
func (*ParallelSteps) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{50}
}
func (m *ParallelSteps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParallelSteps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParallelSteps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParallelSteps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParallelSteps.Merge(m, src)
}
func (m *ParallelSteps) XXX_Size() int {
	return m.Size()
}
func (m *ParallelSteps) XXX_DiscardUnknown() {
	xxx_messageInfo_ParallelSteps.DiscardUnknown(m)
}

var xxx_messageInfo_ParallelSteps proto.InternalMessageInfo

func (m *ParallelSteps) GetSteps() []*WorkflowStep {
	if m != nil {
		return m.Steps
	}
	return nil
}

// Parameter indicate a passed string parameter to a service template with an optional default value
type Parameter struct {
	// Name is the parameter name
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Default is the default value to use for an input parameter if a value was not supplied
	Default *string `protobuf:"bytes,2,opt,name=default" json:"default,omitempty"`
	// Value is the literal value to use for the parameter.
	// If specified in the context of an input parameter, the value takes precedence over any passed values
	Value *string `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	// ValueFrom is the source for the output parameter's value
	ValueFrom *ValueFrom `protobuf:"bytes,4,opt,name=valueFrom" json:"valueFrom,omitempty"`
	// GlobalName exports an output parameter to the global scope, making it available as
	// '{{workflow.outputs.parameters.XXXX}} and in workflow.status.outputs.parameters
	GlobalName           *string  `protobuf:"bytes,5,opt,name=globalName" json:"globalName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Parameter) Reset()         { *m = Parameter{} }
func (m *Parameter) String() string { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()    {}
func (*Parameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{51}
}
func (m *Parameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Parameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Parameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Parameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Parameter.Merge(m, src)
}
func (m *Parameter) XXX_Size() int {
	return m.Size()
}
func (m *Parameter) XXX_DiscardUnknown() {
	xxx_messageInfo_Parameter.DiscardUnknown(m)
}

var xxx_messageInfo_Parameter proto.InternalMessageInfo

func (m *Parameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Parameter) GetDefault() string {
	if m != nil && m.Default != nil {
		return *m.Default
	}
	return ""
}

func (m *Parameter) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *Parameter) GetValueFrom() *ValueFrom {
	if m != nil {
		return m.ValueFrom
	}
	return nil
}

func (m *Parameter) GetGlobalName() string {
	if m != nil && m.GlobalName != nil {
		return *m.GlobalName
	}
	return ""
}

// PodGC describes how to delete completed pods as they complete
type PodGC struct {
	// Strategy is the strategy to use. One of "OnPodCompletion", "OnPodSuccess", "OnWorkflowCompletion", "OnWorkflowSuccess"
	Strategy             *string  `protobuf:"bytes,1,opt,name=strategy" json:"strategy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PodGC) Reset()         { *m = PodGC{} }
func (m *PodGC) String() string { return proto.CompactTextString(m) }
func (*PodGC) ProtoMessage()    {}
func (*PodGC) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{52}
}
func (m *PodGC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodGC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodGC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodGC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodGC.Merge(m, src)
}
func (m *PodGC) XXX_Size() int {
	return m.Size()
}
func (m *PodGC) XXX_DiscardUnknown() {
	xxx_messageInfo_PodGC.DiscardUnknown(m)
}

var xxx_messageInfo_PodGC proto.InternalMessageInfo

func (m *PodGC) GetStrategy() string {
	if m != nil && m.Strategy != nil {
		return *m.Strategy
	}
	return ""
}

// Prometheus is a prometheus metric to be emitted
type Prometheus struct {
	// Name is the name of the metric
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Labels is a list of metric labels
	Labels []*MetricLabel `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty"`
	// Help is a string that describes the metric
	Help *string `protobuf:"bytes,3,opt,name=help" json:"help,omitempty"`
	// When is a conditional statement that decides when to emit the metric
	When *string `protobuf:"bytes,4,opt,name=when" json:"when,omitempty"`
	// Gauge is a gauge metric
	Gauge *Gauge `protobuf:"bytes,5,opt,name=gauge" json:"gauge,omitempty"`
	// Histogram is a histogram metric
	Histogram *Histogram `protobuf:"bytes,6,opt,name=histogram" json:"histogram,omitempty"`
	// Counter is a counter metric
	Counter              *Counter `protobuf:"bytes,7,opt,name=counter" json:"counter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Prometheus) Reset()         { *m = Prometheus{} }
func (m *Prometheus) String() string { return proto.CompactTextString(m) }
func (*Prometheus) ProtoMessage()    {}
func (*Prometheus) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{53}
}
func (m *Prometheus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Prometheus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Prometheus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Prometheus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Prometheus.Merge(m, src)
}
func (m *Prometheus) XXX_Size() int {
	return m.Size()
}
func (m *Prometheus) XXX_DiscardUnknown() {
	xxx_messageInfo_Prometheus.DiscardUnknown(m)
}

var xxx_messageInfo_Prometheus proto.InternalMessageInfo

func (m *Prometheus) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Prometheus) GetLabels() []*MetricLabel {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Prometheus) GetHelp() string {
	if m != nil && m.Help != nil {
		return *m.Help
	}
	return ""
}

func (m *Prometheus) GetWhen() string {
	if m != nil && m.When != nil {
		return *m.When
	}
	return ""
}

func (m *Prometheus) GetGauge() *Gauge {
	if m != nil {
		return m.Gauge
	}
	return nil
}

func (m *Prometheus) GetHistogram() *Histogram {
	if m != nil {
		return m.Histogram
	}
	return nil
}

func (m *Prometheus) GetCounter() *Counter {
	if m != nil {
		return m.Counter
	}
	return nil
}

// RawArtifact allows raw string content to be placed as an artifact in a container
type RawArtifact struct {
	// Data is the string contents of the artifact
	Data                 *string  `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RawArtifact) Reset()         { *m = RawArtifact{} }
func (m *RawArtifact) String() string { return proto.CompactTextString(m) }
func (*RawArtifact) ProtoMessage()    {}
func (*RawArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{54}
}
func (m *RawArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawArtifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawArtifact.Merge(m, src)
}
func (m *RawArtifact) XXX_Size() int {
	return m.Size()
}
func (m *RawArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_RawArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_RawArtifact proto.InternalMessageInfo

func (m *RawArtifact) GetData() string {
	if m != nil && m.Data != nil {
		return *m.Data
	}
	return ""
}

// ResourceTemplate is a template subtype to manipulate kubernetes resources
type ResourceTemplate struct {
	// Action is the action to perform to the resource.
	// Must be one of: get, create, apply, delete, replace, patch
	Action *string `protobuf:"bytes,1,opt,name=action" json:"action,omitempty"`
	// MergeStrategy is the strategy used to merge a patch. It defaults to "strategic"
	// Must be one of: strategic, merge, json
	MergeStrategy *string `protobuf:"bytes,2,opt,name=mergeStrategy" json:"mergeStrategy,omitempty"`
	// Manifest contains the kubernetes manifest
	Manifest *string `protobuf:"bytes,3,opt,name=manifest" json:"manifest,omitempty"`
	// SetOwnerReference sets the reference to the workflow on the OwnerReference of generated resource.
	SetOwnerReference *bool `protobuf:"varint,4,opt,name=setOwnerReference" json:"setOwnerReference,omitempty"`
	// SuccessCondition is a label selector expression which describes the conditions
	// of the k8s resource in which it is acceptable to proceed to the following step
	SuccessCondition *string `protobuf:"bytes,5,opt,name=successCondition" json:"successCondition,omitempty"`
	// FailureCondition is a label selector expression which describes the conditions
	// of the k8s resource in which the step was considered failed
	FailureCondition *string `protobuf:"bytes,6,opt,name=failureCondition" json:"failureCondition,omitempty"`
	// Flags is a set of additional options passed to kubectl before submitting a resource
	// I.e. to disable resource validation:
	// flags: [
	// 	"--validate=false"  # disable resource validation
	// ]
	Flags                []string `protobuf:"bytes,7,rep,name=flags" json:"flags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceTemplate) Reset()         { *m = ResourceTemplate{} }
func (m *ResourceTemplate) String() string { return proto.CompactTextString(m) }
func (*ResourceTemplate) ProtoMessage()    {}
func (*ResourceTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{55}
}
func (m *ResourceTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceTemplate.Merge(m, src)
}
func (m *ResourceTemplate) XXX_Size() int {
	return m.Size()
}
func (m *ResourceTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceTemplate proto.InternalMessageInfo

func (m *ResourceTemplate) GetAction() string {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return ""
}

func (m *ResourceTemplate) GetMergeStrategy() string {
	if m != nil && m.MergeStrategy != nil {
		return *m.MergeStrategy
	}
	return ""
}

func (m *ResourceTemplate) GetManifest() string {
	if m != nil && m.Manifest != nil {
		return *m.Manifest
	}
	return ""
}

func (m *ResourceTemplate) GetSetOwnerReference() bool {
	if m != nil && m.SetOwnerReference != nil {
		return *m.SetOwnerReference
	}
	return false
}

func (m *ResourceTemplate) GetSuccessCondition() string {
	if m != nil && m.SuccessCondition != nil {
		return *m.SuccessCondition
	}
	return ""
}

func (m *ResourceTemplate) GetFailureCondition() string {
	if m != nil && m.FailureCondition != nil {
		return *m.FailureCondition
	}
	return ""
}

func (m *ResourceTemplate) GetFlags() []string {
	if m != nil {
		return m.Flags
	}
	return nil
}

// RetryStrategy provides controls on how to retry a workflow step
type RetryStrategy struct {
	// Limit is the maximum number of attempts when retrying a container
	Limit *intstr.IntOrString `protobuf:"bytes,1,opt,name=limit" json:"limit,omitempty"`
	// RetryPolicy is a policy of NodePhase statuses that will be retried
	RetryPolicy *string `protobuf:"bytes,2,opt,name=retryPolicy" json:"retryPolicy,omitempty"`
	// Backoff is a backoff strategy
	Backoff              *Backoff `protobuf:"bytes,3,opt,name=backoff" json:"backoff,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RetryStrategy) Reset()         { *m = RetryStrategy{} }
func (m *RetryStrategy) String() string { return proto.CompactTextString(m) }
func (*RetryStrategy) ProtoMessage()    {}
func (*RetryStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{56}
}
func (m *RetryStrategy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetryStrategy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetryStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryStrategy.Merge(m, src)
}
func (m *RetryStrategy) XXX_Size() int {
	return m.Size()
}
func (m *RetryStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_RetryStrategy proto.InternalMessageInfo

func (m *RetryStrategy) GetLimit() *intstr.IntOrString {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *RetryStrategy) GetRetryPolicy() string {
	if m != nil && m.RetryPolicy != nil {
		return *m.RetryPolicy
	}
	return ""
}

func (m *RetryStrategy) GetBackoff() *Backoff {
	if m != nil {
		return m.Backoff
	}
	return nil
}

// S3Artifact is the location of an S3 artifact
type S3Artifact struct {
	S3Bucket *S3Bucket `protobuf:"bytes,1,opt,name=s3Bucket" json:"s3Bucket,omitempty"`
	// Key is the key in the bucket where the artifact resides
	Key                  *string  `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S3Artifact) Reset()         { *m = S3Artifact{} }
func (m *S3Artifact) String() string { return proto.CompactTextString(m) }
func (*S3Artifact) ProtoMessage()    {}
func (*S3Artifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{57}
}
func (m *S3Artifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S3Artifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S3Artifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S3Artifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S3Artifact.Merge(m, src)
}
func (m *S3Artifact) XXX_Size() int {
	return m.Size()
}
func (m *S3Artifact) XXX_DiscardUnknown() {
	xxx_messageInfo_S3Artifact.DiscardUnknown(m)
}

var xxx_messageInfo_S3Artifact proto.InternalMessageInfo

func (m *S3Artifact) GetS3Bucket() *S3Bucket {
	if m != nil {
		return m.S3Bucket
	}
	return nil
}

func (m *S3Artifact) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

// S3Bucket contains the access information required for interfacing with an S3 bucket
type S3Bucket struct {
	// Endpoint is the hostname of the bucket endpoint
	Endpoint *string `protobuf:"bytes,1,opt,name=endpoint" json:"endpoint,omitempty"`
	// Bucket is the name of the bucket
	Bucket *string `protobuf:"bytes,2,opt,name=bucket" json:"bucket,omitempty"`
	// Region contains the optional bucket region
	Region *string `protobuf:"bytes,3,opt,name=region" json:"region,omitempty"`
	// Insecure will connect to the service with TLS
	Insecure *bool `protobuf:"varint,4,opt,name=insecure" json:"insecure,omitempty"`
	// AccessKeySecret is the secret selector to the bucket's access key
	AccessKeySecret *v1.SecretKeySelector `protobuf:"bytes,5,opt,name=accessKeySecret" json:"accessKeySecret,omitempty"`
	// SecretKeySecret is the secret selector to the bucket's secret key
	SecretKeySecret *v1.SecretKeySelector `protobuf:"bytes,6,opt,name=secretKeySecret" json:"secretKeySecret,omitempty"`
	// RoleARN is the Amazon Resource Name (ARN) of the role to assume.
	RoleARN *string `protobuf:"bytes,7,opt,name=roleARN" json:"roleARN,omitempty"`
	// UseSDKCreds tells the driver to figure out credentials based on sdk defaults.
	UseSDKCreds          *bool    `protobuf:"varint,8,opt,name=useSDKCreds" json:"useSDKCreds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S3Bucket) Reset()         { *m = S3Bucket{} }
func (m *S3Bucket) String() string { return proto.CompactTextString(m) }
func (*S3Bucket) ProtoMessage()    {}
func (*S3Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{58}
}
func (m *S3Bucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S3Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S3Bucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S3Bucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S3Bucket.Merge(m, src)
}
func (m *S3Bucket) XXX_Size() int {
	return m.Size()
}
func (m *S3Bucket) XXX_DiscardUnknown() {
	xxx_messageInfo_S3Bucket.DiscardUnknown(m)
}

var xxx_messageInfo_S3Bucket proto.InternalMessageInfo

func (m *S3Bucket) GetEndpoint() string {
	if m != nil && m.Endpoint != nil {
		return *m.Endpoint
	}
	return ""
}

func (m *S3Bucket) GetBucket() string {
	if m != nil && m.Bucket != nil {
		return *m.Bucket
	}
	return ""
}

func (m *S3Bucket) GetRegion() string {
	if m != nil && m.Region != nil {
		return *m.Region
	}
	return ""
}

func (m *S3Bucket) GetInsecure() bool {
	if m != nil && m.Insecure != nil {
		return *m.Insecure
	}
	return false
}

func (m *S3Bucket) GetAccessKeySecret() *v1.SecretKeySelector {
	if m != nil {
		return m.AccessKeySecret
	}
	return nil
}

func (m *S3Bucket) GetSecretKeySecret() *v1.SecretKeySelector {
	if m != nil {
		return m.SecretKeySecret
	}
	return nil
}

func (m *S3Bucket) GetRoleARN() string {
	if m != nil && m.RoleARN != nil {
		return *m.RoleARN
	}
	return ""
}

func (m *S3Bucket) GetUseSDKCreds() bool {
	if m != nil && m.UseSDKCreds != nil {
		return *m.UseSDKCreds
	}
	return false
}

// ScriptTemplate is a template subtype to enable scripting through code steps
type ScriptTemplate struct {
	Container *v1.Container `protobuf:"bytes,1,opt,name=container" json:"container,omitempty"`
	// Source contains the source code of the script to execute
	Source               *string  `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScriptTemplate) Reset()         { *m = ScriptTemplate{} }
func (m *ScriptTemplate) String() string { return proto.CompactTextString(m) }
func (*ScriptTemplate) ProtoMessage()    {}
func (*ScriptTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{59}
}
func (m *ScriptTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScriptTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScriptTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScriptTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScriptTemplate.Merge(m, src)
}
func (m *ScriptTemplate) XXX_Size() int {
	return m.Size()
}
func (m *ScriptTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_ScriptTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_ScriptTemplate proto.InternalMessageInfo

func (m *ScriptTemplate) GetContainer() *v1.Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *ScriptTemplate) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

type SemaphoreHolding struct {
	// Semaphore stores the semaphore name.
	Semaphore *string `protobuf:"bytes,1,opt,name=semaphore" json:"semaphore,omitempty"`
	// Holders stores the list of current holder names in the workflow.
	// +listType=atomic
	Holders              []string `protobuf:"bytes,2,rep,name=holders" json:"holders,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SemaphoreHolding) Reset()         { *m = SemaphoreHolding{} }
func (m *SemaphoreHolding) String() string { return proto.CompactTextString(m) }
func (*SemaphoreHolding) ProtoMessage()    {}
func (*SemaphoreHolding) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{60}
}
func (m *SemaphoreHolding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SemaphoreHolding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SemaphoreHolding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SemaphoreHolding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SemaphoreHolding.Merge(m, src)
}
func (m *SemaphoreHolding) XXX_Size() int {
	return m.Size()
}
func (m *SemaphoreHolding) XXX_DiscardUnknown() {
	xxx_messageInfo_SemaphoreHolding.DiscardUnknown(m)
}

var xxx_messageInfo_SemaphoreHolding proto.InternalMessageInfo

func (m *SemaphoreHolding) GetSemaphore() string {
	if m != nil && m.Semaphore != nil {
		return *m.Semaphore
	}
	return ""
}

func (m *SemaphoreHolding) GetHolders() []string {
	if m != nil {
		return m.Holders
	}
	return nil
}

// SemaphoreRef is a reference of Semaphore
type SemaphoreRef struct {
	// ConfigMapKeyRef is configmap selector for Semaphore configuration
	ConfigMapKeyRef      *v1.ConfigMapKeySelector `protobuf:"bytes,1,opt,name=configMapKeyRef" json:"configMapKeyRef,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *SemaphoreRef) Reset()         { *m = SemaphoreRef{} }
func (m *SemaphoreRef) String() string { return proto.CompactTextString(m) }
func (*SemaphoreRef) ProtoMessage()    {}
func (*SemaphoreRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{61}
}
func (m *SemaphoreRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SemaphoreRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SemaphoreRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SemaphoreRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SemaphoreRef.Merge(m, src)
}
func (m *SemaphoreRef) XXX_Size() int {
	return m.Size()
}
func (m *SemaphoreRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SemaphoreRef.DiscardUnknown(m)
}

var xxx_messageInfo_SemaphoreRef proto.InternalMessageInfo

func (m *SemaphoreRef) GetConfigMapKeyRef() *v1.ConfigMapKeySelector {
	if m != nil {
		return m.ConfigMapKeyRef
	}
	return nil
}

type SemaphoreStatus struct {
	// Holding stores the list of resource acquired synchronization lock for workflows.
	Holding []*SemaphoreHolding `protobuf:"bytes,1,rep,name=holding" json:"holding,omitempty"`
	// Waiting indicates the list of current synchronization lock holders.
	Waiting              []*SemaphoreHolding `protobuf:"bytes,2,rep,name=waiting" json:"waiting,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SemaphoreStatus) Reset()         { *m = SemaphoreStatus{} }
func (m *SemaphoreStatus) String() string { return proto.CompactTextString(m) }
func (*SemaphoreStatus) ProtoMessage()    {}
func (*SemaphoreStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{62}
}
func (m *SemaphoreStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SemaphoreStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SemaphoreStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SemaphoreStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SemaphoreStatus.Merge(m, src)
}
func (m *SemaphoreStatus) XXX_Size() int {
	return m.Size()
}
func (m *SemaphoreStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SemaphoreStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SemaphoreStatus proto.InternalMessageInfo

func (m *SemaphoreStatus) GetHolding() []*SemaphoreHolding {
	if m != nil {
		return m.Holding
	}
	return nil
}

func (m *SemaphoreStatus) GetWaiting() []*SemaphoreHolding {
	if m != nil {
		return m.Waiting
	}
	return nil
}

// Sequence expands a workflow step into numeric range
type Sequence struct {
	// Count is number of elements in the sequence (default: 0). Not to be used with end
	Count *intstr.IntOrString `protobuf:"bytes,1,opt,name=count" json:"count,omitempty"`
	// Number at which to start the sequence (default: 0)
	Start *intstr.IntOrString `protobuf:"bytes,2,opt,name=start" json:"start,omitempty"`
	// Number at which to end the sequence (default: 0). Not to be used with Count
	End *intstr.IntOrString `protobuf:"bytes,3,opt,name=end" json:"end,omitempty"`
	// Format is a printf format string to format the value in the sequence
	Format               *string  `protobuf:"bytes,4,opt,name=format" json:"format,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Sequence) Reset()         { *m = Sequence{} }
func (m *Sequence) String() string { return proto.CompactTextString(m) }
func (*Sequence) ProtoMessage()    {}
func (*Sequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{63}
}
func (m *Sequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sequence.Merge(m, src)
}
func (m *Sequence) XXX_Size() int {
	return m.Size()
}
func (m *Sequence) XXX_DiscardUnknown() {
	xxx_messageInfo_Sequence.DiscardUnknown(m)
}

var xxx_messageInfo_Sequence proto.InternalMessageInfo

func (m *Sequence) GetCount() *intstr.IntOrString {
	if m != nil {
		return m.Count
	}
	return nil
}

func (m *Sequence) GetStart() *intstr.IntOrString {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Sequence) GetEnd() *intstr.IntOrString {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *Sequence) GetFormat() string {
	if m != nil && m.Format != nil {
		return *m.Format
	}
	return ""
}

type Submit struct {
	// WorkflowTemplateRef the workflow template to submit
	WorkflowTemplateRef *WorkflowTemplateRef `protobuf:"bytes,1,opt,name=workflowTemplateRef" json:"workflowTemplateRef,omitempty"`
	// Arguments extracted from the event and then set as arguments to the workflow created.
	Arguments            *Arguments `protobuf:"bytes,2,opt,name=arguments" json:"arguments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Submit) Reset()         { *m = Submit{} }
func (m *Submit) String() string { return proto.CompactTextString(m) }
func (*Submit) ProtoMessage()    {}
func (*Submit) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{64}
}
func (m *Submit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Submit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Submit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Submit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Submit.Merge(m, src)
}
func (m *Submit) XXX_Size() int {
	return m.Size()
}
func (m *Submit) XXX_DiscardUnknown() {
	xxx_messageInfo_Submit.DiscardUnknown(m)
}

var xxx_messageInfo_Submit proto.InternalMessageInfo

func (m *Submit) GetWorkflowTemplateRef() *WorkflowTemplateRef {
	if m != nil {
		return m.WorkflowTemplateRef
	}
	return nil
}

func (m *Submit) GetArguments() *Arguments {
	if m != nil {
		return m.Arguments
	}
	return nil
}

// SubmitOpts are workflow submission options
type SubmitOpts struct {
	// Name overrides metadata.name
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// GenerateName overrides metadata.generateName
	GenerateName *string `protobuf:"bytes,2,opt,name=generateName" json:"generateName,omitempty"`
	// Entrypoint overrides spec.entrypoint
	Entrypoint *string `protobuf:"bytes,4,opt,name=entrypoint" json:"entrypoint,omitempty"`
	// Parameters passes input parameters to workflow
	Parameters []string `protobuf:"bytes,5,rep,name=parameters" json:"parameters,omitempty"`
	// ParameterFile holds a reference to a parameter file. This option is not supported in API
	ParameterFile *string `protobuf:"bytes,6,opt,name=parameterFile" json:"parameterFile,omitempty"`
	// ServiceAccount runs all pods in the workflow using specified ServiceAccount.
	ServiceAccount *string `protobuf:"bytes,7,opt,name=serviceAccount" json:"serviceAccount,omitempty"`
	// DryRun validates the workflow on the client-side without creating it. This option is not supported in API
	DryRun *bool `protobuf:"varint,8,opt,name=dryRun" json:"dryRun,omitempty"`
	// ServerDryRun validates the workflow on the server-side without creating it
	ServerDryRun *bool `protobuf:"varint,9,opt,name=serverDryRun" json:"serverDryRun,omitempty"`
	// Labels adds to metadata.labels
	Labels *string `protobuf:"bytes,10,opt,name=labels" json:"labels,omitempty"`
	// OwnerReference creates a metadata.ownerReference
	OwnerReference       *v11.OwnerReference `protobuf:"bytes,11,opt,name=ownerReference" json:"ownerReference,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SubmitOpts) Reset()         { *m = SubmitOpts{} }
func (m *SubmitOpts) String() string { return proto.CompactTextString(m) }
func (*SubmitOpts) ProtoMessage()    {}
func (*SubmitOpts) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{65}
}
func (m *SubmitOpts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitOpts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitOpts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitOpts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitOpts.Merge(m, src)
}
func (m *SubmitOpts) XXX_Size() int {
	return m.Size()
}
func (m *SubmitOpts) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitOpts.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitOpts proto.InternalMessageInfo

func (m *SubmitOpts) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *SubmitOpts) GetGenerateName() string {
	if m != nil && m.GenerateName != nil {
		return *m.GenerateName
	}
	return ""
}

func (m *SubmitOpts) GetEntrypoint() string {
	if m != nil && m.Entrypoint != nil {
		return *m.Entrypoint
	}
	return ""
}

func (m *SubmitOpts) GetParameters() []string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *SubmitOpts) GetParameterFile() string {
	if m != nil && m.ParameterFile != nil {
		return *m.ParameterFile
	}
	return ""
}

func (m *SubmitOpts) GetServiceAccount() string {
	if m != nil && m.ServiceAccount != nil {
		return *m.ServiceAccount
	}
	return ""
}

func (m *SubmitOpts) GetDryRun() bool {
	if m != nil && m.DryRun != nil {
		return *m.DryRun
	}
	return false
}

func (m *SubmitOpts) GetServerDryRun() bool {
	if m != nil && m.ServerDryRun != nil {
		return *m.ServerDryRun
	}
	return false
}

func (m *SubmitOpts) GetLabels() string {
	if m != nil && m.Labels != nil {
		return *m.Labels
	}
	return ""
}

func (m *SubmitOpts) GetOwnerReference() *v11.OwnerReference {
	if m != nil {
		return m.OwnerReference
	}
	return nil
}

// SuppliedValueFrom is a placeholder for a value to be filled in directly, either through the CLI, API, etc.
type SuppliedValueFrom struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SuppliedValueFrom) Reset()         { *m = SuppliedValueFrom{} }
func (m *SuppliedValueFrom) String() string { return proto.CompactTextString(m) }
func (*SuppliedValueFrom) ProtoMessage()    {}
func (*SuppliedValueFrom) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{66}
}
func (m *SuppliedValueFrom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuppliedValueFrom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuppliedValueFrom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuppliedValueFrom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuppliedValueFrom.Merge(m, src)
}
func (m *SuppliedValueFrom) XXX_Size() int {
	return m.Size()
}
func (m *SuppliedValueFrom) XXX_DiscardUnknown() {
	xxx_messageInfo_SuppliedValueFrom.DiscardUnknown(m)
}

var xxx_messageInfo_SuppliedValueFrom proto.InternalMessageInfo

// SuspendTemplate is a template subtype to suspend a workflow at a predetermined point in time
type SuspendTemplate struct {
	// Duration is the seconds to wait before automatically resuming a template
	Duration             *string  `protobuf:"bytes,1,opt,name=duration" json:"duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SuspendTemplate) Reset()         { *m = SuspendTemplate{} }
func (m *SuspendTemplate) String() string { return proto.CompactTextString(m) }
func (*SuspendTemplate) ProtoMessage()    {}
func (*SuspendTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{67}
}
func (m *SuspendTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuspendTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuspendTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuspendTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuspendTemplate.Merge(m, src)
}
func (m *SuspendTemplate) XXX_Size() int {
	return m.Size()
}
func (m *SuspendTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_SuspendTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_SuspendTemplate proto.InternalMessageInfo

func (m *SuspendTemplate) GetDuration() string {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return ""
}

// Synchronization holds synchronization lock configuration
type Synchronization struct {
	// Semaphore holds the Semaphore configuration
	Semaphore *SemaphoreRef `protobuf:"bytes,1,opt,name=semaphore" json:"semaphore,omitempty"`
	// Mutex holds the Mutex lock details
	Mutex                *Mutex   `protobuf:"bytes,2,opt,name=mutex" json:"mutex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Synchronization) Reset()         { *m = Synchronization{} }
func (m *Synchronization) String() string { return proto.CompactTextString(m) }
func (*Synchronization) ProtoMessage()    {}
func (*Synchronization) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{68}
}
func (m *Synchronization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Synchronization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Synchronization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Synchronization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Synchronization.Merge(m, src)
}
func (m *Synchronization) XXX_Size() int {
	return m.Size()
}
func (m *Synchronization) XXX_DiscardUnknown() {
	xxx_messageInfo_Synchronization.DiscardUnknown(m)
}

var xxx_messageInfo_Synchronization proto.InternalMessageInfo

func (m *Synchronization) GetSemaphore() *SemaphoreRef {
	if m != nil {
		return m.Semaphore
	}
	return nil
}

func (m *Synchronization) GetMutex() *Mutex {
	if m != nil {
		return m.Mutex
	}
	return nil
}

// SynchronizationStatus stores the status of semaphore and mutex.
type SynchronizationStatus struct {
	// Semaphore stores this workflow's Semaphore holder details
	Semaphore *SemaphoreStatus `protobuf:"bytes,1,opt,name=semaphore" json:"semaphore,omitempty"`
	// Mutex stores this workflow's mutex holder details
	Mutex                *MutexStatus `protobuf:"bytes,2,opt,name=mutex" json:"mutex,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SynchronizationStatus) Reset()         { *m = SynchronizationStatus{} }
func (m *SynchronizationStatus) String() string { return proto.CompactTextString(m) }
func (*SynchronizationStatus) ProtoMessage()    {}
func (*SynchronizationStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{69}
}
func (m *SynchronizationStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SynchronizationStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SynchronizationStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SynchronizationStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SynchronizationStatus.Merge(m, src)
}
func (m *SynchronizationStatus) XXX_Size() int {
	return m.Size()
}
func (m *SynchronizationStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SynchronizationStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SynchronizationStatus proto.InternalMessageInfo

func (m *SynchronizationStatus) GetSemaphore() *SemaphoreStatus {
	if m != nil {
		return m.Semaphore
	}
	return nil
}

func (m *SynchronizationStatus) GetMutex() *MutexStatus {
	if m != nil {
		return m.Mutex
	}
	return nil
}

// TTLStrategy is the strategy for the time to live depending on if the workflow succeeded or failed
type TTLStrategy struct {
	// SecondsAfterCompletion is the number of seconds to live after completion
	SecondsAfterCompletion *int32 `protobuf:"varint,1,opt,name=secondsAfterCompletion" json:"secondsAfterCompletion,omitempty"`
	// SecondsAfterSuccess is the number of seconds to live after success
	SecondsAfterSuccess *int32 `protobuf:"varint,2,opt,name=secondsAfterSuccess" json:"secondsAfterSuccess,omitempty"`
	// SecondsAfterFailure is the number of seconds to live after failure
	SecondsAfterFailure  *int32   `protobuf:"varint,3,opt,name=secondsAfterFailure" json:"secondsAfterFailure,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TTLStrategy) Reset()         { *m = TTLStrategy{} }
func (m *TTLStrategy) String() string { return proto.CompactTextString(m) }
func (*TTLStrategy) ProtoMessage()    {}
func (*TTLStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{70}
}
func (m *TTLStrategy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TTLStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TTLStrategy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TTLStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TTLStrategy.Merge(m, src)
}
func (m *TTLStrategy) XXX_Size() int {
	return m.Size()
}
func (m *TTLStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_TTLStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_TTLStrategy proto.InternalMessageInfo

func (m *TTLStrategy) GetSecondsAfterCompletion() int32 {
	if m != nil && m.SecondsAfterCompletion != nil {
		return *m.SecondsAfterCompletion
	}
	return 0
}

func (m *TTLStrategy) GetSecondsAfterSuccess() int32 {
	if m != nil && m.SecondsAfterSuccess != nil {
		return *m.SecondsAfterSuccess
	}
	return 0
}

func (m *TTLStrategy) GetSecondsAfterFailure() int32 {
	if m != nil && m.SecondsAfterFailure != nil {
		return *m.SecondsAfterFailure
	}
	return 0
}

// TarStrategy will tar and gzip the file or directory when saving
type TarStrategy struct {
	// CompressionLevel specifies the gzip compression level to use for the artifact.
	// Defaults to gzip.DefaultCompression.
	CompressionLevel     *int32   `protobuf:"varint,1,opt,name=compressionLevel" json:"compressionLevel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TarStrategy) Reset()         { *m = TarStrategy{} }
func (m *TarStrategy) String() string { return proto.CompactTextString(m) }
func (*TarStrategy) ProtoMessage()    {}
func (*TarStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{71}
}
func (m *TarStrategy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TarStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TarStrategy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TarStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TarStrategy.Merge(m, src)
}
func (m *TarStrategy) XXX_Size() int {
	return m.Size()
}
func (m *TarStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_TarStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_TarStrategy proto.InternalMessageInfo

func (m *TarStrategy) GetCompressionLevel() int32 {
	if m != nil && m.CompressionLevel != nil {
		return *m.CompressionLevel
	}
	return 0
}

// Template is a reusable and composable unit of execution in a workflow
type Template struct {
	// Name is the name of the template
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Template is the name of the template which is used as the base of this template.
	// DEPRECATED: This field is not used.
	Template *string `protobuf:"bytes,2,opt,name=template" json:"template,omitempty"`
	// Arguments hold arguments to the template.
	// DEPRECATED: This field is not used.
	Arguments *Arguments `protobuf:"bytes,3,opt,name=arguments" json:"arguments,omitempty"`
	// TemplateRef is the reference to the template resource which is used as the base of this template.
	// DEPRECATED: This field is not used.
	TemplateRef *TemplateRef `protobuf:"bytes,4,opt,name=templateRef" json:"templateRef,omitempty"`
	// Inputs describe what inputs parameters and artifacts are supplied to this template
	Inputs *Inputs `protobuf:"bytes,5,opt,name=inputs" json:"inputs,omitempty"`
	// Outputs describe the parameters and artifacts that this template produces
	Outputs *Outputs `protobuf:"bytes,6,opt,name=outputs" json:"outputs,omitempty"`
	// NodeSelector is a selector to schedule this step of the workflow to be
	// run on the selected node(s). Overrides the selector set at the workflow level.
	NodeSelector map[string]string `protobuf:"bytes,7,rep,name=nodeSelector" json:"nodeSelector,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Affinity sets the pod's scheduling constraints
	// Overrides the affinity set at the workflow level (if any)
	Affinity *v1.Affinity `protobuf:"bytes,8,opt,name=affinity" json:"affinity,omitempty"`
	// Metdata sets the pods's metadata, i.e. annotations and labels
	Metadata *Metadata `protobuf:"bytes,9,opt,name=metadata" json:"metadata,omitempty"`
	// Deamon will allow a workflow to proceed to the next step so long as the container reaches readiness
	Daemon *bool `protobuf:"varint,10,opt,name=daemon" json:"daemon,omitempty"`
	// Steps define a series of sequential/parallel workflow steps
	Steps []*ParallelSteps `protobuf:"bytes,11,rep,name=steps" json:"steps,omitempty"`
	// Container is the main container image to run in the pod
	Container *v1.Container `protobuf:"bytes,12,opt,name=container" json:"container,omitempty"`
	// Script runs a portion of code against an interpreter
	Script *ScriptTemplate `protobuf:"bytes,13,opt,name=script" json:"script,omitempty"`
	// Resource template subtype which can run k8s resources
	Resource *ResourceTemplate `protobuf:"bytes,14,opt,name=resource" json:"resource,omitempty"`
	// DAG template subtype which runs a DAG
	Dag *DAGTemplate `protobuf:"bytes,15,opt,name=dag" json:"dag,omitempty"`
	// Suspend template subtype which can suspend a workflow when reaching the step
	Suspend *SuspendTemplate `protobuf:"bytes,16,opt,name=suspend" json:"suspend,omitempty"`
	// Volumes is a list of volumes that can be mounted by containers in a template.
	// +patchStrategy=merge
	// +patchMergeKey=name
	Volumes []*v1.Volume `protobuf:"bytes,17,rep,name=volumes" json:"volumes,omitempty"`
	// InitContainers is a list of containers which run before the main container.
	// +patchStrategy=merge
	// +patchMergeKey=name
	InitContainers []*UserContainer `protobuf:"bytes,18,rep,name=initContainers" json:"initContainers,omitempty"`
	// Sidecars is a list of containers which run alongside the main container
	// Sidecars are automatically killed when the main container completes
	// +patchStrategy=merge
	// +patchMergeKey=name
	Sidecars []*UserContainer `protobuf:"bytes,19,rep,name=sidecars" json:"sidecars,omitempty"`
	// Location in which all files related to the step will be stored (logs, artifacts, etc...).
	// Can be overridden by individual items in Outputs. If omitted, will use the default
	// artifact repository location configured in the controller, appended with the
	// <workflowname>/<nodename> in the key.
	ArchiveLocation *ArtifactLocation `protobuf:"bytes,20,opt,name=archiveLocation" json:"archiveLocation,omitempty"`
	// Optional duration in seconds relative to the StartTime that the pod may be active on a node
	// before the system actively tries to terminate the pod; value must be positive integer
	// This field is only applicable to container and script templates.
	ActiveDeadlineSeconds *intstr.IntOrString `protobuf:"bytes,21,opt,name=activeDeadlineSeconds" json:"activeDeadlineSeconds,omitempty"`
	// RetryStrategy describes how to retry a template when it fails
	RetryStrategy *RetryStrategy `protobuf:"bytes,22,opt,name=retryStrategy" json:"retryStrategy,omitempty"`
	// Parallelism limits the max total parallel pods that can execute at the same time within the
	// boundaries of this template invocation. If additional steps/dag templates are invoked, the
	// pods created by those templates will not be counted towards this total.
	Parallelism *int64 `protobuf:"varint,23,opt,name=parallelism" json:"parallelism,omitempty"`
	// Tolerations to apply to workflow pods.
	// +patchStrategy=merge
	// +patchMergeKey=key
	Tolerations []*v1.Toleration `protobuf:"bytes,24,rep,name=tolerations" json:"tolerations,omitempty"`
	// If specified, the pod will be dispatched by specified scheduler.
	// Or it will be dispatched by workflow scope scheduler if specified.
	// If neither specified, the pod will be dispatched by default scheduler.
	// +optional
	SchedulerName *string `protobuf:"bytes,25,opt,name=schedulerName" json:"schedulerName,omitempty"`
	// PriorityClassName to apply to workflow pods.
	PriorityClassName *string `protobuf:"bytes,26,opt,name=priorityClassName" json:"priorityClassName,omitempty"`
	// Priority to apply to workflow pods.
	Priority *int32 `protobuf:"varint,27,opt,name=priority" json:"priority,omitempty"`
	// ServiceAccountName to apply to workflow pods
	ServiceAccountName *string `protobuf:"bytes,28,opt,name=serviceAccountName" json:"serviceAccountName,omitempty"`
	// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods.
	// ServiceAccountName of ExecutorConfig must be specified if this value is false.
	AutomountServiceAccountToken *bool `protobuf:"varint,32,opt,name=automountServiceAccountToken" json:"automountServiceAccountToken,omitempty"`
	// Executor holds configurations of the executor container.
	Executor *ExecutorConfig `protobuf:"bytes,33,opt,name=executor" json:"executor,omitempty"`
	// HostAliases is an optional list of hosts and IPs that will be injected into the pod spec
	// +patchStrategy=merge
	// +patchMergeKey=ip
	HostAliases []*v1.HostAlias `protobuf:"bytes,29,rep,name=hostAliases" json:"hostAliases,omitempty"`
	// SecurityContext holds pod-level security attributes and common container settings.
	// Optional: Defaults to empty.  See type description for default values of each field.
	// +optional
	SecurityContext *v1.PodSecurityContext `protobuf:"bytes,30,opt,name=securityContext" json:"securityContext,omitempty"`
	// PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of
	// container fields which are not strings (e.g. resource limits).
	PodSpecPatch *string `protobuf:"bytes,31,opt,name=podSpecPatch" json:"podSpecPatch,omitempty"`
	// Metrics are a list of metrics emitted from this template
	Metrics *Metrics `protobuf:"bytes,35,opt,name=metrics" json:"metrics,omitempty"`
	// Synchronization holds synchronization lock configuration for this template
	Synchronization *Synchronization `protobuf:"bytes,36,opt,name=synchronization" json:"synchronization,omitempty"`
	// Memoize allows templates to use outputs generated from already executed templates
	Memoize *Memoize `protobuf:"bytes,37,opt,name=memoize" json:"memoize,omitempty"`
	// Timout allows to set the total node execution timeout duration counting from the node's start time.
	// This duration also includes time in which the node spends in Pending state. This duration may not be applied to Step or DAG templates.
	Timeout              *string  `protobuf:"bytes,38,opt,name=timeout" json:"timeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Template) Reset()         { *m = Template{} }
func (m *Template) String() string { return proto.CompactTextString(m) }
func (*Template) ProtoMessage()    {}
func (*Template) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{72}
}
func (m *Template) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Template) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Template.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Template) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Template.Merge(m, src)
}
func (m *Template) XXX_Size() int {
	return m.Size()
}
func (m *Template) XXX_DiscardUnknown() {
	xxx_messageInfo_Template.DiscardUnknown(m)
}

var xxx_messageInfo_Template proto.InternalMessageInfo

func (m *Template) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Template) GetTemplate() string {
	if m != nil && m.Template != nil {
		return *m.Template
	}
	return ""
}

func (m *Template) GetArguments() *Arguments {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *Template) GetTemplateRef() *TemplateRef {
	if m != nil {
		return m.TemplateRef
	}
	return nil
}

func (m *Template) GetInputs() *Inputs {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Template) GetOutputs() *Outputs {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *Template) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *Template) GetAffinity() *v1.Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

func (m *Template) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Template) GetDaemon() bool {
	if m != nil && m.Daemon != nil {
		return *m.Daemon
	}
	return false
}

func (m *Template) GetSteps() []*ParallelSteps {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Template) GetContainer() *v1.Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *Template) GetScript() *ScriptTemplate {
	if m != nil {
		return m.Script
	}
	return nil
}

func (m *Template) GetResource() *ResourceTemplate {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *Template) GetDag() *DAGTemplate {
	if m != nil {
		return m.Dag
	}
	return nil
}

func (m *Template) GetSuspend() *SuspendTemplate {
	if m != nil {
		return m.Suspend
	}
	return nil
}

func (m *Template) GetVolumes() []*v1.Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *Template) GetInitContainers() []*UserContainer {
	if m != nil {
		return m.InitContainers
	}
	return nil
}

func (m *Template) GetSidecars() []*UserContainer {
	if m != nil {
		return m.Sidecars
	}
	return nil
}

func (m *Template) GetArchiveLocation() *ArtifactLocation {
	if m != nil {
		return m.ArchiveLocation
	}
	return nil
}

func (m *Template) GetActiveDeadlineSeconds() *intstr.IntOrString {
	if m != nil {
		return m.ActiveDeadlineSeconds
	}
	return nil
}

func (m *Template) GetRetryStrategy() *RetryStrategy {
	if m != nil {
		return m.RetryStrategy
	}
	return nil
}

func (m *Template) GetParallelism() int64 {
	if m != nil && m.Parallelism != nil {
		return *m.Parallelism
	}
	return 0
}

func (m *Template) GetTolerations() []*v1.Toleration {
	if m != nil {
		return m.Tolerations
	}
	return nil
}

func (m *Template) GetSchedulerName() string {
	if m != nil && m.SchedulerName != nil {
		return *m.SchedulerName
	}
	return ""
}

func (m *Template) GetPriorityClassName() string {
	if m != nil && m.PriorityClassName != nil {
		return *m.PriorityClassName
	}
	return ""
}

func (m *Template) GetPriority() int32 {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return 0
}

func (m *Template) GetServiceAccountName() string {
	if m != nil && m.ServiceAccountName != nil {
		return *m.ServiceAccountName
	}
	return ""
}

func (m *Template) GetAutomountServiceAccountToken() bool {
	if m != nil && m.AutomountServiceAccountToken != nil {
		return *m.AutomountServiceAccountToken
	}
	return false
}

func (m *Template) GetExecutor() *ExecutorConfig {
	if m != nil {
		return m.Executor
	}
	return nil
}

func (m *Template) GetHostAliases() []*v1.HostAlias {
	if m != nil {
		return m.HostAliases
	}
	return nil
}

func (m *Template) GetSecurityContext() *v1.PodSecurityContext {
	if m != nil {
		return m.SecurityContext
	}
	return nil
}

func (m *Template) GetPodSpecPatch() string {
	if m != nil && m.PodSpecPatch != nil {
		return *m.PodSpecPatch
	}
	return ""
}

func (m *Template) GetMetrics() *Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Template) GetSynchronization() *Synchronization {
	if m != nil {
		return m.Synchronization
	}
	return nil
}

func (m *Template) GetMemoize() *Memoize {
	if m != nil {
		return m.Memoize
	}
	return nil
}

func (m *Template) GetTimeout() string {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return ""
}

// TemplateRef is a reference of template resource.
type TemplateRef struct {
	// Name is the resource name of the template.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Template is the name of referred template in the resource.
	Template *string `protobuf:"bytes,2,opt,name=template" json:"template,omitempty"`
	// RuntimeResolution skips validation at creation time.
	// By enabling this option, you can create the referred workflow template before the actual runtime.
	// DEPRECATED: This value is not used anymore and is ignored
	RuntimeResolution *bool `protobuf:"varint,3,opt,name=runtimeResolution" json:"runtimeResolution,omitempty"`
	// ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate).
	ClusterScope         *bool    `protobuf:"varint,4,opt,name=clusterScope" json:"clusterScope,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TemplateRef) Reset()         { *m = TemplateRef{} }
func (m *TemplateRef) String() string { return proto.CompactTextString(m) }
func (*TemplateRef) ProtoMessage()    {}
func (*TemplateRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{73}
}
func (m *TemplateRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TemplateRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TemplateRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TemplateRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TemplateRef.Merge(m, src)
}
func (m *TemplateRef) XXX_Size() int {
	return m.Size()
}
func (m *TemplateRef) XXX_DiscardUnknown() {
	xxx_messageInfo_TemplateRef.DiscardUnknown(m)
}

var xxx_messageInfo_TemplateRef proto.InternalMessageInfo

func (m *TemplateRef) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TemplateRef) GetTemplate() string {
	if m != nil && m.Template != nil {
		return *m.Template
	}
	return ""
}

func (m *TemplateRef) GetRuntimeResolution() bool {
	if m != nil && m.RuntimeResolution != nil {
		return *m.RuntimeResolution
	}
	return false
}

func (m *TemplateRef) GetClusterScope() bool {
	if m != nil && m.ClusterScope != nil {
		return *m.ClusterScope
	}
	return false
}

// UserContainer is a container specified by a user.
type UserContainer struct {
	Container *v1.Container `protobuf:"bytes,1,opt,name=container" json:"container,omitempty"`
	// MirrorVolumeMounts will mount the same volumes specified in the main container
	// to the container (including artifacts), at the same mountPaths. This enables
	// dind daemon to partially see the same filesystem as the main container in
	// order to use features such as docker volume binding
	MirrorVolumeMounts   *bool    `protobuf:"varint,2,opt,name=mirrorVolumeMounts" json:"mirrorVolumeMounts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserContainer) Reset()         { *m = UserContainer{} }
func (m *UserContainer) String() string { return proto.CompactTextString(m) }
func (*UserContainer) ProtoMessage()    {}
func (*UserContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{74}
}
func (m *UserContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserContainer.Merge(m, src)
}
func (m *UserContainer) XXX_Size() int {
	return m.Size()
}
func (m *UserContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_UserContainer.DiscardUnknown(m)
}

var xxx_messageInfo_UserContainer proto.InternalMessageInfo

func (m *UserContainer) GetContainer() *v1.Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *UserContainer) GetMirrorVolumeMounts() bool {
	if m != nil && m.MirrorVolumeMounts != nil {
		return *m.MirrorVolumeMounts
	}
	return false
}

// ValueFrom describes a location in which to obtain the value to a parameter
type ValueFrom struct {
	// Path in the container to retrieve an output parameter value from in container templates
	Path *string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// JSONPath of a resource to retrieve an output parameter value from in resource templates
	JsonPath *string `protobuf:"bytes,2,opt,name=jsonPath" json:"jsonPath,omitempty"`
	// JQFilter expression against the resource object in resource templates
	JqFilter *string `protobuf:"bytes,3,opt,name=jqFilter" json:"jqFilter,omitempty"`
	// Selector (https://github.com/antonmedv/expr) that is evaluated against the event to get the value of the parameter. E.g. `payload.message`
	Event *string `protobuf:"bytes,7,opt,name=event" json:"event,omitempty"`
	// Parameter reference to a step or dag task in which to retrieve an output parameter value from
	// (e.g. '{{steps.mystep.outputs.myparam}}')
	Parameter *string `protobuf:"bytes,4,opt,name=parameter" json:"parameter,omitempty"`
	// Supplied value to be filled in directly, either through the CLI, API, etc.
	Supplied *SuppliedValueFrom `protobuf:"bytes,6,opt,name=supplied" json:"supplied,omitempty"`
	// Default specifies a value to be used if retrieving the value from the specified source fails
	Default              *string  `protobuf:"bytes,5,opt,name=default" json:"default,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValueFrom) Reset()         { *m = ValueFrom{} }
func (m *ValueFrom) String() string { return proto.CompactTextString(m) }
func (*ValueFrom) ProtoMessage()    {}
func (*ValueFrom) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{75}
}
func (m *ValueFrom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueFrom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueFrom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueFrom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueFrom.Merge(m, src)
}
func (m *ValueFrom) XXX_Size() int {
	return m.Size()
}
func (m *ValueFrom) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueFrom.DiscardUnknown(m)
}

var xxx_messageInfo_ValueFrom proto.InternalMessageInfo

func (m *ValueFrom) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *ValueFrom) GetJsonPath() string {
	if m != nil && m.JsonPath != nil {
		return *m.JsonPath
	}
	return ""
}

func (m *ValueFrom) GetJqFilter() string {
	if m != nil && m.JqFilter != nil {
		return *m.JqFilter
	}
	return ""
}

func (m *ValueFrom) GetEvent() string {
	if m != nil && m.Event != nil {
		return *m.Event
	}
	return ""
}

func (m *ValueFrom) GetParameter() string {
	if m != nil && m.Parameter != nil {
		return *m.Parameter
	}
	return ""
}

func (m *ValueFrom) GetSupplied() *SuppliedValueFrom {
	if m != nil {
		return m.Supplied
	}
	return nil
}

func (m *ValueFrom) GetDefault() string {
	if m != nil && m.Default != nil {
		return *m.Default
	}
	return ""
}

type Version struct {
	Version              *string  `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	BuildDate            *string  `protobuf:"bytes,2,opt,name=buildDate" json:"buildDate,omitempty"`
	GitCommit            *string  `protobuf:"bytes,3,opt,name=gitCommit" json:"gitCommit,omitempty"`
	GitTag               *string  `protobuf:"bytes,4,opt,name=gitTag" json:"gitTag,omitempty"`
	GitTreeState         *string  `protobuf:"bytes,5,opt,name=gitTreeState" json:"gitTreeState,omitempty"`
	GoVersion            *string  `protobuf:"bytes,6,opt,name=goVersion" json:"goVersion,omitempty"`
	Compiler             *string  `protobuf:"bytes,7,opt,name=compiler" json:"compiler,omitempty"`
	Platform             *string  `protobuf:"bytes,8,opt,name=platform" json:"platform,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{76}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Version.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(m, src)
}
func (m *Version) XXX_Size() int {
	return m.Size()
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *Version) GetBuildDate() string {
	if m != nil && m.BuildDate != nil {
		return *m.BuildDate
	}
	return ""
}

func (m *Version) GetGitCommit() string {
	if m != nil && m.GitCommit != nil {
		return *m.GitCommit
	}
	return ""
}

func (m *Version) GetGitTag() string {
	if m != nil && m.GitTag != nil {
		return *m.GitTag
	}
	return ""
}

func (m *Version) GetGitTreeState() string {
	if m != nil && m.GitTreeState != nil {
		return *m.GitTreeState
	}
	return ""
}

func (m *Version) GetGoVersion() string {
	if m != nil && m.GoVersion != nil {
		return *m.GoVersion
	}
	return ""
}

func (m *Version) GetCompiler() string {
	if m != nil && m.Compiler != nil {
		return *m.Compiler
	}
	return ""
}

func (m *Version) GetPlatform() string {
	if m != nil && m.Platform != nil {
		return *m.Platform
	}
	return ""
}

// VolumeClaimGC describes how to delete volumes from completed Workflows
type VolumeClaimGC struct {
	// Strategy is the strategy to use. One of "OnWorkflowCompletion", "OnWorkflowSuccess"
	Strategy             *string  `protobuf:"bytes,1,opt,name=strategy" json:"strategy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeClaimGC) Reset()         { *m = VolumeClaimGC{} }
func (m *VolumeClaimGC) String() string { return proto.CompactTextString(m) }
func (*VolumeClaimGC) ProtoMessage()    {}
func (*VolumeClaimGC) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{77}
}
func (m *VolumeClaimGC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolumeClaimGC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VolumeClaimGC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VolumeClaimGC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeClaimGC.Merge(m, src)
}
func (m *VolumeClaimGC) XXX_Size() int {
	return m.Size()
}
func (m *VolumeClaimGC) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeClaimGC.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeClaimGC proto.InternalMessageInfo

func (m *VolumeClaimGC) GetStrategy() string {
	if m != nil && m.Strategy != nil {
		return *m.Strategy
	}
	return ""
}

// Workflow is the definition of a workflow resource
// +genclient
// +genclient:noStatus
// +kubebuilder:resource:shortName=wf
// +kubebuilder:printcolumn:name="Status",type="string",JSONPath=".status.phase",description="Status of the workflow"
// +kubebuilder:printcolumn:name="Age",type="date",format="date-time",JSONPath=".status.startedAt",description="When the workflow was started"
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type Workflow struct {
	Metadata             *v11.ObjectMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec                 *WorkflowSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status               *WorkflowStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Workflow) Reset()         { *m = Workflow{} }
func (m *Workflow) String() string { return proto.CompactTextString(m) }
func (*Workflow) ProtoMessage()    {}
func (*Workflow) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{78}
}
func (m *Workflow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Workflow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Workflow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Workflow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Workflow.Merge(m, src)
}
func (m *Workflow) XXX_Size() int {
	return m.Size()
}
func (m *Workflow) XXX_DiscardUnknown() {
	xxx_messageInfo_Workflow.DiscardUnknown(m)
}

var xxx_messageInfo_Workflow proto.InternalMessageInfo

func (m *Workflow) GetMetadata() *v11.ObjectMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Workflow) GetSpec() *WorkflowSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Workflow) GetStatus() *WorkflowStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// WorkflowEventBinding is the definition of an event resource
// +genclient
// +genclient:noStatus
// +kubebuilder:resource:shortName=wfeb
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type WorkflowEventBinding struct {
	Metadata             *v11.ObjectMeta           `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec                 *WorkflowEventBindingSpec `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *WorkflowEventBinding) Reset()         { *m = WorkflowEventBinding{} }
func (m *WorkflowEventBinding) String() string { return proto.CompactTextString(m) }
func (*WorkflowEventBinding) ProtoMessage()    {}
func (*WorkflowEventBinding) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{79}
}
func (m *WorkflowEventBinding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowEventBinding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowEventBinding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowEventBinding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowEventBinding.Merge(m, src)
}
func (m *WorkflowEventBinding) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowEventBinding) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowEventBinding.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowEventBinding proto.InternalMessageInfo

func (m *WorkflowEventBinding) GetMetadata() *v11.ObjectMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *WorkflowEventBinding) GetSpec() *WorkflowEventBindingSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// WorkflowEventBindingList is list of event resources
// +kubebuilder:resource:shortName=wfebs
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type WorkflowEventBindingList struct {
	Metadata             *v11.ListMeta           `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Items                []*WorkflowEventBinding `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *WorkflowEventBindingList) Reset()         { *m = WorkflowEventBindingList{} }
func (m *WorkflowEventBindingList) String() string { return proto.CompactTextString(m) }
func (*WorkflowEventBindingList) ProtoMessage()    {}
func (*WorkflowEventBindingList) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{80}
}
func (m *WorkflowEventBindingList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowEventBindingList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowEventBindingList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowEventBindingList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowEventBindingList.Merge(m, src)
}
func (m *WorkflowEventBindingList) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowEventBindingList) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowEventBindingList.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowEventBindingList proto.InternalMessageInfo

func (m *WorkflowEventBindingList) GetMetadata() *v11.ListMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *WorkflowEventBindingList) GetItems() []*WorkflowEventBinding {
	if m != nil {
		return m.Items
	}
	return nil
}

type WorkflowEventBindingSpec struct {
	// Event is the event to bind to
	Event *Event `protobuf:"bytes,1,opt,name=event" json:"event,omitempty"`
	// Submit is the workflow template to submit
	Submit               *Submit  `protobuf:"bytes,2,opt,name=submit" json:"submit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowEventBindingSpec) Reset()         { *m = WorkflowEventBindingSpec{} }
func (m *WorkflowEventBindingSpec) String() string { return proto.CompactTextString(m) }
func (*WorkflowEventBindingSpec) ProtoMessage()    {}
func (*WorkflowEventBindingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{81}
}
func (m *WorkflowEventBindingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowEventBindingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowEventBindingSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowEventBindingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowEventBindingSpec.Merge(m, src)
}
func (m *WorkflowEventBindingSpec) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowEventBindingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowEventBindingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowEventBindingSpec proto.InternalMessageInfo

func (m *WorkflowEventBindingSpec) GetEvent() *Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *WorkflowEventBindingSpec) GetSubmit() *Submit {
	if m != nil {
		return m.Submit
	}
	return nil
}

// WorkflowList is list of Workflow resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type WorkflowList struct {
	Metadata             *v11.ListMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Items                []*Workflow   `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *WorkflowList) Reset()         { *m = WorkflowList{} }
func (m *WorkflowList) String() string { return proto.CompactTextString(m) }
func (*WorkflowList) ProtoMessage()    {}
func (*WorkflowList) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{82}
}
func (m *WorkflowList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowList.Merge(m, src)
}
func (m *WorkflowList) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowList) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowList.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowList proto.InternalMessageInfo

func (m *WorkflowList) GetMetadata() *v11.ListMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *WorkflowList) GetItems() []*Workflow {
	if m != nil {
		return m.Items
	}
	return nil
}

// WorkflowSpec is the specification of a Workflow.
type WorkflowSpec struct {
	// Templates is a list of workflow templates used in a workflow
	// +patchStrategy=merge
	// +patchMergeKey=name
	Templates []*Template `protobuf:"bytes,1,rep,name=templates" json:"templates,omitempty"`
	// Entrypoint is a template reference to the starting point of the workflow.
	Entrypoint *string `protobuf:"bytes,2,opt,name=entrypoint" json:"entrypoint,omitempty"`
	// Arguments contain the parameters and artifacts sent to the workflow entrypoint
	// Parameters are referencable globally using the 'workflow' variable prefix.
	// e.g. {{workflow.parameters.myparam}}
	Arguments *Arguments `protobuf:"bytes,3,opt,name=arguments" json:"arguments,omitempty"`
	// ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.
	ServiceAccountName *string `protobuf:"bytes,4,opt,name=serviceAccountName" json:"serviceAccountName,omitempty"`
	// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods.
	// ServiceAccountName of ExecutorConfig must be specified if this value is false.
	AutomountServiceAccountToken *bool `protobuf:"varint,28,opt,name=automountServiceAccountToken" json:"automountServiceAccountToken,omitempty"`
	// Executor holds configurations of executor containers of the workflow.
	Executor *ExecutorConfig `protobuf:"bytes,29,opt,name=executor" json:"executor,omitempty"`
	// Volumes is a list of volumes that can be mounted by containers in a workflow.
	// +patchStrategy=merge
	// +patchMergeKey=name
	Volumes []*v1.Volume `protobuf:"bytes,5,rep,name=volumes" json:"volumes,omitempty"`
	// VolumeClaimTemplates is a list of claims that containers are allowed to reference.
	// The Workflow controller will create the claims at the beginning of the workflow
	// and delete the claims upon completion of the workflow
	// +patchStrategy=merge
	// +patchMergeKey=name
	VolumeClaimTemplates []*v1.PersistentVolumeClaim `protobuf:"bytes,6,rep,name=volumeClaimTemplates" json:"volumeClaimTemplates,omitempty"`
	// Parallelism limits the max total parallel pods that can execute at the same time in a workflow
	Parallelism *int64 `protobuf:"varint,7,opt,name=parallelism" json:"parallelism,omitempty"`
	// ArtifactRepositoryRef specifies the configMap name and key containing the artifact repository config.
	ArtifactRepositoryRef *ArtifactRepositoryRef `protobuf:"bytes,8,opt,name=artifactRepositoryRef" json:"artifactRepositoryRef,omitempty"`
	// Suspend will suspend the workflow and prevent execution of any future steps in the workflow
	Suspend *bool `protobuf:"varint,9,opt,name=suspend" json:"suspend,omitempty"`
	// NodeSelector is a selector which will result in all pods of the workflow
	// to be scheduled on the selected node(s). This is able to be overridden by
	// a nodeSelector specified in the template.
	NodeSelector map[string]string `protobuf:"bytes,10,rep,name=nodeSelector" json:"nodeSelector,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Affinity sets the scheduling constraints for all pods in the workflow.
	// Can be overridden by an affinity specified in the template
	Affinity *v1.Affinity `protobuf:"bytes,11,opt,name=affinity" json:"affinity,omitempty"`
	// Tolerations to apply to workflow pods.
	// +patchStrategy=merge
	// +patchMergeKey=key
	Tolerations []*v1.Toleration `protobuf:"bytes,12,rep,name=tolerations" json:"tolerations,omitempty"`
	// ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
	// in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets
	// can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
	// More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
	// +patchStrategy=merge
	// +patchMergeKey=name
	ImagePullSecrets []*v1.LocalObjectReference `protobuf:"bytes,13,rep,name=imagePullSecrets" json:"imagePullSecrets,omitempty"`
	// Host networking requested for this workflow pod. Default to false.
	HostNetwork *bool `protobuf:"varint,14,opt,name=hostNetwork" json:"hostNetwork,omitempty"`
	// Set DNS policy for the pod.
	// Defaults to "ClusterFirst".
	// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
	// DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
	// To have DNS options set along with hostNetwork, you have to specify DNS policy
	// explicitly to 'ClusterFirstWithHostNet'.
	DnsPolicy *string `protobuf:"bytes,15,opt,name=dnsPolicy" json:"dnsPolicy,omitempty"`
	// PodDNSConfig defines the DNS parameters of a pod in addition to
	// those generated from DNSPolicy.
	DnsConfig *v1.PodDNSConfig `protobuf:"bytes,16,opt,name=dnsConfig" json:"dnsConfig,omitempty"`
	// OnExit is a template reference which is invoked at the end of the
	// workflow, irrespective of the success, failure, or error of the
	// primary workflow.
	OnExit *string `protobuf:"bytes,17,opt,name=onExit" json:"onExit,omitempty"`
	// TTLSecondsAfterFinished limits the lifetime of a Workflow that has finished execution
	// (Succeeded, Failed, Error). If this field is set, once the Workflow finishes, it will be
	// deleted after ttlSecondsAfterFinished expires. If this field is unset,
	// ttlSecondsAfterFinished will not expire. If this field is set to zero,
	// ttlSecondsAfterFinished expires immediately after the Workflow finishes.
	// DEPRECATED: Use TTLStrategy.SecondsAfterCompletion instead.
	TtlSecondsAfterFinished *int32 `protobuf:"varint,18,opt,name=ttlSecondsAfterFinished" json:"ttlSecondsAfterFinished,omitempty"`
	// TTLStrategy limits the lifetime of a Workflow that has finished execution depending on if it
	// Succeeded or Failed. If this struct is set, once the Workflow finishes, it will be
	// deleted after the time to live expires. If this field is unset,
	// the controller config map will hold the default values.
	TtlStrategy *TTLStrategy `protobuf:"bytes,30,opt,name=ttlStrategy" json:"ttlStrategy,omitempty"`
	// Optional duration in seconds relative to the workflow start time which the workflow is
	// allowed to run before the controller terminates the workflow. A value of zero is used to
	// terminate a Running workflow
	ActiveDeadlineSeconds *int64 `protobuf:"varint,19,opt,name=activeDeadlineSeconds" json:"activeDeadlineSeconds,omitempty"`
	// Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first.
	Priority *int32 `protobuf:"varint,20,opt,name=priority" json:"priority,omitempty"`
	// Set scheduler name for all pods.
	// Will be overridden if container/script template's scheduler name is set.
	// Default scheduler will be used if neither specified.
	// +optional
	SchedulerName *string `protobuf:"bytes,21,opt,name=schedulerName" json:"schedulerName,omitempty"`
	// PodGC describes the strategy to use when to deleting completed pods
	PodGC *PodGC `protobuf:"bytes,22,opt,name=podGC" json:"podGC,omitempty"`
	// PriorityClassName to apply to workflow pods.
	PodPriorityClassName *string `protobuf:"bytes,23,opt,name=podPriorityClassName" json:"podPriorityClassName,omitempty"`
	// Priority to apply to workflow pods.
	PodPriority *int32 `protobuf:"varint,24,opt,name=podPriority" json:"podPriority,omitempty"`
	// +patchStrategy=merge
	// +patchMergeKey=ip
	HostAliases []*v1.HostAlias `protobuf:"bytes,25,rep,name=hostAliases" json:"hostAliases,omitempty"`
	// SecurityContext holds pod-level security attributes and common container settings.
	// Optional: Defaults to empty.  See type description for default values of each field.
	// +optional
	SecurityContext *v1.PodSecurityContext `protobuf:"bytes,26,opt,name=securityContext" json:"securityContext,omitempty"`
	// PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of
	// container fields which are not strings (e.g. resource limits).
	PodSpecPatch *string `protobuf:"bytes,27,opt,name=podSpecPatch" json:"podSpecPatch,omitempty"`
	// PodDisruptionBudget holds the number of concurrent disruptions that you allow for Workflow's Pods.
	// Controller will automatically add the selector with workflow name, if selector is empty.
	// Optional: Defaults to empty.
	// +optional
	PodDisruptionBudget *v1beta1.PodDisruptionBudgetSpec `protobuf:"bytes,31,opt,name=podDisruptionBudget" json:"podDisruptionBudget,omitempty"`
	// Metrics are a list of metrics emitted from this Workflow
	Metrics *Metrics `protobuf:"bytes,32,opt,name=metrics" json:"metrics,omitempty"`
	// Shutdown will shutdown the workflow according to its ShutdownStrategy
	Shutdown *string `protobuf:"bytes,33,opt,name=shutdown" json:"shutdown,omitempty"`
	// WorkflowTemplateRef holds a reference to a WorkflowTemplate for execution
	WorkflowTemplateRef *WorkflowTemplateRef `protobuf:"bytes,34,opt,name=workflowTemplateRef" json:"workflowTemplateRef,omitempty"`
	// Synchronization holds synchronization lock configuration for this Workflow
	Synchronization *Synchronization `protobuf:"bytes,35,opt,name=synchronization" json:"synchronization,omitempty"`
	// VolumeClaimGC describes the strategy to use when to deleting volumes from completed workflows
	VolumeClaimGC *VolumeClaimGC `protobuf:"bytes,36,opt,name=volumeClaimGC" json:"volumeClaimGC,omitempty"`
	// RetryStrategy for all templates in the workflow.
	RetryStrategy        *RetryStrategy `protobuf:"bytes,37,opt,name=retryStrategy" json:"retryStrategy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *WorkflowSpec) Reset()         { *m = WorkflowSpec{} }
func (m *WorkflowSpec) String() string { return proto.CompactTextString(m) }
func (*WorkflowSpec) ProtoMessage()    {}
func (*WorkflowSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{83}
}
func (m *WorkflowSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowSpec.Merge(m, src)
}
func (m *WorkflowSpec) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowSpec proto.InternalMessageInfo

func (m *WorkflowSpec) GetTemplates() []*Template {
	if m != nil {
		return m.Templates
	}
	return nil
}

func (m *WorkflowSpec) GetEntrypoint() string {
	if m != nil && m.Entrypoint != nil {
		return *m.Entrypoint
	}
	return ""
}

func (m *WorkflowSpec) GetArguments() *Arguments {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *WorkflowSpec) GetServiceAccountName() string {
	if m != nil && m.ServiceAccountName != nil {
		return *m.ServiceAccountName
	}
	return ""
}

func (m *WorkflowSpec) GetAutomountServiceAccountToken() bool {
	if m != nil && m.AutomountServiceAccountToken != nil {
		return *m.AutomountServiceAccountToken
	}
	return false
}

func (m *WorkflowSpec) GetExecutor() *ExecutorConfig {
	if m != nil {
		return m.Executor
	}
	return nil
}

func (m *WorkflowSpec) GetVolumes() []*v1.Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *WorkflowSpec) GetVolumeClaimTemplates() []*v1.PersistentVolumeClaim {
	if m != nil {
		return m.VolumeClaimTemplates
	}
	return nil
}

func (m *WorkflowSpec) GetParallelism() int64 {
	if m != nil && m.Parallelism != nil {
		return *m.Parallelism
	}
	return 0
}

func (m *WorkflowSpec) GetArtifactRepositoryRef() *ArtifactRepositoryRef {
	if m != nil {
		return m.ArtifactRepositoryRef
	}
	return nil
}

func (m *WorkflowSpec) GetSuspend() bool {
	if m != nil && m.Suspend != nil {
		return *m.Suspend
	}
	return false
}

func (m *WorkflowSpec) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *WorkflowSpec) GetAffinity() *v1.Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

func (m *WorkflowSpec) GetTolerations() []*v1.Toleration {
	if m != nil {
		return m.Tolerations
	}
	return nil
}

func (m *WorkflowSpec) GetImagePullSecrets() []*v1.LocalObjectReference {
	if m != nil {
		return m.ImagePullSecrets
	}
	return nil
}

func (m *WorkflowSpec) GetHostNetwork() bool {
	if m != nil && m.HostNetwork != nil {
		return *m.HostNetwork
	}
	return false
}

func (m *WorkflowSpec) GetDnsPolicy() string {
	if m != nil && m.DnsPolicy != nil {
		return *m.DnsPolicy
	}
	return ""
}

func (m *WorkflowSpec) GetDnsConfig() *v1.PodDNSConfig {
	if m != nil {
		return m.DnsConfig
	}
	return nil
}

func (m *WorkflowSpec) GetOnExit() string {
	if m != nil && m.OnExit != nil {
		return *m.OnExit
	}
	return ""
}

func (m *WorkflowSpec) GetTtlSecondsAfterFinished() int32 {
	if m != nil && m.TtlSecondsAfterFinished != nil {
		return *m.TtlSecondsAfterFinished
	}
	return 0
}

func (m *WorkflowSpec) GetTtlStrategy() *TTLStrategy {
	if m != nil {
		return m.TtlStrategy
	}
	return nil
}

func (m *WorkflowSpec) GetActiveDeadlineSeconds() int64 {
	if m != nil && m.ActiveDeadlineSeconds != nil {
		return *m.ActiveDeadlineSeconds
	}
	return 0
}

func (m *WorkflowSpec) GetPriority() int32 {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return 0
}

func (m *WorkflowSpec) GetSchedulerName() string {
	if m != nil && m.SchedulerName != nil {
		return *m.SchedulerName
	}
	return ""
}

func (m *WorkflowSpec) GetPodGC() *PodGC {
	if m != nil {
		return m.PodGC
	}
	return nil
}

func (m *WorkflowSpec) GetPodPriorityClassName() string {
	if m != nil && m.PodPriorityClassName != nil {
		return *m.PodPriorityClassName
	}
	return ""
}

func (m *WorkflowSpec) GetPodPriority() int32 {
	if m != nil && m.PodPriority != nil {
		return *m.PodPriority
	}
	return 0
}

func (m *WorkflowSpec) GetHostAliases() []*v1.HostAlias {
	if m != nil {
		return m.HostAliases
	}
	return nil
}

func (m *WorkflowSpec) GetSecurityContext() *v1.PodSecurityContext {
	if m != nil {
		return m.SecurityContext
	}
	return nil
}

func (m *WorkflowSpec) GetPodSpecPatch() string {
	if m != nil && m.PodSpecPatch != nil {
		return *m.PodSpecPatch
	}
	return ""
}

func (m *WorkflowSpec) GetPodDisruptionBudget() *v1beta1.PodDisruptionBudgetSpec {
	if m != nil {
		return m.PodDisruptionBudget
	}
	return nil
}

func (m *WorkflowSpec) GetMetrics() *Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *WorkflowSpec) GetShutdown() string {
	if m != nil && m.Shutdown != nil {
		return *m.Shutdown
	}
	return ""
}

func (m *WorkflowSpec) GetWorkflowTemplateRef() *WorkflowTemplateRef {
	if m != nil {
		return m.WorkflowTemplateRef
	}
	return nil
}

func (m *WorkflowSpec) GetSynchronization() *Synchronization {
	if m != nil {
		return m.Synchronization
	}
	return nil
}

func (m *WorkflowSpec) GetVolumeClaimGC() *VolumeClaimGC {
	if m != nil {
		return m.VolumeClaimGC
	}
	return nil
}

func (m *WorkflowSpec) GetRetryStrategy() *RetryStrategy {
	if m != nil {
		return m.RetryStrategy
	}
	return nil
}

// WorkflowStatus contains overall status information about a workflow
type WorkflowStatus struct {
	// Phase a simple, high-level summary of where the workflow is in its lifecycle.
	Phase *string `protobuf:"bytes,1,opt,name=phase" json:"phase,omitempty"`
	// Time at which this workflow started
	StartedAt *v11.Time `protobuf:"bytes,2,opt,name=startedAt" json:"startedAt,omitempty"`
	// Time at which this workflow completed
	FinishedAt *v11.Time `protobuf:"bytes,3,opt,name=finishedAt" json:"finishedAt,omitempty"`
	// EstimatedDuration in seconds.
	EstimatedDuration *int64 `protobuf:"varint,16,opt,name=estimatedDuration" json:"estimatedDuration,omitempty"`
	// A human readable message indicating details about why the workflow is in this condition.
	Message *string `protobuf:"bytes,4,opt,name=message" json:"message,omitempty"`
	// Compressed and base64 decoded Nodes map
	CompressedNodes *string `protobuf:"bytes,5,opt,name=compressedNodes" json:"compressedNodes,omitempty"`
	// Nodes is a mapping between a node ID and the node's status.
	Nodes map[string]*NodeStatus `protobuf:"bytes,6,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Whether on not node status has been offloaded to a database. If exists, then Nodes and CompressedNodes will be empty.
	// This will actually be populated with a hash of the offloaded data.
	OffloadNodeStatusVersion *string `protobuf:"bytes,10,opt,name=offloadNodeStatusVersion" json:"offloadNodeStatusVersion,omitempty"`
	// StoredTemplates is a mapping between a template ref and the node's status.
	StoredTemplates map[string]*Template `protobuf:"bytes,9,rep,name=storedTemplates" json:"storedTemplates,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// PersistentVolumeClaims tracks all PVCs that were created as part of the workflow.
	// The contents of this list are drained at the end of the workflow.
	PersistentVolumeClaims []*v1.Volume `protobuf:"bytes,7,rep,name=persistentVolumeClaims" json:"persistentVolumeClaims,omitempty"`
	// Outputs captures output values and artifact locations produced by the workflow via global outputs
	Outputs *Outputs `protobuf:"bytes,8,opt,name=outputs" json:"outputs,omitempty"`
	// Conditions is a list of conditions the Workflow may have
	Conditions []*Condition `protobuf:"bytes,13,rep,name=conditions" json:"conditions,omitempty"`
	// ResourcesDuration is the total for the workflow
	ResourcesDuration map[string]int64 `protobuf:"bytes,12,rep,name=resourcesDuration" json:"resourcesDuration,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// StoredWorkflowSpec stores the WorkflowTemplate spec for future execution.
	StoredWorkflowTemplateSpec *WorkflowSpec `protobuf:"bytes,14,opt,name=storedWorkflowTemplateSpec" json:"storedWorkflowTemplateSpec,omitempty"`
	// Synchronization stores the status of synchronization locks
	Synchronization      *SynchronizationStatus `protobuf:"bytes,15,opt,name=synchronization" json:"synchronization,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *WorkflowStatus) Reset()         { *m = WorkflowStatus{} }
func (m *WorkflowStatus) String() string { return proto.CompactTextString(m) }
func (*WorkflowStatus) ProtoMessage()    {}
func (*WorkflowStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{84}
}
func (m *WorkflowStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowStatus.Merge(m, src)
}
func (m *WorkflowStatus) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowStatus proto.InternalMessageInfo

func (m *WorkflowStatus) GetPhase() string {
	if m != nil && m.Phase != nil {
		return *m.Phase
	}
	return ""
}

func (m *WorkflowStatus) GetStartedAt() *v11.Time {
	if m != nil {
		return m.StartedAt
	}
	return nil
}

func (m *WorkflowStatus) GetFinishedAt() *v11.Time {
	if m != nil {
		return m.FinishedAt
	}
	return nil
}

func (m *WorkflowStatus) GetEstimatedDuration() int64 {
	if m != nil && m.EstimatedDuration != nil {
		return *m.EstimatedDuration
	}
	return 0
}

func (m *WorkflowStatus) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *WorkflowStatus) GetCompressedNodes() string {
	if m != nil && m.CompressedNodes != nil {
		return *m.CompressedNodes
	}
	return ""
}

func (m *WorkflowStatus) GetNodes() map[string]*NodeStatus {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *WorkflowStatus) GetOffloadNodeStatusVersion() string {
	if m != nil && m.OffloadNodeStatusVersion != nil {
		return *m.OffloadNodeStatusVersion
	}
	return ""
}

func (m *WorkflowStatus) GetStoredTemplates() map[string]*Template {
	if m != nil {
		return m.StoredTemplates
	}
	return nil
}

func (m *WorkflowStatus) GetPersistentVolumeClaims() []*v1.Volume {
	if m != nil {
		return m.PersistentVolumeClaims
	}
	return nil
}

func (m *WorkflowStatus) GetOutputs() *Outputs {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *WorkflowStatus) GetConditions() []*Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *WorkflowStatus) GetResourcesDuration() map[string]int64 {
	if m != nil {
		return m.ResourcesDuration
	}
	return nil
}

func (m *WorkflowStatus) GetStoredWorkflowTemplateSpec() *WorkflowSpec {
	if m != nil {
		return m.StoredWorkflowTemplateSpec
	}
	return nil
}

func (m *WorkflowStatus) GetSynchronization() *SynchronizationStatus {
	if m != nil {
		return m.Synchronization
	}
	return nil
}

// WorkflowStep is a reference to a template to execute in a series of step
type WorkflowStep struct {
	// Name of the step
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Template is the name of the template to execute as the step
	Template *string `protobuf:"bytes,2,opt,name=template" json:"template,omitempty"`
	// Arguments hold arguments to the template
	Arguments *Arguments `protobuf:"bytes,3,opt,name=arguments" json:"arguments,omitempty"`
	// TemplateRef is the reference to the template resource to execute as the step.
	TemplateRef *TemplateRef `protobuf:"bytes,4,opt,name=templateRef" json:"templateRef,omitempty"`
	// WithItems expands a step into multiple parallel steps from the items in the list
	WithItems []*Item `protobuf:"bytes,5,rep,name=withItems" json:"withItems,omitempty"`
	// WithParam expands a step into multiple parallel steps from the value in the parameter,
	// which is expected to be a JSON list.
	WithParam *string `protobuf:"bytes,6,opt,name=withParam" json:"withParam,omitempty"`
	// WithSequence expands a step into a numeric sequence
	WithSequence *Sequence `protobuf:"bytes,7,opt,name=withSequence" json:"withSequence,omitempty"`
	// When is an expression in which the step should conditionally execute
	When *string `protobuf:"bytes,8,opt,name=when" json:"when,omitempty"`
	// ContinueOn makes argo to proceed with the following step even if this step fails.
	// Errors and Failed states can be specified
	ContinueOn *ContinueOn `protobuf:"bytes,9,opt,name=continueOn" json:"continueOn,omitempty"`
	// OnExit is a template reference which is invoked at the end of the
	// template, irrespective of the success, failure, or error of the
	// primary template.
	OnExit               *string  `protobuf:"bytes,11,opt,name=onExit" json:"onExit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowStep) Reset()         { *m = WorkflowStep{} }
func (m *WorkflowStep) String() string { return proto.CompactTextString(m) }
func (*WorkflowStep) ProtoMessage()    {}
func (*WorkflowStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{85}
}
func (m *WorkflowStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowStep.Merge(m, src)
}
func (m *WorkflowStep) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowStep) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowStep.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowStep proto.InternalMessageInfo

func (m *WorkflowStep) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *WorkflowStep) GetTemplate() string {
	if m != nil && m.Template != nil {
		return *m.Template
	}
	return ""
}

func (m *WorkflowStep) GetArguments() *Arguments {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *WorkflowStep) GetTemplateRef() *TemplateRef {
	if m != nil {
		return m.TemplateRef
	}
	return nil
}

func (m *WorkflowStep) GetWithItems() []*Item {
	if m != nil {
		return m.WithItems
	}
	return nil
}

func (m *WorkflowStep) GetWithParam() string {
	if m != nil && m.WithParam != nil {
		return *m.WithParam
	}
	return ""
}

func (m *WorkflowStep) GetWithSequence() *Sequence {
	if m != nil {
		return m.WithSequence
	}
	return nil
}

func (m *WorkflowStep) GetWhen() string {
	if m != nil && m.When != nil {
		return *m.When
	}
	return ""
}

func (m *WorkflowStep) GetContinueOn() *ContinueOn {
	if m != nil {
		return m.ContinueOn
	}
	return nil
}

func (m *WorkflowStep) GetOnExit() string {
	if m != nil && m.OnExit != nil {
		return *m.OnExit
	}
	return ""
}

// WorkflowTemplate is the definition of a workflow template resource
// +genclient
// +genclient:noStatus
// +kubebuilder:resource:shortName=wftmpl
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type WorkflowTemplate struct {
	Metadata             *v11.ObjectMeta       `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec                 *WorkflowTemplateSpec `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *WorkflowTemplate) Reset()         { *m = WorkflowTemplate{} }
func (m *WorkflowTemplate) String() string { return proto.CompactTextString(m) }
func (*WorkflowTemplate) ProtoMessage()    {}
func (*WorkflowTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{86}
}
func (m *WorkflowTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowTemplate.Merge(m, src)
}
func (m *WorkflowTemplate) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowTemplate proto.InternalMessageInfo

func (m *WorkflowTemplate) GetMetadata() *v11.ObjectMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *WorkflowTemplate) GetSpec() *WorkflowTemplateSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// WorkflowTemplateList is list of WorkflowTemplate resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type WorkflowTemplateList struct {
	Metadata             *v11.ListMeta       `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Items                []*WorkflowTemplate `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *WorkflowTemplateList) Reset()         { *m = WorkflowTemplateList{} }
func (m *WorkflowTemplateList) String() string { return proto.CompactTextString(m) }
func (*WorkflowTemplateList) ProtoMessage()    {}
func (*WorkflowTemplateList) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{87}
}
func (m *WorkflowTemplateList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowTemplateList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowTemplateList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowTemplateList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowTemplateList.Merge(m, src)
}
func (m *WorkflowTemplateList) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowTemplateList) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowTemplateList.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowTemplateList proto.InternalMessageInfo

func (m *WorkflowTemplateList) GetMetadata() *v11.ListMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *WorkflowTemplateList) GetItems() []*WorkflowTemplate {
	if m != nil {
		return m.Items
	}
	return nil
}

// WorkflowTemplateRef is a reference to a WorkflowTemplate resource.
type WorkflowTemplateRef struct {
	// Name is the resource name of the workflow template.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate).
	ClusterScope         *bool    `protobuf:"varint,2,opt,name=clusterScope" json:"clusterScope,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowTemplateRef) Reset()         { *m = WorkflowTemplateRef{} }
func (m *WorkflowTemplateRef) String() string { return proto.CompactTextString(m) }
func (*WorkflowTemplateRef) ProtoMessage()    {}
func (*WorkflowTemplateRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{88}
}
func (m *WorkflowTemplateRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowTemplateRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowTemplateRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowTemplateRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowTemplateRef.Merge(m, src)
}
func (m *WorkflowTemplateRef) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowTemplateRef) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowTemplateRef.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowTemplateRef proto.InternalMessageInfo

func (m *WorkflowTemplateRef) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *WorkflowTemplateRef) GetClusterScope() bool {
	if m != nil && m.ClusterScope != nil {
		return *m.ClusterScope
	}
	return false
}

// WorkflowTemplateSpec is a spec of WorkflowTemplate.
type WorkflowTemplateSpec struct {
	WorkflowSpec *WorkflowSpec `protobuf:"bytes,1,opt,name=workflowSpec" json:"workflowSpec,omitempty"`
	// WorkflowMetadata contains some metadata of the workflow to be refer
	WorkflowMeta         *v11.ObjectMeta `protobuf:"bytes,2,opt,name=workflowMeta" json:"workflowMeta,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *WorkflowTemplateSpec) Reset()         { *m = WorkflowTemplateSpec{} }
func (m *WorkflowTemplateSpec) String() string { return proto.CompactTextString(m) }
func (*WorkflowTemplateSpec) ProtoMessage()    {}
func (*WorkflowTemplateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{89}
}
func (m *WorkflowTemplateSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowTemplateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowTemplateSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowTemplateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowTemplateSpec.Merge(m, src)
}
func (m *WorkflowTemplateSpec) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowTemplateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowTemplateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowTemplateSpec proto.InternalMessageInfo

func (m *WorkflowTemplateSpec) GetWorkflowSpec() *WorkflowSpec {
	if m != nil {
		return m.WorkflowSpec
	}
	return nil
}

func (m *WorkflowTemplateSpec) GetWorkflowMeta() *v11.ObjectMeta {
	if m != nil {
		return m.WorkflowMeta
	}
	return nil
}

// ZipStrategy will unzip zipped input artifacts
type ZipStrategy struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZipStrategy) Reset()         { *m = ZipStrategy{} }
func (m *ZipStrategy) String() string { return proto.CompactTextString(m) }
func (*ZipStrategy) ProtoMessage()    {}
func (*ZipStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_271ec8e8bc601009, []int{90}
}
func (m *ZipStrategy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZipStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZipStrategy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZipStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZipStrategy.Merge(m, src)
}
func (m *ZipStrategy) XXX_Size() int {
	return m.Size()
}
func (m *ZipStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_ZipStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_ZipStrategy proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Amount)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Amount")
	proto.RegisterType((*ArchiveStrategy)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ArchiveStrategy")
	proto.RegisterType((*Arguments)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Arguments")
	proto.RegisterType((*Artifact)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Artifact")
	proto.RegisterType((*ArtifactLocation)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ArtifactLocation")
	proto.RegisterType((*ArtifactRepositoryRef)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ArtifactRepositoryRef")
	proto.RegisterType((*ArtifactoryArtifact)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ArtifactoryArtifact")
	proto.RegisterType((*ArtifactoryAuth)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ArtifactoryAuth")
	proto.RegisterType((*Backoff)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Backoff")
	proto.RegisterType((*Cache)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Cache")
	proto.RegisterType((*ClusterWorkflowTemplate)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ClusterWorkflowTemplate")
	proto.RegisterType((*ClusterWorkflowTemplateList)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ClusterWorkflowTemplateList")
	proto.RegisterType((*Condition)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Condition")
	proto.RegisterType((*ContinueOn)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ContinueOn")
	proto.RegisterType((*Counter)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Counter")
	proto.RegisterType((*CronWorkflow)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.CronWorkflow")
	proto.RegisterType((*CronWorkflowList)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.CronWorkflowList")
	proto.RegisterType((*CronWorkflowSpec)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.CronWorkflowSpec")
	proto.RegisterType((*CronWorkflowStatus)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.CronWorkflowStatus")
	proto.RegisterType((*DAGTask)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.DAGTask")
	proto.RegisterType((*DAGTemplate)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.DAGTemplate")
	proto.RegisterType((*Event)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Event")
	proto.RegisterType((*ExecutorConfig)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ExecutorConfig")
	proto.RegisterType((*GCSArtifact)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.GCSArtifact")
	proto.RegisterType((*GCSBucket)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.GCSBucket")
	proto.RegisterType((*Gauge)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Gauge")
	proto.RegisterType((*GitArtifact)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.GitArtifact")
	proto.RegisterType((*HDFSArtifact)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.HDFSArtifact")
	proto.RegisterType((*HDFSConfig)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.HDFSConfig")
	proto.RegisterType((*HDFSKrbConfig)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.HDFSKrbConfig")
	proto.RegisterType((*HTTPArtifact)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.HTTPArtifact")
	proto.RegisterType((*Header)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Header")
	proto.RegisterType((*Histogram)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Histogram")
	proto.RegisterType((*Inputs)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Inputs")
	proto.RegisterType((*Item)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Item")
	proto.RegisterType((*Link)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Link")
	proto.RegisterType((*MemoizationStatus)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.MemoizationStatus")
	proto.RegisterType((*Memoize)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Memoize")
	proto.RegisterType((*Metadata)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Metadata")
	proto.RegisterMapType((map[string]string)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Metadata.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Metadata.LabelsEntry")
	proto.RegisterType((*MetricLabel)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.MetricLabel")
	proto.RegisterType((*Metrics)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Metrics")
	proto.RegisterType((*Mutex)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Mutex")
	proto.RegisterType((*MutexHolding)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.MutexHolding")
	proto.RegisterType((*MutexStatus)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.MutexStatus")
	proto.RegisterType((*NodeStatus)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.NodeStatus")
	proto.RegisterMapType((map[string]int64)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.NodeStatus.ResourcesDurationEntry")
	proto.RegisterType((*NodeSynchronizationStatus)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.NodeSynchronizationStatus")
	proto.RegisterType((*NoneStrategy)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.NoneStrategy")
	proto.RegisterType((*OSSArtifact)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.OSSArtifact")
	proto.RegisterType((*OSSBucket)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.OSSBucket")
	proto.RegisterType((*Outputs)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Outputs")
	proto.RegisterType((*ParallelSteps)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ParallelSteps")
	proto.RegisterType((*Parameter)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Parameter")
	proto.RegisterType((*PodGC)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.PodGC")
	proto.RegisterType((*Prometheus)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Prometheus")
	proto.RegisterType((*RawArtifact)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.RawArtifact")
	proto.RegisterType((*ResourceTemplate)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ResourceTemplate")
	proto.RegisterType((*RetryStrategy)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.RetryStrategy")
	proto.RegisterType((*S3Artifact)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.S3Artifact")
	proto.RegisterType((*S3Bucket)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.S3Bucket")
	proto.RegisterType((*ScriptTemplate)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ScriptTemplate")
	proto.RegisterType((*SemaphoreHolding)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.SemaphoreHolding")
	proto.RegisterType((*SemaphoreRef)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.SemaphoreRef")
	proto.RegisterType((*SemaphoreStatus)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.SemaphoreStatus")
	proto.RegisterType((*Sequence)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Sequence")
	proto.RegisterType((*Submit)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Submit")
	proto.RegisterType((*SubmitOpts)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.SubmitOpts")
	proto.RegisterType((*SuppliedValueFrom)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.SuppliedValueFrom")
	proto.RegisterType((*SuspendTemplate)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.SuspendTemplate")
	proto.RegisterType((*Synchronization)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Synchronization")
	proto.RegisterType((*SynchronizationStatus)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.SynchronizationStatus")
	proto.RegisterType((*TTLStrategy)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.TTLStrategy")
	proto.RegisterType((*TarStrategy)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.TarStrategy")
	proto.RegisterType((*Template)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Template")
	proto.RegisterMapType((map[string]string)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Template.NodeSelectorEntry")
	proto.RegisterType((*TemplateRef)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.TemplateRef")
	proto.RegisterType((*UserContainer)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.UserContainer")
	proto.RegisterType((*ValueFrom)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ValueFrom")
	proto.RegisterType((*Version)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Version")
	proto.RegisterType((*VolumeClaimGC)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.VolumeClaimGC")
	proto.RegisterType((*Workflow)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.Workflow")
	proto.RegisterType((*WorkflowEventBinding)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowEventBinding")
	proto.RegisterType((*WorkflowEventBindingList)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowEventBindingList")
	proto.RegisterType((*WorkflowEventBindingSpec)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowEventBindingSpec")
	proto.RegisterType((*WorkflowList)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowList")
	proto.RegisterType((*WorkflowSpec)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowSpec")
	proto.RegisterMapType((map[string]string)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowSpec.NodeSelectorEntry")
	proto.RegisterType((*WorkflowStatus)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowStatus")
	proto.RegisterMapType((map[string]*NodeStatus)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowStatus.NodesEntry")
	proto.RegisterMapType((map[string]int64)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowStatus.ResourcesDurationEntry")
	proto.RegisterMapType((map[string]*Template)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowStatus.StoredTemplatesEntry")
	proto.RegisterType((*WorkflowStep)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowStep")
	proto.RegisterType((*WorkflowTemplate)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowTemplate")
	proto.RegisterType((*WorkflowTemplateList)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowTemplateList")
	proto.RegisterType((*WorkflowTemplateRef)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowTemplateRef")
	proto.RegisterType((*WorkflowTemplateSpec)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.WorkflowTemplateSpec")
	proto.RegisterType((*ZipStrategy)(nil), "github.com.argoproj.argo.pkg.apis.workflow.v1alpha1.ZipStrategy")
}

func init() {
	proto.RegisterFile("pkg/apis/workflow/v1alpha1/generated.proto", fileDescriptor_271ec8e8bc601009)
}

var fileDescriptor_271ec8e8bc601009 = []byte{
	// 5516 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x5c, 0x4b, 0x70, 0x1c, 0xc7,
	0x79, 0xae, 0x5d, 0x60, 0x81, 0xdd, 0x7f, 0x01, 0x02, 0x68, 0xbe, 0x56, 0x10, 0x4d, 0xd3, 0x23,
	0xdb, 0x45, 0x3b, 0x0a, 0x68, 0x91, 0x8a, 0x4b, 0x0f, 0x8b, 0x22, 0x08, 0x10, 0x24, 0x25, 0x92,
	0x40, 0x7a, 0x41, 0x4a, 0x96, 0x64, 0xb1, 0x06, 0x33, 0xbd, 0xbb, 0x43, 0xcc, 0xce, 0x8c, 0xba,
	0x7b, 0x00, 0x42, 0x15, 0x57, 0x45, 0x89, 0x52, 0xe5, 0x54, 0x52, 0x95, 0xe4, 0x90, 0x38, 0xb9,
	0xe5, 0x92, 0x43, 0x92, 0x83, 0x73, 0xcb, 0xd1, 0x95, 0xaa, 0x38, 0xf2, 0xc5, 0x55, 0x4e, 0xf9,
	0x96, 0x53, 0xa2, 0x4b, 0x8e, 0xa9, 0x5c, 0x7c, 0xc8, 0x29, 0xd5, 0xaf, 0x79, 0xed, 0xac, 0x44,
	0xcc, 0x2e, 0x55, 0xa5, 0xf2, 0x6d, 0xfa, 0xf5, 0xf5, 0xeb, 0xef, 0xee, 0xff, 0xff, 0xfa, 0xef,
	0x81, 0x6f, 0x47, 0xfb, 0xfd, 0x4b, 0x76, 0xe4, 0xb1, 0x4b, 0x87, 0x21, 0xdd, 0xef, 0xf9, 0xe1,
	0xe1, 0xa5, 0x83, 0x17, 0x6c, 0x3f, 0x1a, 0xd8, 0x2f, 0x5c, 0xea, 0x93, 0x80, 0x50, 0x9b, 0x13,
	0x77, 0x2d, 0xa2, 0x21, 0x0f, 0xd1, 0x95, 0xbe, 0xc7, 0x07, 0xf1, 0xde, 0x9a, 0x13, 0x0e, 0xd7,
	0x6c, 0xda, 0x0f, 0x23, 0x1a, 0x3e, 0x92, 0x1f, 0x6b, 0xd1, 0x7e, 0x7f, 0x4d, 0x80, 0xac, 0x19,
	0x90, 0x35, 0x03, 0xb2, 0x6a, 0xed, 0xbf, 0xc4, 0xd6, 0xbc, 0x50, 0xd4, 0x71, 0xc9, 0x09, 0x29,
	0xb9, 0x74, 0x30, 0x02, 0xbc, 0xfa, 0xad, 0x4c, 0x9e, 0x28, 0xf4, 0x3d, 0xe7, 0xe8, 0xd2, 0xc1,
	0x0b, 0x7b, 0x84, 0x8f, 0xb6, 0x61, 0xf5, 0xc5, 0x34, 0xeb, 0xd0, 0x76, 0x06, 0x5e, 0x40, 0xe8,
	0xd1, 0xa5, 0xa4, 0x0f, 0x43, 0xc2, 0xed, 0xb2, 0x0a, 0x2e, 0x8d, 0x2b, 0x45, 0xe3, 0x80, 0x7b,
	0x43, 0x32, 0x52, 0xe0, 0xbb, 0x9f, 0x57, 0x80, 0x39, 0x03, 0x32, 0xb4, 0x47, 0xca, 0x5d, 0x19,
	0x57, 0x2e, 0xe6, 0x9e, 0x7f, 0xc9, 0x0b, 0x38, 0xe3, 0xb4, 0x58, 0xc8, 0x3a, 0x0f, 0x73, 0xeb,
	0xc3, 0x30, 0x0e, 0x38, 0x3a, 0x05, 0x8d, 0x03, 0xdb, 0x8f, 0x49, 0xa7, 0x76, 0xa1, 0x76, 0xb1,
	0x85, 0x55, 0xc0, 0xfa, 0xf3, 0x3a, 0x2c, 0xad, 0x53, 0x67, 0xe0, 0x1d, 0x90, 0x2e, 0x17, 0x05,
	0xfb, 0x47, 0x08, 0xc3, 0x0c, 0xb7, 0xa9, 0xcc, 0xd7, 0xbe, 0x7c, 0x6d, 0xad, 0xc2, 0xcc, 0xac,
	0xed, 0xda, 0xd4, 0xc0, 0x61, 0x01, 0x86, 0xee, 0xc3, 0x6c, 0x10, 0x06, 0xa4, 0x53, 0x97, 0xa0,
	0xeb, 0x95, 0x40, 0xef, 0x85, 0x41, 0xd2, 0x48, 0x2c, 0xe1, 0x44, 0x53, 0x3f, 0xf4, 0xa2, 0xce,
	0xcc, 0x04, 0x4d, 0x7d, 0xc7, 0x8b, 0xd2, 0xa6, 0x7e, 0xe8, 0x45, 0xd6, 0xcf, 0x6b, 0xd0, 0x5a,
	0xa7, 0xfd, 0x78, 0x48, 0x02, 0xce, 0xd0, 0xfb, 0x00, 0x91, 0x4d, 0xed, 0x21, 0xe1, 0x84, 0xb2,
	0x4e, 0xed, 0xc2, 0xcc, 0xc5, 0xf6, 0xe5, 0xab, 0x95, 0x2a, 0xda, 0x31, 0x30, 0x38, 0x83, 0x88,
	0xde, 0x85, 0x96, 0x4d, 0xb9, 0xd7, 0xb3, 0x1d, 0xce, 0x3a, 0x75, 0x09, 0xff, 0x5a, 0x25, 0xf8,
	0x75, 0x8d, 0x82, 0x53, 0x3c, 0xeb, 0xef, 0x66, 0xa0, 0x69, 0xe2, 0x11, 0x82, 0xd9, 0xc0, 0x1e,
	0x9a, 0xf9, 0x97, 0xdf, 0x22, 0x2e, 0xb2, 0xf9, 0x40, 0x4e, 0x4b, 0x0b, 0xcb, 0x6f, 0x11, 0x37,
	0x0c, 0x5d, 0x22, 0x07, 0xb5, 0x81, 0xe5, 0xb7, 0x88, 0xeb, 0xd1, 0x70, 0xd8, 0x99, 0x55, 0xf9,
	0xc4, 0x37, 0xfa, 0x00, 0x96, 0x4d, 0x4d, 0x77, 0x42, 0xc7, 0xe6, 0x5e, 0x18, 0x74, 0x1a, 0x72,
	0x22, 0x6e, 0x4c, 0xd4, 0x01, 0x03, 0x86, 0x47, 0xe0, 0xd1, 0x79, 0x80, 0xbe, 0x1f, 0xee, 0xd9,
	0xfe, 0x3d, 0xd1, 0x91, 0x39, 0xd9, 0x98, 0x4c, 0x0c, 0x7a, 0x1f, 0xe6, 0x6d, 0x25, 0xcc, 0x9d,
	0x79, 0xd9, 0x92, 0xcd, 0x8a, 0x2d, 0xc9, 0x2d, 0x08, 0x6c, 0x40, 0xd1, 0x2a, 0x34, 0xc3, 0x48,
	0xb4, 0xc4, 0xf6, 0x3b, 0xcd, 0x0b, 0xb5, 0x8b, 0x4d, 0x9c, 0x84, 0x51, 0x07, 0xe6, 0x59, 0xbc,
	0xb7, 0x23, 0x46, 0xb3, 0x25, 0x1b, 0x66, 0x82, 0xe8, 0x02, 0xb4, 0x29, 0x71, 0x62, 0xca, 0xc8,
	0x5d, 0x31, 0xae, 0x20, 0x0b, 0x66, 0xa3, 0xac, 0xff, 0x69, 0xc0, 0x72, 0xb1, 0xfb, 0xa2, 0x98,
	0xae, 0xf7, 0x4e, 0xd8, 0x67, 0x72, 0xda, 0x9a, 0x38, 0x1b, 0x85, 0xb6, 0xa1, 0xce, 0xae, 0xe8,
	0x25, 0xf5, 0x7a, 0xa5, 0x9e, 0x76, 0xaf, 0x24, 0x62, 0x53, 0x67, 0x57, 0xc4, 0x72, 0xea, 0x7b,
	0x7c, 0xa2, 0xe5, 0x74, 0xd3, 0xe3, 0x09, 0xa4, 0x00, 0x13, 0x2b, 0x7f, 0xc0, 0x79, 0x24, 0x45,
	0xa7, 0xea, 0xca, 0xbf, 0xb5, 0xbb, 0xbb, 0x93, 0xa0, 0x4a, 0x38, 0xf4, 0x48, 0x8c, 0x8e, 0x8a,
	0x09, 0xe9, 0x91, 0x16, 0xbc, 0x5b, 0x13, 0x09, 0x5e, 0x48, 0x8f, 0x92, 0x4a, 0xb2, 0xe0, 0xb2,
	0x0b, 0x6e, 0x8f, 0x49, 0x81, 0xab, 0xdc, 0x85, 0xcd, 0xad, 0x6e, 0xa6, 0x0b, 0x6e, 0x8f, 0x89,
	0xd1, 0xa6, 0xf6, 0xa1, 0x96, 0xd4, 0x6a, 0xa3, 0x8d, 0xed, 0xc3, 0x74, 0xb4, 0xa9, 0x7d, 0x28,
	0x30, 0x43, 0xc6, 0xa4, 0x70, 0x56, 0xc5, 0xdc, 0xee, 0xa6, 0x0d, 0x15, 0x60, 0x52, 0x2a, 0x1c,
	0x26, 0xa5, 0xba, 0xb2, 0x54, 0x6c, 0x64, 0x30, 0xfb, 0x0e, 0xb3, 0x6e, 0xc2, 0xe9, 0x24, 0x82,
	0x44, 0x21, 0xf3, 0xc4, 0x40, 0x63, 0xd2, 0x43, 0xe7, 0xa0, 0xe5, 0x84, 0x41, 0xcf, 0xeb, 0xdf,
	0xb5, 0x23, 0xbd, 0x55, 0xa5, 0x11, 0x68, 0x19, 0x66, 0xf6, 0xc9, 0x91, 0xde, 0xae, 0xc4, 0xa7,
	0xf5, 0xe3, 0x1a, 0x9c, 0x2c, 0x99, 0x40, 0x91, 0x33, 0xa6, 0xbe, 0x46, 0x10, 0x9f, 0x28, 0x80,
	0xa5, 0xcc, 0xa4, 0xae, 0xc7, 0x7a, 0xdb, 0xab, 0xbe, 0x49, 0xe4, 0xb0, 0x70, 0x11, 0xdc, 0xfa,
	0x49, 0x4d, 0x1c, 0xad, 0xb9, 0x38, 0x74, 0x17, 0x4e, 0xc4, 0x8c, 0x50, 0xb1, 0xf7, 0x76, 0x89,
	0x43, 0x09, 0xd7, 0xa7, 0xec, 0x37, 0xd6, 0xd4, 0xe1, 0x2e, 0x2a, 0x5b, 0x13, 0xaa, 0xcc, 0xda,
	0xc1, 0x0b, 0x6b, 0x2a, 0xc7, 0x9b, 0xe4, 0xa8, 0x4b, 0x7c, 0x22, 0x30, 0x70, 0xa1, 0xb0, 0x80,
	0x8b, 0x6c, 0xc6, 0x0e, 0x43, 0xea, 0x6a, 0xb8, 0xfa, 0xb1, 0xe0, 0xf2, 0x85, 0xad, 0xbf, 0xa8,
	0xc1, 0xfc, 0x75, 0xdb, 0xd9, 0x0f, 0x7b, 0x3d, 0xb1, 0xd5, 0xb9, 0x31, 0x55, 0xbb, 0xba, 0x1a,
	0xc4, 0x24, 0x8c, 0x6e, 0xc1, 0x9c, 0xea, 0x94, 0xae, 0xee, 0x3b, 0x99, 0xea, 0x12, 0xd5, 0x44,
	0x8e, 0x9d, 0x50, 0x4d, 0xd6, 0x94, 0x6a, 0xb2, 0x76, 0x3b, 0xe0, 0xdb, 0x42, 0x2b, 0xf0, 0x82,
	0x3e, 0xd6, 0xe5, 0xc5, 0x1e, 0x37, 0xb4, 0x1f, 0x6f, 0x9a, 0x8a, 0x66, 0x64, 0x45, 0xd9, 0x28,
	0x6b, 0x1b, 0x1a, 0x1b, 0xb6, 0x33, 0x20, 0x68, 0xab, 0x28, 0x18, 0xed, 0xcb, 0x17, 0xcb, 0xba,
	0xb9, 0x61, 0x32, 0x65, 0x7b, 0x9a, 0x16, 0xb5, 0xfe, 0xad, 0x06, 0x67, 0x37, 0xfc, 0x98, 0x71,
	0x42, 0xdf, 0xd2, 0x93, 0xba, 0x4b, 0x86, 0x91, 0x6f, 0x73, 0x82, 0xee, 0x40, 0x53, 0xa8, 0x79,
	0xae, 0xcd, 0x6d, 0x5d, 0xc5, 0xf8, 0xae, 0x49, 0xb1, 0x10, 0xb9, 0x45, 0xa5, 0xdb, 0x7b, 0x8f,
	0x88, 0xc3, 0xef, 0x12, 0x6e, 0xe3, 0x04, 0x01, 0xfd, 0x00, 0x66, 0x59, 0x44, 0x1c, 0x3d, 0x48,
	0xb7, 0x2b, 0x49, 0x59, 0xb1, 0x89, 0xdd, 0x88, 0x38, 0x58, 0xc2, 0x5a, 0xbf, 0xa8, 0xc1, 0xb3,
	0x63, 0x3a, 0x72, 0xc7, 0x63, 0x1c, 0xbd, 0x31, 0xd2, 0x99, 0xb5, 0x27, 0xeb, 0x8c, 0x28, 0x5d,
	0xe8, 0xca, 0x1e, 0x34, 0x3c, 0x4e, 0x86, 0x46, 0x43, 0xb9, 0x53, 0xa9, 0x2f, 0x63, 0x1a, 0x8b,
	0x15, 0xb4, 0xf5, 0xbb, 0xd0, 0xda, 0x08, 0x03, 0xd7, 0x93, 0x22, 0x86, 0x60, 0x96, 0x1f, 0x45,
	0x89, 0xb2, 0x22, 0xbe, 0xd1, 0x19, 0x98, 0x63, 0xdc, 0xe6, 0x31, 0xd3, 0xeb, 0x5f, 0x87, 0xc4,
	0xc9, 0x3b, 0x24, 0x8c, 0xd9, 0x7d, 0xa2, 0x05, 0xc8, 0x04, 0xad, 0x57, 0x00, 0x36, 0xc2, 0x80,
	0x7b, 0x41, 0x4c, 0xb6, 0x03, 0xa1, 0x01, 0x13, 0x4a, 0x43, 0xaa, 0x8f, 0x52, 0x15, 0x10, 0xa8,
	0x3d, 0xdb, 0xf3, 0x89, 0x2b, 0x51, 0x9b, 0x58, 0x87, 0xac, 0xaf, 0xc2, 0xfc, 0x86, 0x50, 0x9c,
	0x09, 0x1d, 0xa3, 0x3a, 0xff, 0x75, 0x1d, 0x16, 0x36, 0x68, 0x18, 0x98, 0xfe, 0x4c, 0x59, 0x7a,
	0xbe, 0x9f, 0x93, 0x9e, 0x6a, 0x2a, 0x55, 0xb6, 0x79, 0xa9, 0xe4, 0xa0, 0x87, 0xc9, 0x40, 0xaa,
	0x93, 0xfe, 0xe6, 0xe4, 0xe0, 0x12, 0xce, 0xcc, 0x88, 0xf5, 0xcf, 0x35, 0x58, 0xce, 0x26, 0x4f,
	0x5d, 0x1e, 0xdf, 0xca, 0xcb, 0xe3, 0xfa, 0xc4, 0x1d, 0x30, 0x42, 0xf8, 0xd1, 0x6c, 0xbe, 0xe5,
	0x62, 0xd4, 0x10, 0x81, 0x85, 0xc3, 0x4c, 0x58, 0xb7, 0x7e, 0x7d, 0xa2, 0x05, 0x2d, 0xa7, 0x23,
	0x07, 0x2b, 0xb6, 0x5c, 0x61, 0xfa, 0xb9, 0xb1, 0x4f, 0xb4, 0x84, 0x27, 0x61, 0xf4, 0x3c, 0xac,
	0x38, 0x61, 0xe0, 0xc4, 0x94, 0x92, 0xc0, 0x39, 0xda, 0x91, 0x86, 0xac, 0x96, 0xf6, 0xd1, 0x04,
	0xa5, 0x8b, 0xb2, 0x88, 0x04, 0xae, 0x54, 0xbb, 0x9a, 0xd8, 0x04, 0xd1, 0x4b, 0x70, 0x96, 0x71,
	0x71, 0x52, 0x05, 0xfd, 0x4d, 0x62, 0xbb, 0xbe, 0x17, 0x88, 0xb3, 0x24, 0x0c, 0x5c, 0x26, 0x55,
	0xa8, 0x19, 0x3c, 0x2e, 0x19, 0x5d, 0x85, 0x55, 0x16, 0x3b, 0x0e, 0x61, 0xac, 0x17, 0xfb, 0x6f,
	0x84, 0x7b, 0xec, 0x96, 0xc7, 0xc4, 0xb9, 0x76, 0xc7, 0x1b, 0x7a, 0x5c, 0xaa, 0x46, 0x0d, 0xfc,
	0x19, 0x39, 0xd0, 0x77, 0xe1, 0x8c, 0x5a, 0x59, 0x23, 0x65, 0xe7, 0x65, 0xd9, 0x31, 0xa9, 0x62,
	0x54, 0x84, 0x55, 0xfc, 0xa1, 0xb0, 0x1e, 0x9b, 0x6a, 0x54, 0x4c, 0x18, 0xed, 0xa6, 0x13, 0x23,
	0x04, 0x44, 0xab, 0x28, 0xc7, 0x5f, 0x75, 0x39, 0x14, 0xeb, 0x4f, 0xea, 0x80, 0x46, 0x85, 0x1b,
	0xbd, 0x0a, 0x73, 0xb6, 0xc3, 0x85, 0x6d, 0xa1, 0xac, 0xc0, 0xe7, 0xca, 0x4e, 0x1f, 0x05, 0x8a,
	0x49, 0x8f, 0x88, 0xf9, 0x20, 0x58, 0x17, 0x41, 0x6f, 0xc3, 0x8a, 0x6f, 0x33, 0xde, 0xd5, 0xf3,
	0xe9, 0xee, 0x7a, 0x43, 0x63, 0x0c, 0x7f, 0xfb, 0xc9, 0x9a, 0x2b, 0x4a, 0xe0, 0x51, 0x10, 0x61,
	0xa0, 0x3a, 0x66, 0xdb, 0x14, 0x0b, 0xba, 0xba, 0x81, 0x9a, 0xec, 0xbe, 0x38, 0x83, 0x68, 0xfd,
	0x6d, 0x03, 0xe6, 0x37, 0xd7, 0x6f, 0xee, 0xda, 0x6c, 0xbf, 0xd4, 0x84, 0x14, 0xf3, 0xa3, 0x77,
	0x72, 0x23, 0xb5, 0x26, 0x8c, 0xde, 0x13, 0xc6, 0xad, 0xb6, 0xa4, 0xf5, 0x5e, 0x73, 0xb5, 0xa2,
	0xb2, 0xa5, 0x51, 0x70, 0x0a, 0x88, 0xf6, 0xa0, 0x6d, 0x6a, 0xc2, 0xa4, 0xa7, 0x0d, 0x8c, 0x8a,
	0x7c, 0x45, 0x8a, 0x83, 0xb3, 0xa0, 0xc8, 0x82, 0x05, 0x97, 0x88, 0x95, 0x43, 0x02, 0xc7, 0x23,
	0x62, 0x91, 0xcc, 0x5c, 0x6c, 0xe1, 0x5c, 0x1c, 0x7a, 0x0b, 0x5a, 0x87, 0x1e, 0x1f, 0xdc, 0x96,
	0x1b, 0xd2, 0x9c, 0x9c, 0x80, 0x97, 0x2b, 0xb5, 0x42, 0x20, 0xe0, 0x14, 0x4b, 0xe8, 0xc2, 0x22,
	0x20, 0x89, 0x03, 0xb9, 0x4a, 0x5a, 0x38, 0x8d, 0x40, 0x36, 0x2c, 0x88, 0x40, 0x97, 0x7c, 0x10,
	0x0b, 0x51, 0xd3, 0x3a, 0x7f, 0x35, 0xf2, 0xc0, 0x80, 0xe0, 0x1c, 0xa4, 0x98, 0xef, 0xc3, 0x01,
	0x09, 0xb4, 0x41, 0x2b, 0xbf, 0xd1, 0x43, 0x29, 0x6f, 0xfa, 0x4c, 0x95, 0xc6, 0x6c, 0x55, 0xe3,
	0x33, 0x3d, 0x9a, 0x71, 0x06, 0x52, 0x1c, 0xc8, 0x61, 0x70, 0xe3, 0xb1, 0xc7, 0x3b, 0x6d, 0x75,
	0xcc, 0xab, 0x90, 0xd8, 0xd4, 0xd4, 0xb0, 0xb3, 0xce, 0x82, 0x3a, 0xe6, 0x75, 0xd0, 0xfa, 0xcb,
	0x1a, 0xb4, 0x85, 0x88, 0x1a, 0xb1, 0x3b, 0x03, 0x73, 0xdc, 0xa6, 0x7d, 0xad, 0x5d, 0xb7, 0xb0,
	0x0e, 0x21, 0x0c, 0x0d, 0x6e, 0xb3, 0x7d, 0x73, 0x6a, 0x7c, 0xaf, 0x52, 0xab, 0xf5, 0x5a, 0xc0,
	0x0a, 0x4a, 0x88, 0xbf, 0xd8, 0xb8, 0xb6, 0x6c, 0xa6, 0xec, 0xe6, 0x26, 0x4e, 0xc2, 0xd6, 0x73,
	0xd0, 0xb8, 0x71, 0x40, 0x02, 0xb9, 0x87, 0x31, 0xad, 0x8a, 0x1a, 0x65, 0xda, 0x84, 0xad, 0x6b,
	0x70, 0xe2, 0xc6, 0x63, 0xe2, 0xc4, 0x3c, 0xa4, 0x4a, 0x75, 0x45, 0x6b, 0x80, 0x18, 0xa1, 0x07,
	0x9e, 0x43, 0xd6, 0x1d, 0x47, 0xa8, 0x20, 0xf7, 0xd2, 0x35, 0x57, 0x92, 0x62, 0xfd, 0x10, 0xda,
	0x19, 0xfb, 0x4a, 0x2c, 0xba, 0xfe, 0x46, 0xf7, 0x7a, 0xec, 0xec, 0x27, 0xe6, 0xc5, 0xd5, 0xaa,
	0x46, 0x9b, 0x42, 0xc1, 0x29, 0x60, 0x89, 0x05, 0xf6, 0x71, 0x0d, 0x5a, 0x49, 0x56, 0x31, 0xf6,
	0x7b, 0x69, 0xd5, 0x2d, 0xac, 0x43, 0xe8, 0x21, 0x9c, 0xcd, 0x37, 0x5d, 0xaa, 0xe7, 0xc7, 0xb7,
	0x59, 0xc6, 0xa1, 0x58, 0x2f, 0x43, 0xe3, 0xa6, 0x1d, 0xf7, 0x49, 0xb9, 0xb6, 0x26, 0xa6, 0x80,
	0x12, 0xdb, 0xe7, 0x66, 0xdf, 0x6d, 0xe2, 0x24, 0x6c, 0xfd, 0xd5, 0x0c, 0xb4, 0x33, 0xbc, 0x85,
	0x10, 0x7b, 0x4a, 0xa2, 0xd0, 0x6c, 0x73, 0xe2, 0x5b, 0x95, 0x3f, 0xf0, 0x98, 0x30, 0x53, 0xf4,
	0x36, 0x67, 0xc2, 0xa2, 0x46, 0x97, 0x44, 0x7c, 0x20, 0x05, 0x60, 0x16, 0xab, 0x80, 0x88, 0xed,
	0x11, 0xee, 0x0c, 0x3a, 0xb3, 0x72, 0xcf, 0x50, 0x81, 0x12, 0x0b, 0xb0, 0x31, 0x5d, 0x0b, 0x70,
	0x6e, 0x02, 0x0b, 0x10, 0xbd, 0x05, 0x27, 0x19, 0x1b, 0xec, 0x50, 0xef, 0xc0, 0xe6, 0x24, 0x9d,
	0xa1, 0xf9, 0xe3, 0x60, 0x96, 0x21, 0xa0, 0x17, 0xe1, 0xb4, 0x17, 0x30, 0xe2, 0xc4, 0x94, 0xdc,
	0xee, 0x07, 0x21, 0x25, 0xb7, 0x42, 0x26, 0x4a, 0x69, 0x1a, 0xad, 0x3c, 0xd1, 0xfa, 0x9b, 0x1a,
	0x2c, 0x64, 0x89, 0x13, 0xb1, 0xf9, 0x0c, 0x36, 0xb7, 0xba, 0x6a, 0xa1, 0x68, 0xe1, 0x7e, 0xbd,
	0x32, 0x1f, 0xa3, 0x60, 0x70, 0x06, 0xb2, 0x94, 0x10, 0x15, 0x13, 0x19, 0x52, 0x87, 0xe8, 0xf5,
	0xad, 0x02, 0xd6, 0x3f, 0xd5, 0x00, 0x52, 0x10, 0x34, 0x80, 0x45, 0x01, 0xf3, 0x26, 0xdd, 0xcb,
	0x35, 0xee, 0x7a, 0xe5, 0xc6, 0x25, 0x48, 0x38, 0x0f, 0x2c, 0x4e, 0x05, 0xdb, 0x75, 0x29, 0x61,
	0x8c, 0xa8, 0x9d, 0xac, 0x85, 0xd3, 0x08, 0x21, 0xa7, 0x03, 0xb7, 0xc7, 0xee, 0x33, 0x42, 0xb5,
	0x7e, 0x98, 0x84, 0xad, 0x3f, 0x9c, 0x81, 0xc5, 0x1c, 0x34, 0xda, 0x86, 0xa5, 0x7d, 0xba, 0xb7,
	0x21, 0x2d, 0xec, 0x2a, 0x84, 0x44, 0xb1, 0xb4, 0x06, 0x7c, 0x93, 0x1c, 0x71, 0x7b, 0xaf, 0xca,
	0xf2, 0x2e, 0x96, 0x46, 0x17, 0xa0, 0xbd, 0x4f, 0xf7, 0xee, 0x6b, 0xa9, 0x37, 0x0c, 0x41, 0x26,
	0x4a, 0xf4, 0x78, 0x9f, 0xee, 0x61, 0x62, 0xfb, 0x86, 0x9f, 0x4e, 0xc2, 0xe8, 0x6d, 0x40, 0xfb,
	0xa6, 0xb3, 0x09, 0x31, 0xa0, 0x57, 0xdc, 0x93, 0xb3, 0x07, 0x25, 0x18, 0x42, 0x91, 0xde, 0xa7,
	0x7b, 0x5d, 0xb5, 0x19, 0xed, 0x50, 0x2f, 0x70, 0xbc, 0x28, 0xc7, 0x4b, 0x8f, 0x4b, 0xb6, 0x0e,
	0x61, 0x21, 0xcb, 0x67, 0x96, 0x30, 0x55, 0xf7, 0x61, 0x7e, 0x40, 0x6c, 0x97, 0x50, 0x73, 0x52,
	0xbd, 0x5a, 0x4d, 0x8a, 0x24, 0x06, 0x36, 0x58, 0xd6, 0x65, 0x98, 0x53, 0x51, 0xa5, 0x7a, 0x5c,
	0xb2, 0x6d, 0xd6, 0xb3, 0x46, 0xee, 0x63, 0x68, 0x49, 0x6d, 0xbc, 0x2f, 0x34, 0x8e, 0x24, 0xcb,
	0x4c, 0x76, 0x67, 0xbd, 0x0f, 0xf3, 0x6a, 0x8f, 0x67, 0x72, 0xa7, 0xab, 0xda, 0x5a, 0x75, 0x4d,
	0x85, 0x0d, 0x96, 0xf5, 0xb3, 0x1a, 0xcc, 0xdd, 0x0e, 0xa2, 0xf8, 0xcb, 0x7e, 0x07, 0x73, 0x0e,
	0x66, 0x85, 0x36, 0x97, 0x3f, 0x96, 0x16, 0xcc, 0xf8, 0x5e, 0x87, 0xd9, 0x3b, 0x5e, 0xb0, 0x3f,
	0x6e, 0x46, 0x98, 0x13, 0x46, 0xc9, 0x8c, 0xc8, 0x80, 0x11, 0x97, 0x99, 0x44, 0x5c, 0xac, 0xfb,
	0xb0, 0x72, 0x97, 0x0c, 0x43, 0xef, 0x43, 0xc9, 0x98, 0x69, 0x6b, 0x65, 0x19, 0x66, 0x06, 0x1e,
	0xd7, 0x54, 0x87, 0xf8, 0x1c, 0x3d, 0xb9, 0x25, 0xd7, 0x2a, 0xd6, 0xee, 0xbd, 0x74, 0x65, 0xa5,
	0x11, 0xd6, 0x1f, 0xd5, 0x60, 0x5e, 0xe1, 0x12, 0x53, 0xb6, 0x96, 0x96, 0xdd, 0x81, 0x86, 0xcc,
	0xaa, 0x97, 0xf7, 0x2b, 0xd5, 0x34, 0x40, 0x81, 0x80, 0x15, 0x90, 0xd0, 0x1c, 0x86, 0xf6, 0xe3,
	0xf5, 0x84, 0xc5, 0xd1, 0x21, 0xeb, 0x3f, 0xea, 0xd0, 0xbc, 0x6b, 0x0c, 0xff, 0x08, 0xda, 0x76,
	0x10, 0x84, 0xdc, 0x56, 0xe6, 0x8e, 0x92, 0x85, 0x7b, 0x95, 0x2a, 0x37, 0x98, 0x6b, 0xeb, 0x29,
	0xe0, 0x8d, 0x80, 0xd3, 0x23, 0x9c, 0xad, 0x02, 0xd9, 0x30, 0xe7, 0xdb, 0x7b, 0xc4, 0x37, 0x92,
	0x71, 0x7b, 0xb2, 0xca, 0xee, 0x48, 0x2c, 0x55, 0x8f, 0x06, 0x5e, 0xbd, 0x0a, 0xcb, 0xc5, 0x36,
	0x94, 0x8c, 0x78, 0xe9, 0x02, 0x7d, 0xa5, 0xfe, 0x52, 0x6d, 0xf5, 0x65, 0x68, 0x67, 0x60, 0x8f,
	0x53, 0xd4, 0xfa, 0x1d, 0x68, 0xdf, 0x25, 0x9c, 0x7a, 0x8e, 0x04, 0x78, 0xd2, 0xa2, 0xd6, 0x23,
	0x21, 0x1a, 0xa2, 0x18, 0x13, 0x47, 0x72, 0x44, 0xc3, 0x21, 0xe1, 0x03, 0x12, 0x9b, 0x09, 0xa9,
	0x76, 0x24, 0xef, 0x24, 0x30, 0x38, 0x03, 0x69, 0x3d, 0x0b, 0x8d, 0xbb, 0x31, 0x27, 0x8f, 0xcb,
	0xd6, 0x88, 0xf5, 0x3d, 0x58, 0x90, 0x89, 0xb7, 0x42, 0xdf, 0xf5, 0x82, 0xbe, 0x68, 0xee, 0x50,
	0x84, 0x8d, 0xf2, 0x27, 0x03, 0x42, 0xb4, 0x06, 0xa1, 0xef, 0x12, 0x6a, 0x98, 0x43, 0x15, 0xb2,
	0x3e, 0xa9, 0x41, 0x5b, 0x16, 0xd7, 0x8b, 0xe6, 0x5d, 0x98, 0x1f, 0x28, 0x20, 0xdd, 0x91, 0x6a,
	0x1c, 0x4f, 0xb6, 0x45, 0xd8, 0x20, 0x0a, 0xf0, 0x43, 0xdb, 0xe3, 0x02, 0xbc, 0x3e, 0x35, 0x70,
	0x8d, 0x68, 0xfd, 0xb8, 0x0d, 0x70, 0x2f, 0x74, 0x89, 0xee, 0xc8, 0x09, 0xa8, 0x7b, 0xae, 0x1e,
	0x83, 0xba, 0xe7, 0x26, 0x43, 0x57, 0xcf, 0x6c, 0x2f, 0x17, 0xa0, 0xed, 0x7a, 0x2c, 0xf2, 0xed,
	0xa3, 0xcc, 0xfa, 0xcf, 0x46, 0x25, 0x24, 0xec, 0x6c, 0x86, 0x84, 0xb5, 0x60, 0xc1, 0xd8, 0xc7,
	0xb2, 0x58, 0x43, 0xa6, 0xe5, 0xe2, 0x8a, 0x86, 0xf9, 0xdc, 0xd3, 0x30, 0xcc, 0xbf, 0x0d, 0xcb,
	0x8c, 0x87, 0x94, 0xb8, 0x26, 0xc7, 0xed, 0xcd, 0x0e, 0x92, 0x6d, 0x19, 0x89, 0x47, 0x97, 0xe1,
	0xd4, 0x61, 0x81, 0x74, 0x96, 0x6d, 0x3f, 0x29, 0xf3, 0x97, 0xa6, 0xa1, 0xaf, 0xc3, 0xa2, 0xa9,
	0xae, 0x2b, 0x37, 0xe1, 0x53, 0x32, 0x73, 0x3e, 0x52, 0x88, 0x5b, 0x34, 0xb0, 0x19, 0xd1, 0xd6,
	0xb9, 0x0a, 0xa0, 0xf3, 0x00, 0x7b, 0x61, 0x1c, 0xb8, 0x36, 0x3d, 0xba, 0xbd, 0xa9, 0x49, 0xab,
	0x4c, 0x4c, 0x96, 0xb0, 0x6e, 0xe5, 0x08, 0x6b, 0x74, 0x0b, 0x5a, 0x92, 0x7f, 0x23, 0xee, 0x3a,
	0xd7, 0xb6, 0xf5, 0x71, 0xe8, 0xa1, 0xb4, 0x30, 0x7a, 0x03, 0xa0, 0xe7, 0x05, 0x1e, 0x1b, 0x48,
	0xa8, 0xf6, 0xb1, 0xa1, 0x32, 0xa5, 0xd1, 0xf3, 0xb0, 0x42, 0x18, 0xf7, 0x86, 0x36, 0x27, 0x6e,
	0x72, 0x57, 0xd3, 0x91, 0x74, 0xe1, 0x68, 0x02, 0xfa, 0xb8, 0x06, 0x2b, 0x94, 0xb0, 0x30, 0xa6,
	0x0e, 0x61, 0x49, 0xf6, 0xd3, 0x52, 0xe4, 0x1f, 0x54, 0x74, 0xfc, 0x30, 0x82, 0xbd, 0x86, 0x8b,
	0xc0, 0x6a, 0x27, 0x1d, 0xad, 0x50, 0x4e, 0x4d, 0xe8, 0xde, 0xde, 0xd1, 0x64, 0x81, 0x0a, 0xc8,
	0x6b, 0x2d, 0x9b, 0x0c, 0xc3, 0x80, 0xb8, 0x9d, 0x45, 0x65, 0x06, 0x9a, 0x30, 0xea, 0xc2, 0x9c,
	0x27, 0x15, 0x8e, 0xce, 0x09, 0x39, 0x5c, 0xd5, 0xf4, 0x18, 0xa5, 0xb3, 0x60, 0x0d, 0x85, 0x1e,
	0xc0, 0x7c, 0x18, 0x73, 0x89, 0xba, 0x24, 0x51, 0xab, 0xb1, 0x0e, 0xdb, 0x0a, 0x03, 0x1b, 0x30,
	0xd1, 0x11, 0x67, 0xe0, 0xf9, 0x2e, 0x25, 0x41, 0x67, 0x59, 0x1a, 0x01, 0x49, 0x58, 0xc8, 0x6e,
	0x18, 0x73, 0x29, 0x70, 0x62, 0xe8, 0x58, 0x67, 0x45, 0x66, 0xc8, 0x47, 0x8a, 0x95, 0x3c, 0x08,
	0x19, 0x17, 0x01, 0xb9, 0x1a, 0xce, 0xa8, 0x95, 0x9c, 0x8d, 0x43, 0x1c, 0x56, 0x86, 0x45, 0xd5,
	0xa2, 0x73, 0x56, 0xf6, 0x63, 0xab, 0xe2, 0x39, 0x58, 0x40, 0xc3, 0xa3, 0x15, 0x08, 0x09, 0x3a,
	0xcd, 0x8e, 0x02, 0x67, 0x40, 0xc3, 0x20, 0x5f, 0xf5, 0x33, 0xb2, 0xea, 0x7b, 0xd5, 0xa5, 0xa8,
	0x0c, 0x15, 0x97, 0x57, 0xb6, 0xba, 0x09, 0x67, 0xca, 0xc5, 0xed, 0xf3, 0x8e, 0xc9, 0x99, 0xfc,
	0x09, 0xfb, 0xcc, 0xd8, 0x9a, 0xc5, 0x4e, 0x60, 0xce, 0x04, 0x05, 0x96, 0x6c, 0xe8, 0x27, 0x60,
	0x21, 0xeb, 0xef, 0x64, 0xfd, 0x10, 0xda, 0x99, 0x8b, 0x79, 0xf4, 0x1e, 0xb4, 0xc2, 0xee, 0x34,
	0x48, 0x9e, 0xed, 0x6e, 0x42, 0xf2, 0x24, 0x80, 0x25, 0x24, 0xcf, 0x7f, 0xd5, 0xa0, 0x95, 0x64,
	0x15, 0xc2, 0x47, 0x02, 0x37, 0x0a, 0xbd, 0xc0, 0xd0, 0x3c, 0x49, 0x38, 0x43, 0x00, 0xd5, 0x73,
	0x04, 0xd0, 0x36, 0x2c, 0xd9, 0xf2, 0x72, 0x20, 0xa5, 0x15, 0x66, 0x8e, 0x65, 0x19, 0x16, 0x4a,
	0x0b, 0x40, 0x96, 0xe6, 0x92, 0x80, 0xb3, 0xc7, 0x02, 0x2c, 0x94, 0xb6, 0xfe, 0xaf, 0x06, 0xf3,
	0x7a, 0x9d, 0x7d, 0xa9, 0x4d, 0x0e, 0x31, 0x05, 0x94, 0xb0, 0xd8, 0xe7, 0x46, 0x93, 0x56, 0x21,
	0x39, 0x6d, 0x8f, 0x3d, 0xbe, 0x11, 0xba, 0xe6, 0x4c, 0x4f, 0xc2, 0xd6, 0x00, 0x16, 0x45, 0x4b,
	0x7d, 0x9f, 0xf8, 0x5d, 0x4e, 0x22, 0x86, 0xde, 0x82, 0x06, 0x13, 0x1f, 0x13, 0x69, 0x42, 0xe9,
	0x15, 0x0a, 0x89, 0xb0, 0xc2, 0xb3, 0x7e, 0x51, 0x83, 0x56, 0x32, 0x28, 0xa5, 0x86, 0x8f, 0x64,
	0x7a, 0x7b, 0xb6, 0xe8, 0x40, 0xdd, 0x30, 0xbd, 0x32, 0x38, 0xc6, 0x02, 0x7d, 0x0f, 0x5a, 0xf2,
	0x63, 0xcb, 0xb8, 0xa8, 0x55, 0x9d, 0xab, 0x07, 0x06, 0x05, 0xa7, 0x80, 0x05, 0xa7, 0xb3, 0x46,
	0xd1, 0xe9, 0xcc, 0x7a, 0x0e, 0x1a, 0x3b, 0xa1, 0x7b, 0x73, 0x43, 0xb2, 0xbc, 0x7a, 0xb9, 0x26,
	0x2c, 0xaf, 0x59, 0xbe, 0xff, 0x30, 0x03, 0x90, 0xea, 0xb7, 0xa5, 0xbd, 0x7e, 0xbb, 0x60, 0x68,
	0x5c, 0xab, 0x6a, 0x68, 0x18, 0x6d, 0xde, 0xd8, 0x17, 0xa2, 0xb6, 0x01, 0xf1, 0x23, 0x3d, 0x68,
	0xf2, 0x3b, 0xa1, 0xf6, 0x67, 0x33, 0xd4, 0xfe, 0x0e, 0x34, 0xfa, 0x76, 0xdc, 0x27, 0x9a, 0x20,
	0xa9, 0x66, 0xd3, 0x49, 0x12, 0x16, 0x2b, 0x20, 0x31, 0x33, 0x03, 0x43, 0x1f, 0x68, 0x3d, 0xb0,
	0xda, 0xcc, 0x24, 0x24, 0x04, 0x4e, 0x01, 0xc5, 0xd9, 0xea, 0xa8, 0x2b, 0x7a, 0xcd, 0x50, 0x7e,
	0xaf, 0xe2, 0x3d, 0x84, 0xc4, 0xc0, 0x06, 0xcc, 0xfa, 0x1a, 0xb4, 0x33, 0x8e, 0x55, 0x62, 0xa8,
	0x92, 0x4b, 0xeb, 0x16, 0x96, 0xdf, 0xd6, 0x8f, 0xea, 0xb0, 0x6c, 0x0e, 0x87, 0xec, 0xbd, 0x83,
	0xed, 0x64, 0x3c, 0x66, 0x74, 0x48, 0x9c, 0xc7, 0x43, 0x42, 0xfb, 0xc9, 0x66, 0xae, 0xa5, 0x3a,
	0x1f, 0x29, 0xc4, 0x67, 0x68, 0x07, 0x5e, 0x8f, 0x30, 0xb3, 0x6e, 0x93, 0xb0, 0xd0, 0xc0, 0x18,
	0xe1, 0xdb, 0x87, 0x01, 0xa1, 0xc9, 0xdd, 0xa2, 0xbe, 0xda, 0x1d, 0x4d, 0x90, 0xba, 0xb1, 0xba,
	0x88, 0x4d, 0xae, 0xf4, 0xb4, 0xdc, 0x8e, 0xc4, 0x8b, 0xbc, 0x3d, 0xdb, 0xf3, 0x63, 0x4a, 0xd2,
	0xbc, 0x8a, 0xc0, 0x1a, 0x89, 0x97, 0x44, 0xa8, 0x6f, 0xf7, 0x59, 0x67, 0x5e, 0x33, 0xda, 0x22,
	0x60, 0xfd, 0x7b, 0x0d, 0x16, 0x31, 0xe1, 0xf4, 0x28, 0xe9, 0xc9, 0x16, 0x34, 0x7c, 0x79, 0xb3,
	0x5b, 0xab, 0xe8, 0x1e, 0xa4, 0x8a, 0x2b, 0xc7, 0x49, 0x4e, 0xcd, 0x75, 0xb7, 0x1a, 0xb5, 0x6c,
	0x94, 0x90, 0x80, 0x3d, 0xe5, 0xb0, 0xa4, 0x0f, 0x93, 0x6a, 0x12, 0xa0, 0x9d, 0x9e, 0xb0, 0x01,
	0xb3, 0x8e, 0x00, 0x52, 0xd7, 0x48, 0xf4, 0x7d, 0x68, 0xb2, 0x2b, 0xb9, 0xb3, 0xb6, 0xe2, 0x2d,
	0x9b, 0x06, 0xc1, 0x09, 0x5c, 0xc9, 0x49, 0xfb, 0xcb, 0x3a, 0x34, 0x4d, 0xc6, 0x4a, 0x07, 0xad,
	0xdc, 0xfd, 0xfb, 0xa9, 0x3b, 0x95, 0x0e, 0x09, 0x2c, 0xc3, 0xb2, 0x6b, 0xd1, 0x49, 0xc2, 0x65,
	0x87, 0x73, 0x63, 0xda, 0x87, 0xf3, 0xdc, 0x24, 0x87, 0xb3, 0x38, 0x13, 0x68, 0xe8, 0x93, 0x75,
	0x7c, 0x4f, 0xdb, 0x5a, 0x26, 0x28, 0xa4, 0x24, 0x66, 0xa4, 0xbb, 0xf9, 0xe6, 0x06, 0x25, 0x2e,
	0xd3, 0x17, 0x0a, 0xd9, 0x28, 0x8b, 0xc0, 0x89, 0xae, 0x43, 0xbd, 0x88, 0x27, 0x2b, 0xf5, 0x55,
	0xe9, 0x4c, 0xc6, 0x6d, 0x21, 0x8a, 0x7a, 0x4a, 0xbf, 0x32, 0x86, 0x0e, 0x56, 0x99, 0x70, 0x9a,
	0x5f, 0xfa, 0x21, 0xc9, 0x85, 0x9f, 0xf8, 0x21, 0xc9, 0x90, 0xf5, 0x06, 0x2c, 0x77, 0xc9, 0xd0,
	0x8e, 0x06, 0xf2, 0x06, 0x43, 0x19, 0xfd, 0xe7, 0xa0, 0xc5, 0x4c, 0x9c, 0x71, 0x67, 0x4c, 0x22,
	0x44, 0xa7, 0x14, 0x13, 0x61, 0x88, 0x7c, 0x13, 0xb4, 0xf6, 0x60, 0x21, 0xc1, 0x12, 0xe6, 0x2e,
	0x86, 0x25, 0x27, 0x43, 0x4d, 0x0b, 0xb3, 0xfa, 0xb8, 0x3e, 0x70, 0x45, 0x00, 0xeb, 0x57, 0x35,
	0x58, 0x4a, 0x2a, 0xd1, 0x0a, 0xe9, 0xc3, 0x22, 0x03, 0x72, 0xa3, 0xe2, 0x7d, 0x72, 0x7e, 0x1c,
	0x52, 0x16, 0xe4, 0x61, 0x91, 0x05, 0x99, 0x56, 0x05, 0x46, 0x71, 0xfe, 0x75, 0x0d, 0x9a, 0xc9,
	0x05, 0xf6, 0x16, 0x34, 0xe4, 0xa6, 0x5e, 0x7d, 0x27, 0x92, 0xc5, 0x05, 0x8e, 0x34, 0xad, 0x2b,
	0x3b, 0x3c, 0xaa, 0xe2, 0xe8, 0x3a, 0xcc, 0x90, 0xc0, 0xd5, 0x7b, 0xd5, 0xf1, 0x51, 0x44, 0x61,
	0xe9, 0xb0, 0x16, 0xd2, 0xa1, 0xcd, 0xf5, 0xd9, 0xad, 0x43, 0xd6, 0xa7, 0x35, 0x98, 0xeb, 0xc6,
	0x7b, 0x62, 0xe3, 0xfc, 0x10, 0x4e, 0x16, 0x49, 0x8d, 0x54, 0x62, 0x6e, 0x4d, 0xc5, 0x11, 0x11,
	0x93, 0x1e, 0x2e, 0xab, 0x24, 0xef, 0xf3, 0x51, 0x9f, 0xb2, 0xcf, 0x87, 0xf5, 0xf1, 0x0c, 0x80,
	0xea, 0xe4, 0x76, 0xc4, 0xcb, 0xf5, 0x28, 0x0b, 0x16, 0xcc, 0x2b, 0x98, 0x7b, 0x29, 0xe7, 0x95,
	0x8b, 0x13, 0x3a, 0x1d, 0x11, 0x96, 0x9c, 0xda, 0x59, 0xd5, 0x38, 0x66, 0x62, 0x44, 0x7a, 0x46,
	0xfd, 0x57, 0x4e, 0x1f, 0x59, 0xf5, 0xfd, 0xeb, 0xb0, 0x98, 0x84, 0xb6, 0x3c, 0xdf, 0xdc, 0xf9,
	0xe4, 0x23, 0xd1, 0x37, 0xe1, 0x44, 0xfe, 0xb6, 0x5a, 0x6f, 0x5d, 0x85, 0x58, 0x31, 0xa3, 0x2e,
	0x3d, 0xc2, 0x71, 0xa0, 0x37, 0x2f, 0x1d, 0x12, 0x3d, 0x11, 0x39, 0x09, 0xdd, 0x54, 0xa9, 0x2d,
	0x99, 0x9a, 0x8b, 0x13, 0x65, 0xb5, 0xd6, 0x08, 0x4a, 0x1a, 0xb4, 0xce, 0xf7, 0x1e, 0x9c, 0x08,
	0xf3, 0xea, 0x82, 0xe2, 0x80, 0x5e, 0x7c, 0x42, 0xe7, 0xa8, 0x5c, 0x59, 0x5c, 0xc0, 0xb2, 0x4e,
	0xc2, 0x4a, 0x37, 0x8e, 0x22, 0xdf, 0x23, 0x6e, 0xa2, 0x33, 0x5b, 0xbf, 0x0d, 0x4b, 0x5d, 0xe5,
	0x66, 0x96, 0xec, 0xb3, 0x9f, 0xe1, 0x45, 0x6c, 0xfd, 0xab, 0xd8, 0x7e, 0xf2, 0x56, 0x31, 0x7a,
	0x58, 0xdc, 0x2e, 0xab, 0x1a, 0x1e, 0xd9, 0xcd, 0x33, 0xbb, 0xe3, 0xee, 0x18, 0x7e, 0x78, 0x92,
	0x6b, 0x0b, 0x49, 0xc1, 0x6a, 0x6e, 0x59, 0xec, 0xa2, 0xa7, 0xcb, 0x8d, 0xfb, 0xbd, 0xd1, 0xce,
	0x6c, 0x4e, 0xd6, 0x19, 0xcd, 0x57, 0x64, 0xfa, 0xf3, 0x20, 0xdf, 0x9f, 0x6b, 0xd5, 0xfb, 0xa3,
	0xb1, 0x75, 0xaf, 0xfe, 0xbe, 0x06, 0xed, 0xdd, 0xdd, 0x3b, 0x89, 0x4a, 0xf7, 0x5d, 0x38, 0xc3,
	0x94, 0x23, 0xe0, 0x7a, 0x8f, 0x13, 0xba, 0x11, 0x0e, 0x23, 0x9f, 0x24, 0xd3, 0xda, 0xc0, 0x63,
	0x52, 0xd1, 0x77, 0xe0, 0x64, 0x36, 0xa5, 0xab, 0xd4, 0x4f, 0xd9, 0xda, 0x06, 0x2e, 0x4b, 0x2a,
	0x96, 0xd8, 0x52, 0x4a, 0xa8, 0x7e, 0x8d, 0x54, 0x96, 0x64, 0xbd, 0x0c, 0xed, 0xcc, 0x7b, 0x33,
	0xa1, 0xd1, 0x3a, 0xe1, 0x30, 0xa2, 0x84, 0x31, 0x2f, 0x0c, 0xee, 0x90, 0x03, 0xe2, 0xeb, 0x46,
	0x8e, 0xc4, 0x5b, 0xbf, 0x3e, 0x0d, 0xcd, 0x44, 0x58, 0x7f, 0xf3, 0xbc, 0xdb, 0x52, 0xc6, 0xb3,
	0xf1, 0x54, 0x18, 0xcf, 0xb9, 0x69, 0x32, 0x9e, 0x0c, 0x16, 0x82, 0xd0, 0x25, 0x46, 0x9f, 0x91,
	0x46, 0x48, 0xfb, 0xf2, 0xf6, 0x44, 0x23, 0xa2, 0x48, 0x41, 0x8d, 0xa8, 0xa8, 0xe4, 0x5c, 0x25,
	0xe8, 0x25, 0x68, 0xda, 0xbd, 0x9e, 0x17, 0x78, 0xfc, 0x48, 0x3b, 0xd8, 0x9d, 0x2b, 0x53, 0xb8,
	0xd6, 0x75, 0x1e, 0x9c, 0xe4, 0x16, 0x46, 0x43, 0xe2, 0xee, 0xdc, 0x9a, 0xc0, 0x68, 0x30, 0x37,
	0x87, 0x19, 0xef, 0x67, 0x71, 0x5e, 0x48, 0xd2, 0x5a, 0xbf, 0x25, 0xd3, 0x21, 0xf4, 0xb6, 0xa1,
	0x6c, 0xda, 0x72, 0x68, 0xae, 0x57, 0xe6, 0xab, 0x12, 0x16, 0x48, 0x73, 0x36, 0x79, 0x7d, 0x79,
	0xe1, 0x98, 0xfa, 0xf2, 0xbb, 0x30, 0xc7, 0xa4, 0xfa, 0x2d, 0x19, 0xf7, 0xf6, 0xe5, 0x8d, 0x6a,
	0x9b, 0x60, 0x4e, 0x83, 0xc7, 0x1a, 0x12, 0xd9, 0xd0, 0x34, 0xdc, 0xbf, 0xa6, 0xed, 0xab, 0x29,
	0x94, 0x45, 0x63, 0x1e, 0x27, 0xb0, 0x08, 0xc3, 0x8c, 0x6b, 0xf7, 0x35, 0x7d, 0x7f, 0xad, 0xb2,
	0xd3, 0xa0, 0x01, 0x16, 0x60, 0xe8, 0xfd, 0xd4, 0x43, 0x7b, 0x79, 0x92, 0x93, 0x21, 0x7f, 0xde,
	0xa6, 0x7e, 0xde, 0x2f, 0xc2, 0xfc, 0x41, 0xe8, 0xc7, 0x43, 0x4d, 0xfe, 0xb7, 0x2f, 0xaf, 0x96,
	0x4d, 0xd7, 0x03, 0x99, 0x05, 0x9b, 0xac, 0xe8, 0x11, 0x9c, 0x10, 0xc2, 0x9b, 0xcc, 0x22, 0xeb,
	0xa0, 0x09, 0x24, 0xe9, 0x3e, 0x13, 0x47, 0x81, 0x11, 0x88, 0x02, 0x32, 0x7a, 0x1f, 0x9a, 0xcc,
	0x73, 0x89, 0x63, 0x53, 0xd6, 0x39, 0x39, 0xb5, 0x5a, 0x12, 0x4c, 0x14, 0xc2, 0x52, 0xf2, 0x56,
	0x52, 0xbf, 0x4e, 0x3d, 0x35, 0xcd, 0xd7, 0xa9, 0x45, 0x74, 0xd4, 0x83, 0xd3, 0xca, 0xd9, 0xbb,
	0xe8, 0x58, 0x7f, 0xba, 0xa2, 0xb6, 0x5f, 0x0e, 0x87, 0x06, 0xb0, 0x48, 0xb3, 0x74, 0x8b, 0xbc,
	0xb8, 0xa9, 0x3a, 0x7a, 0x39, 0xe2, 0x06, 0xe7, 0x81, 0x85, 0x65, 0x1d, 0xe9, 0xdd, 0xc0, 0x63,
	0x43, 0x79, 0xef, 0x33, 0x83, 0xb3, 0x51, 0xe8, 0x1a, 0xb4, 0x79, 0xe8, 0x13, 0xaa, 0xdd, 0x31,
	0x3a, 0x72, 0x1e, 0xcf, 0x97, 0x89, 0xda, 0x6e, 0x92, 0x0d, 0x67, 0x8b, 0x08, 0x4d, 0xda, 0x3c,
	0x72, 0xa0, 0x52, 0x5d, 0x7f, 0x46, 0x69, 0xd2, 0xb9, 0x48, 0xf4, 0x3c, 0xac, 0x44, 0xd4, 0x0b,
	0xa9, 0xc7, 0x8f, 0x36, 0x7c, 0x9b, 0x31, 0x99, 0x73, 0x55, 0x3d, 0x7f, 0x18, 0x49, 0x10, 0x87,
	0xb6, 0x89, 0xec, 0x3c, 0x2b, 0x4f, 0xfe, 0x24, 0x3c, 0xc6, 0xb9, 0xf6, 0xdc, 0x38, 0xe7, 0x5a,
	0x74, 0x1d, 0xce, 0xd9, 0x31, 0x0f, 0xa5, 0x73, 0x52, 0x37, 0x97, 0xbc, 0x1b, 0xee, 0x93, 0xa0,
	0x73, 0x41, 0xee, 0xc0, 0x9f, 0x99, 0x07, 0x3d, 0x84, 0x26, 0xd1, 0x2e, 0xbe, 0x9d, 0xaf, 0x4d,
	0xb0, 0x05, 0xe6, 0xfd, 0x84, 0x71, 0x02, 0x8a, 0x5e, 0x87, 0xf6, 0x20, 0x64, 0x7c, 0xdd, 0xf7,
	0x6c, 0x46, 0x58, 0xe7, 0x2b, 0x72, 0x1a, 0x4a, 0x37, 0xe8, 0x5b, 0x26, 0x1b, 0xce, 0x96, 0x40,
	0x3b, 0x92, 0xae, 0x89, 0xe5, 0x30, 0x86, 0x01, 0x27, 0x8f, 0x79, 0xe7, 0xbc, 0x6c, 0xe8, 0x37,
	0xcb, 0x40, 0x76, 0x42, 0xb7, 0x9b, 0xcf, 0x8d, 0x8b, 0xc5, 0x85, 0xed, 0x12, 0x85, 0x6e, 0x37,
	0x22, 0xce, 0x8e, 0xcd, 0x9d, 0x41, 0xe7, 0xab, 0xca, 0x0a, 0xcb, 0xc6, 0x09, 0x4d, 0x61, 0xa8,
	0xbc, 0x48, 0x3a, 0xcf, 0x4d, 0xa0, 0x29, 0x68, 0x4f, 0x14, 0x6c, 0xc0, 0x50, 0x00, 0x4b, 0x85,
	0x1b, 0xbd, 0xce, 0xd7, 0x27, 0xd9, 0x64, 0xf3, 0x58, 0xb8, 0x08, 0xae, 0xfa, 0x21, 0x1d, 0xa5,
	0x3a, 0xdf, 0x98, 0xa8, 0x1f, 0x12, 0x03, 0x1b, 0x30, 0xd4, 0x81, 0x79, 0xee, 0x0d, 0x49, 0x18,
	0xf3, 0xce, 0x37, 0x15, 0xe7, 0xa5, 0x83, 0xab, 0xaf, 0xc3, 0xca, 0x88, 0xe6, 0x72, 0x2c, 0xbf,
	0x9f, 0x3f, 0x13, 0xfa, 0x7d, 0x46, 0x13, 0x3c, 0xae, 0xee, 0xfb, 0x3c, 0xac, 0xe8, 0xdf, 0x55,
	0x88, 0x83, 0xd3, 0x8f, 0x93, 0xe7, 0x9b, 0x4d, 0x3c, 0x9a, 0x20, 0x84, 0xc1, 0x51, 0x8f, 0xff,
	0x94, 0x2f, 0x85, 0xa2, 0x1f, 0x73, 0x71, 0xd6, 0xef, 0xc1, 0x62, 0x6e, 0x2b, 0x9f, 0x8c, 0xa3,
	0x5b, 0x03, 0x34, 0xf4, 0x28, 0x0d, 0xa9, 0x3a, 0xe2, 0xee, 0x8a, 0xc5, 0xc8, 0xb4, 0xe3, 0x77,
	0x49, 0x8a, 0xf5, 0xc7, 0x75, 0x68, 0x25, 0x96, 0x6c, 0xe2, 0x05, 0x5c, 0xcb, 0x78, 0x01, 0xaf,
	0x42, 0xf3, 0x11, 0x0b, 0x83, 0x9d, 0xd4, 0x3b, 0x38, 0x09, 0xcb, 0xb4, 0x0f, 0xb6, 0x3c, 0x9f,
	0xa7, 0x4e, 0xb7, 0x26, 0x2c, 0x5f, 0x1d, 0x1e, 0x90, 0xc4, 0xf6, 0x57, 0x01, 0x74, 0x0e, 0x5a,
	0x09, 0x57, 0xa0, 0xf9, 0x87, 0x34, 0x02, 0xed, 0x41, 0x93, 0x69, 0xf3, 0x5a, 0xeb, 0xd0, 0x5b,
	0x15, 0xd5, 0x83, 0x82, 0x8d, 0x8e, 0x13, 0xdc, 0xec, 0x25, 0x5b, 0x23, 0x77, 0xc9, 0x66, 0xfd,
	0x6f, 0x0d, 0xe6, 0x1f, 0x10, 0x2a, 0x5d, 0xdb, 0x3b, 0x30, 0x7f, 0xa0, 0x3e, 0xcd, 0x05, 0xb5,
	0x0e, 0x8a, 0x1e, 0xec, 0xc5, 0x9e, 0xef, 0x6e, 0xa6, 0xe2, 0x91, 0x46, 0x88, 0xd4, 0xbe, 0x38,
	0xee, 0x87, 0x43, 0xcf, 0xdc, 0x66, 0xa4, 0x11, 0x42, 0x81, 0xed, 0x7b, 0x7c, 0xd7, 0xee, 0x1b,
	0x0a, 0x4b, 0x85, 0x24, 0x75, 0xe3, 0xf1, 0x5d, 0x4a, 0xa4, 0xa5, 0x9b, 0x38, 0x17, 0x65, 0xe3,
	0x24, 0x72, 0xa8, 0x9b, 0xa7, 0x69, 0x97, 0x34, 0x42, 0xba, 0x45, 0x84, 0xc3, 0xc8, 0xf3, 0xf5,
	0x9d, 0x50, 0x0b, 0x27, 0x61, 0x79, 0x2c, 0xf8, 0x36, 0xef, 0x85, 0x74, 0x68, 0x5e, 0x92, 0x99,
	0xb0, 0xf5, 0x5b, 0xb0, 0xa8, 0xe4, 0x61, 0xc3, 0xb7, 0xbd, 0xe1, 0xe7, 0x5c, 0xe6, 0xfd, 0x69,
	0x1d, 0x9a, 0x4f, 0xe9, 0xd5, 0xe7, 0xfd, 0xdc, 0xab, 0xcf, 0x29, 0x3c, 0x31, 0x54, 0x2f, 0x3e,
	0xdf, 0x2d, 0xbc, 0xf8, 0xdc, 0x98, 0xf0, 0x36, 0x37, 0xf7, 0xda, 0xf3, 0x93, 0x1a, 0x9c, 0x32,
	0x49, 0xf2, 0xbd, 0xcb, 0x75, 0x2f, 0x90, 0x5c, 0xef, 0x74, 0x87, 0xc6, 0xce, 0x0d, 0xcd, 0xdd,
	0x89, 0x7a, 0x90, 0x6d, 0x66, 0xe6, 0x49, 0xf5, 0x27, 0x35, 0xe8, 0x94, 0x65, 0x99, 0xfa, 0xfb,
	0xd5, 0x87, 0xf9, 0xf7, 0xab, 0xb7, 0xa7, 0xd6, 0x19, 0xf3, 0x8e, 0xf5, 0x5f, 0xc6, 0xf4, 0x44,
	0x3e, 0x34, 0xdd, 0x31, 0x5b, 0x52, 0x6d, 0x02, 0x12, 0x4c, 0xa2, 0x9a, 0xed, 0xac, 0x0b, 0x73,
	0x4c, 0xb2, 0xb2, 0x7a, 0x76, 0x5e, 0xad, 0xb8, 0x5d, 0x09, 0x08, 0xac, 0xa1, 0xac, 0x9f, 0xd4,
	0x60, 0xe1, 0xa9, 0xbd, 0x20, 0xee, 0xe6, 0x67, 0xe0, 0xb5, 0x89, 0x66, 0xc0, 0x8c, 0xfa, 0xcf,
	0x4e, 0xa5, 0x2d, 0xee, 0xaa, 0x75, 0xd7, 0x32, 0x47, 0xa6, 0x71, 0xa4, 0x78, 0x6d, 0x32, 0x0a,
	0x27, 0xc5, 0x2b, 0x90, 0xd8, 0xf5, 0x11, 0x12, 0xfb, 0xe9, 0xf2, 0x53, 0xe5, 0x8a, 0xf4, 0x6c,
	0x65, 0x45, 0xfa, 0xdc, 0x31, 0x15, 0xe9, 0xaf, 0x3c, 0x0d, 0x45, 0x3a, 0x63, 0x36, 0x37, 0x9e,
	0xdc, 0x6c, 0xfe, 0x01, 0x9c, 0x3a, 0x48, 0x0f, 0x8f, 0xdd, 0x64, 0xc2, 0xd5, 0x5b, 0xd0, 0x6f,
	0x95, 0xaa, 0xd0, 0xe2, 0xbc, 0x62, 0x9c, 0x04, 0x3c, 0x73, 0xec, 0xe0, 0x52, 0x98, 0xa2, 0x19,
	0x36, 0x3f, 0x6a, 0x86, 0xfd, 0x7e, 0x0d, 0x4e, 0xdb, 0x65, 0xbf, 0x53, 0xd1, 0x9c, 0xd5, 0x1b,
	0x93, 0xb9, 0x16, 0x65, 0x11, 0x71, 0x79, 0x45, 0xd9, 0x27, 0xe7, 0xad, 0xfc, 0x93, 0xf3, 0xc3,
	0x02, 0x6f, 0x07, 0x72, 0x54, 0xba, 0x13, 0x1f, 0x6d, 0xc7, 0xe2, 0xee, 0xda, 0xc7, 0xe2, 0xee,
	0x0a, 0x66, 0xed, 0xc2, 0xf1, 0xcd, 0xda, 0x5d, 0x58, 0xf6, 0x86, 0x76, 0x9f, 0xec, 0xc4, 0xbe,
	0xaf, 0x6e, 0xb0, 0x59, 0x67, 0x51, 0xc2, 0x94, 0x5e, 0xd8, 0xde, 0x09, 0x1d, 0xdb, 0x2f, 0xbe,
	0x1d, 0x1f, 0x41, 0x10, 0x92, 0x20, 0xdd, 0x33, 0x09, 0x17, 0x43, 0x23, 0xf9, 0xae, 0x26, 0xce,
	0x46, 0x09, 0xed, 0xc8, 0x0d, 0x98, 0x76, 0x98, 0x58, 0x52, 0xda, 0x51, 0x12, 0x81, 0xae, 0xca,
	0x54, 0xfd, 0x40, 0x4d, 0xf1, 0x4e, 0x17, 0xc6, 0x18, 0x78, 0x9b, 0xf7, 0xcc, 0xf3, 0xb8, 0xb4,
	0x48, 0xe6, 0x69, 0xee, 0x4a, 0xee, 0x69, 0xee, 0x4b, 0x70, 0x96, 0x73, 0xbf, 0x9b, 0xe5, 0xe6,
	0xb5, 0xf7, 0xb0, 0xf4, 0xc9, 0x6e, 0xe0, 0x71, 0xc9, 0x92, 0xe5, 0xe6, 0x7e, 0x42, 0x65, 0x9c,
	0x9f, 0x84, 0xe5, 0x4e, 0xaf, 0x2b, 0x70, 0x16, 0x14, 0xbd, 0x38, 0x8e, 0x98, 0x39, 0x29, 0x57,
	0xd2, 0x18, 0x9a, 0x25, 0x4b, 0x22, 0x9c, 0x2a, 0x90, 0x08, 0x23, 0xa4, 0xc5, 0xe9, 0x32, 0xd2,
	0x62, 0x47, 0x7a, 0x20, 0xdf, 0xdc, 0xd0, 0x04, 0x4d, 0xb5, 0x63, 0x56, 0xba, 0x96, 0x61, 0x05,
	0x84, 0x2e, 0xc3, 0xa9, 0x28, 0x74, 0x77, 0x46, 0x98, 0x90, 0xb3, 0xca, 0x91, 0xbd, 0x2c, 0x4d,
	0xee, 0x1e, 0x69, 0xbc, 0x74, 0xdb, 0x6e, 0xe0, 0x6c, 0x54, 0x91, 0x3d, 0x78, 0x66, 0x1a, 0xec,
	0xc1, 0xea, 0x74, 0xd9, 0x83, 0x67, 0x4b, 0xd8, 0x03, 0x17, 0x4e, 0x46, 0xa1, 0xbb, 0xe9, 0x31,
	0x1a, 0xcb, 0x7f, 0xb0, 0x5d, 0x8f, 0xdd, 0x3e, 0xe1, 0x92, 0x68, 0x68, 0x5f, 0xbe, 0x9c, 0xad,
	0x59, 0xfd, 0xf7, 0x71, 0x4d, 0xff, 0xf7, 0x51, 0x4a, 0x77, 0xa1, 0x94, 0xd4, 0x01, 0xcb, 0xe0,
	0xb2, 0x1c, 0xc5, 0x85, 0x69, 0x72, 0x14, 0xc2, 0xbe, 0x18, 0xc4, 0xdc, 0x0d, 0x0f, 0x03, 0xc9,
	0x09, 0x09, 0xfb, 0x42, 0x87, 0xc7, 0x5d, 0xdf, 0x5b, 0x5f, 0xc4, 0xf5, 0x7d, 0x09, 0x77, 0xf2,
	0xdc, 0xd3, 0xe4, 0x4e, 0x06, 0xb0, 0x78, 0x90, 0x35, 0xbc, 0x34, 0x53, 0x53, 0x8d, 0xcd, 0xcc,
	0x99, 0x70, 0x38, 0x0f, 0x3c, 0xca, 0x9b, 0x7e, 0xe3, 0x29, 0xf1, 0xa6, 0x93, 0xb3, 0x33, 0xff,
	0xb8, 0x00, 0x27, 0x0a, 0x7f, 0x1f, 0x49, 0x5e, 0x9a, 0xd4, 0xb2, 0x2f, 0x4d, 0x72, 0xef, 0x45,
	0xea, 0xd3, 0x7b, 0x2f, 0x32, 0x33, 0xfd, 0xf7, 0x22, 0xcb, 0xe3, 0xde, 0x8b, 0x64, 0x5e, 0xc3,
	0xcc, 0xe6, 0x5f, 0xc3, 0x5c, 0x84, 0x25, 0x73, 0x63, 0x4b, 0xf4, 0x4b, 0x06, 0xc5, 0x08, 0x14,
	0xa3, 0x91, 0x0b, 0x8d, 0x40, 0xa6, 0xcf, 0x4d, 0xf0, 0x20, 0x30, 0x3f, 0xe2, 0x52, 0xbd, 0xd0,
	0x0f, 0xf5, 0x14, 0x38, 0x7a, 0x05, 0x3a, 0x61, 0xaf, 0xe7, 0x87, 0xb6, 0x9b, 0xbe, 0x48, 0x31,
	0x4c, 0x84, 0xf2, 0xbe, 0x18, 0x9b, 0x8e, 0xfe, 0xa0, 0x06, 0x4b, 0xf9, 0x87, 0x49, 0xac, 0xd3,
	0x92, 0x8d, 0x7d, 0x7b, 0x1a, 0x8d, 0xed, 0xe6, 0xa1, 0x55, 0xb3, 0x8b, 0x15, 0x22, 0x0c, 0x67,
	0xa2, 0x32, 0xc5, 0x93, 0xe9, 0xcb, 0xd4, 0xcf, 0xd2, 0x76, 0xc7, 0x94, 0xcc, 0x5e, 0xf7, 0x36,
	0xa7, 0x79, 0xdd, 0x9b, 0xff, 0xaf, 0xcd, 0xe2, 0xb4, 0xff, 0x6b, 0x83, 0x7e, 0x54, 0xfa, 0x4c,
	0x49, 0xa9, 0x7a, 0xef, 0x4c, 0x63, 0x4a, 0x9e, 0xfc, 0xa9, 0xd2, 0x47, 0x35, 0x58, 0x55, 0x53,
	0x55, 0xf6, 0xbb, 0x37, 0x7d, 0xad, 0x39, 0x05, 0x2e, 0xe8, 0x33, 0x2a, 0x41, 0x7c, 0x74, 0xdf,
	0x5f, 0x9a, 0xc0, 0x76, 0x28, 0x7f, 0x68, 0x53, 0xac, 0x62, 0xf5, 0x48, 0xbd, 0x5a, 0x1c, 0xfb,
	0x70, 0xf5, 0x7e, 0x76, 0x8b, 0xac, 0xfa, 0xae, 0x34, 0x5d, 0x8c, 0xd9, 0x47, 0xb3, 0x1f, 0xd5,
	0xe0, 0x54, 0xd9, 0xaa, 0x29, 0x69, 0x45, 0x37, 0xdf, 0x8a, 0x09, 0x2d, 0xf8, 0x4c, 0x1b, 0xa6,
	0xf3, 0xc2, 0xe8, 0xbf, 0x67, 0x33, 0xac, 0x03, 0x27, 0xd1, 0x6f, 0xa0, 0x23, 0x4b, 0xee, 0x17,
	0x4c, 0x8d, 0xa7, 0xf5, 0x0b, 0xa6, 0xb9, 0xcf, 0xfb, 0x05, 0xd3, 0xfc, 0xd3, 0xfb, 0x05, 0x53,
	0x73, 0xec, 0x2f, 0x98, 0x5a, 0x5f, 0xd8, 0x2f, 0x98, 0xac, 0x9f, 0xd6, 0x60, 0xf9, 0xcb, 0xfd,
	0xd3, 0xcc, 0x9f, 0x66, 0xb8, 0xea, 0xa7, 0xf6, 0xb7, 0xcc, 0x77, 0xf3, 0xdc, 0xe2, 0x8d, 0xe9,
	0x68, 0xec, 0x9a, 0x63, 0xbc, 0x0b, 0x27, 0x4b, 0x94, 0xf9, 0x71, 0x9e, 0xb0, 0xb9, 0x6b, 0xb7,
	0x7a, 0xc9, 0xb5, 0xdb, 0xaf, 0x4a, 0x06, 0xe4, 0x8b, 0xfc, 0xe9, 0x61, 0xf1, 0x17, 0x7e, 0xf5,
	0xa9, 0xfc, 0xc2, 0x6f, 0x11, 0xda, 0x99, 0xff, 0xba, 0x5f, 0x3f, 0xf3, 0xf3, 0x4f, 0xcf, 0xd7,
	0x7e, 0xf9, 0xe9, 0xf9, 0xda, 0x7f, 0x7e, 0x7a, 0xbe, 0xf6, 0x4e, 0xd3, 0xb4, 0xeb, 0xff, 0x03,
	0x00, 0x00, 0xff, 0xff, 0x56, 0x16, 0x94, 0xd4, 0xa2, 0x60, 0x00, 0x00,
}

func (m *Amount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Amount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Amount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArchiveStrategy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArchiveStrategy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArchiveStrategy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Zip != nil {
		{
			size, err := m.Zip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.None != nil {
		{
			size, err := m.None.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Tar != nil {
		{
			size, err := m.Tar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Arguments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Arguments) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Arguments) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Artifacts) > 0 {
		for iNdEx := len(m.Artifacts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Artifacts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Artifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Artifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Artifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RecurseMode != nil {
		i--
		if *m.RecurseMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.SubPath != nil {
		i -= len(*m.SubPath)
		copy(dAtA[i:], *m.SubPath)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SubPath)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Optional != nil {
		i--
		if *m.Optional {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Archive != nil {
		{
			size, err := m.Archive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.GlobalName != nil {
		i -= len(*m.GlobalName)
		copy(dAtA[i:], *m.GlobalName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GlobalName)))
		i--
		dAtA[i] = 0x32
	}
	if m.ArtifactLocation != nil {
		{
			size, err := m.ArtifactLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.From != nil {
		i -= len(*m.From)
		copy(dAtA[i:], *m.From)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.From)))
		i--
		dAtA[i] = 0x22
	}
	if m.Mode != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Mode))
		i--
		dAtA[i] = 0x18
	}
	if m.Path != nil {
		i -= len(*m.Path)
		copy(dAtA[i:], *m.Path)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArtifactLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArtifactLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArtifactLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Gcs != nil {
		{
			size, err := m.Gcs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Oss != nil {
		{
			size, err := m.Oss.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Raw != nil {
		{
			size, err := m.Raw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Hdfs != nil {
		{
			size, err := m.Hdfs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Artifactory != nil {
		{
			size, err := m.Artifactory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Git != nil {
		{
			size, err := m.Git.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.S3 != nil {
		{
			size, err := m.S3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ArchiveLogs != nil {
		i--
		if *m.ArchiveLogs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ArtifactRepositoryRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArtifactRepositoryRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArtifactRepositoryRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		i -= len(*m.Key)
		copy(dAtA[i:], *m.Key)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.ConfigMap != nil {
		i -= len(*m.ConfigMap)
		copy(dAtA[i:], *m.ConfigMap)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ConfigMap)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArtifactoryArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArtifactoryArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArtifactoryArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ArtifactoryAuth != nil {
		{
			size, err := m.ArtifactoryAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Url != nil {
		i -= len(*m.Url)
		copy(dAtA[i:], *m.Url)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArtifactoryAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArtifactoryAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArtifactoryAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PasswordSecret != nil {
		{
			size, err := m.PasswordSecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.UsernameSecret != nil {
		{
			size, err := m.UsernameSecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Backoff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Backoff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Backoff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxDuration != nil {
		i -= len(*m.MaxDuration)
		copy(dAtA[i:], *m.MaxDuration)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.MaxDuration)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Factor != nil {
		{
			size, err := m.Factor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Duration != nil {
		i -= len(*m.Duration)
		copy(dAtA[i:], *m.Duration)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Duration)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cache) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cache) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cache) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConfigMap != nil {
		{
			size, err := m.ConfigMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterWorkflowTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterWorkflowTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterWorkflowTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterWorkflowTemplateList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterWorkflowTemplateList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterWorkflowTemplateList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Message != nil {
		i -= len(*m.Message)
		copy(dAtA[i:], *m.Message)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != nil {
		i -= len(*m.Status)
		copy(dAtA[i:], *m.Status)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != nil {
		i -= len(*m.Type)
		copy(dAtA[i:], *m.Type)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContinueOn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContinueOn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContinueOn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Failed != nil {
		i--
		if *m.Failed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Error != nil {
		i--
		if *m.Error {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Counter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Counter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Counter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CronWorkflow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronWorkflow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronWorkflow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CronWorkflowList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronWorkflowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronWorkflowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CronWorkflowSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronWorkflowSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronWorkflowSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WorkflowMeta != nil {
		{
			size, err := m.WorkflowMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Timezone != nil {
		i -= len(*m.Timezone)
		copy(dAtA[i:], *m.Timezone)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Timezone)))
		i--
		dAtA[i] = 0x42
	}
	if m.FailedJobsHistoryLimit != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.FailedJobsHistoryLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.SuccessfulJobsHistoryLimit != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.SuccessfulJobsHistoryLimit))
		i--
		dAtA[i] = 0x30
	}
	if m.StartingDeadlineSeconds != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.StartingDeadlineSeconds))
		i--
		dAtA[i] = 0x28
	}
	if m.Suspend != nil {
		i--
		if *m.Suspend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ConcurrencyPolicy != nil {
		i -= len(*m.ConcurrencyPolicy)
		copy(dAtA[i:], *m.ConcurrencyPolicy)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ConcurrencyPolicy)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Schedule != nil {
		i -= len(*m.Schedule)
		copy(dAtA[i:], *m.Schedule)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Schedule)))
		i--
		dAtA[i] = 0x12
	}
	if m.WorkflowSpec != nil {
		{
			size, err := m.WorkflowSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CronWorkflowStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronWorkflowStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronWorkflowStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.LastScheduledTime != nil {
		{
			size, err := m.LastScheduledTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Active) > 0 {
		for iNdEx := len(m.Active) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Active[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DAGTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DAGTask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DAGTask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Depends != nil {
		i -= len(*m.Depends)
		copy(dAtA[i:], *m.Depends)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Depends)))
		i--
		dAtA[i] = 0x62
	}
	if m.OnExit != nil {
		i -= len(*m.OnExit)
		copy(dAtA[i:], *m.OnExit)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.OnExit)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ContinueOn != nil {
		{
			size, err := m.ContinueOn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.When != nil {
		i -= len(*m.When)
		copy(dAtA[i:], *m.When)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.When)))
		i--
		dAtA[i] = 0x4a
	}
	if m.WithSequence != nil {
		{
			size, err := m.WithSequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.WithParam != nil {
		i -= len(*m.WithParam)
		copy(dAtA[i:], *m.WithParam)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WithParam)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.WithItems) > 0 {
		for iNdEx := len(m.WithItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WithItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Dependencies) > 0 {
		for iNdEx := len(m.Dependencies) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Dependencies[iNdEx])
			copy(dAtA[i:], m.Dependencies[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Dependencies[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TemplateRef != nil {
		{
			size, err := m.TemplateRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Arguments != nil {
		{
			size, err := m.Arguments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Template != nil {
		i -= len(*m.Template)
		copy(dAtA[i:], *m.Template)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Template)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DAGTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DAGTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DAGTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FailFast != nil {
		i--
		if *m.FailFast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Tasks) > 0 {
		for iNdEx := len(m.Tasks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tasks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Target != nil {
		i -= len(*m.Target)
		copy(dAtA[i:], *m.Target)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Target)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Selector != nil {
		i -= len(*m.Selector)
		copy(dAtA[i:], *m.Selector)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Selector)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutorConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutorConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutorConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ServiceAccountName != nil {
		i -= len(*m.ServiceAccountName)
		copy(dAtA[i:], *m.ServiceAccountName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ServiceAccountName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCSArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCSArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCSArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		i -= len(*m.Key)
		copy(dAtA[i:], *m.Key)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.GCSBucket != nil {
		{
			size, err := m.GCSBucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCSBucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCSBucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCSBucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ServiceAccountKeySecret != nil {
		{
			size, err := m.ServiceAccountKeySecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Bucket != nil {
		i -= len(*m.Bucket)
		copy(dAtA[i:], *m.Bucket)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Bucket)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Gauge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Gauge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Gauge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Realtime != nil {
		i--
		if *m.Realtime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Value != nil {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GitArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GitArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GitArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InsecureIgnoreHostKey != nil {
		i--
		if *m.InsecureIgnoreHostKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.SshPrivateKeySecret != nil {
		{
			size, err := m.SshPrivateKeySecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PasswordSecret != nil {
		{
			size, err := m.PasswordSecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UsernameSecret != nil {
		{
			size, err := m.UsernameSecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Fetch) > 0 {
		for iNdEx := len(m.Fetch) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fetch[iNdEx])
			copy(dAtA[i:], m.Fetch[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Fetch[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Depth != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Depth))
		i--
		dAtA[i] = 0x18
	}
	if m.Revision != nil {
		i -= len(*m.Revision)
		copy(dAtA[i:], *m.Revision)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Revision)))
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		i -= len(*m.Repo)
		copy(dAtA[i:], *m.Repo)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Repo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HDFSArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HDFSArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HDFSArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Force != nil {
		i--
		if *m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Path != nil {
		i -= len(*m.Path)
		copy(dAtA[i:], *m.Path)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if m.HDFSConfig != nil {
		{
			size, err := m.HDFSConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HDFSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HDFSConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HDFSConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HdfsUser != nil {
		i -= len(*m.HdfsUser)
		copy(dAtA[i:], *m.HdfsUser)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.HdfsUser)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addresses[iNdEx])
			copy(dAtA[i:], m.Addresses[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Addresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.HDFSKrbConfig != nil {
		{
			size, err := m.HDFSKrbConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HDFSKrbConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HDFSKrbConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HDFSKrbConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KrbServicePrincipalName != nil {
		i -= len(*m.KrbServicePrincipalName)
		copy(dAtA[i:], *m.KrbServicePrincipalName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.KrbServicePrincipalName)))
		i--
		dAtA[i] = 0x32
	}
	if m.KrbConfigConfigMap != nil {
		{
			size, err := m.KrbConfigConfigMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.KrbRealm != nil {
		i -= len(*m.KrbRealm)
		copy(dAtA[i:], *m.KrbRealm)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.KrbRealm)))
		i--
		dAtA[i] = 0x22
	}
	if m.KrbUsername != nil {
		i -= len(*m.KrbUsername)
		copy(dAtA[i:], *m.KrbUsername)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.KrbUsername)))
		i--
		dAtA[i] = 0x1a
	}
	if m.KrbKeytabSecret != nil {
		{
			size, err := m.KrbKeytabSecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.KrbCCacheSecret != nil {
		{
			size, err := m.KrbCCacheSecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HTTPArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Url != nil {
		i -= len(*m.Url)
		copy(dAtA[i:], *m.Url)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Histogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Histogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Histogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Buckets) > 0 {
		for iNdEx := len(m.Buckets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Buckets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Value != nil {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *Inputs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Inputs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Inputs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Artifacts) > 0 {
		for iNdEx := len(m.Artifacts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Artifacts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Link) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Url != nil {
		i -= len(*m.Url)
		copy(dAtA[i:], *m.Url)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Url)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Scope != nil {
		i -= len(*m.Scope)
		copy(dAtA[i:], *m.Scope)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Scope)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoizationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoizationStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoizationStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CacheName != nil {
		i -= len(*m.CacheName)
		copy(dAtA[i:], *m.CacheName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.CacheName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Key != nil {
		i -= len(*m.Key)
		copy(dAtA[i:], *m.Key)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Hit != nil {
		i--
		if *m.Hit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Memoize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Memoize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Memoize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxAge != nil {
		i -= len(*m.MaxAge)
		copy(dAtA[i:], *m.MaxAge)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.MaxAge)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Cache != nil {
		{
			size, err := m.Cache.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		i -= len(*m.Key)
		copy(dAtA[i:], *m.Key)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGenerated(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGenerated(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetricLabel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricLabel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricLabel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		i -= len(*m.Key)
		copy(dAtA[i:], *m.Key)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Prometheus) > 0 {
		for iNdEx := len(m.Prometheus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Prometheus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Mutex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mutex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mutex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MutexHolding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MutexHolding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MutexHolding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Holder != nil {
		i -= len(*m.Holder)
		copy(dAtA[i:], *m.Holder)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Holder)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mutex != nil {
		i -= len(*m.Mutex)
		copy(dAtA[i:], *m.Mutex)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Mutex)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MutexStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MutexStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MutexStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Waiting) > 0 {
		for iNdEx := len(m.Waiting) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Waiting[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Holding) > 0 {
		for iNdEx := len(m.Holding) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Holding[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SynchronizationStatus != nil {
		{
			size, err := m.SynchronizationStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.EstimatedDuration != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.EstimatedDuration))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.MemoizationStatus != nil {
		{
			size, err := m.MemoizationStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.HostNodeName != nil {
		i -= len(*m.HostNodeName)
		copy(dAtA[i:], *m.HostNodeName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.HostNodeName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.ResourcesDuration) > 0 {
		for k := range m.ResourcesDuration {
			v := m.ResourcesDuration[k]
			baseI := i
			i = encodeVarintGenerated(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGenerated(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.TemplateScope != nil {
		i -= len(*m.TemplateScope)
		copy(dAtA[i:], *m.TemplateScope)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TemplateScope)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.WorkflowTemplateName != nil {
		i -= len(*m.WorkflowTemplateName)
		copy(dAtA[i:], *m.WorkflowTemplateName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WorkflowTemplateName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.StoredTemplateID != nil {
		i -= len(*m.StoredTemplateID)
		copy(dAtA[i:], *m.StoredTemplateID)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.StoredTemplateID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.OutboundNodes) > 0 {
		for iNdEx := len(m.OutboundNodes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OutboundNodes[iNdEx])
			copy(dAtA[i:], m.OutboundNodes[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.OutboundNodes[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Children[iNdEx])
			copy(dAtA[i:], m.Children[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Children[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Outputs != nil {
		{
			size, err := m.Outputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Inputs != nil {
		{
			size, err := m.Inputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Daemoned != nil {
		i--
		if *m.Daemoned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.PodIP != nil {
		i -= len(*m.PodIP)
		copy(dAtA[i:], *m.PodIP)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.PodIP)))
		i--
		dAtA[i] = 0x62
	}
	if m.FinishedAt != nil {
		{
			size, err := m.FinishedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.StartedAt != nil {
		{
			size, err := m.StartedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Message != nil {
		i -= len(*m.Message)
		copy(dAtA[i:], *m.Message)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Message)))
		i--
		dAtA[i] = 0x4a
	}
	if m.BoundaryID != nil {
		i -= len(*m.BoundaryID)
		copy(dAtA[i:], *m.BoundaryID)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.BoundaryID)))
		i--
		dAtA[i] = 0x42
	}
	if m.Phase != nil {
		i -= len(*m.Phase)
		copy(dAtA[i:], *m.Phase)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Phase)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TemplateRef != nil {
		{
			size, err := m.TemplateRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TemplateName != nil {
		i -= len(*m.TemplateName)
		copy(dAtA[i:], *m.TemplateName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.TemplateName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Type != nil {
		i -= len(*m.Type)
		copy(dAtA[i:], *m.Type)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.DisplayName != nil {
		i -= len(*m.DisplayName)
		copy(dAtA[i:], *m.DisplayName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DisplayName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i -= len(*m.Id)
		copy(dAtA[i:], *m.Id)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeSynchronizationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeSynchronizationStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeSynchronizationStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Waiting != nil {
		i -= len(*m.Waiting)
		copy(dAtA[i:], *m.Waiting)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Waiting)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NoneStrategy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoneStrategy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoneStrategy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *OSSArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSSArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSSArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		i -= len(*m.Key)
		copy(dAtA[i:], *m.Key)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.OSSBucket != nil {
		{
			size, err := m.OSSBucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OSSBucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSSBucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSSBucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SecretKeySecret != nil {
		{
			size, err := m.SecretKeySecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AccessKeySecret != nil {
		{
			size, err := m.AccessKeySecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Bucket != nil {
		i -= len(*m.Bucket)
		copy(dAtA[i:], *m.Bucket)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Bucket)))
		i--
		dAtA[i] = 0x12
	}
	if m.Endpoint != nil {
		i -= len(*m.Endpoint)
		copy(dAtA[i:], *m.Endpoint)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Outputs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Outputs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Outputs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExitCode != nil {
		i -= len(*m.ExitCode)
		copy(dAtA[i:], *m.ExitCode)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ExitCode)))
		i--
		dAtA[i] = 0x22
	}
	if m.Result != nil {
		i -= len(*m.Result)
		copy(dAtA[i:], *m.Result)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Result)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Artifacts) > 0 {
		for iNdEx := len(m.Artifacts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Artifacts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ParallelSteps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParallelSteps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParallelSteps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Parameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Parameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Parameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GlobalName != nil {
		i -= len(*m.GlobalName)
		copy(dAtA[i:], *m.GlobalName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GlobalName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ValueFrom != nil {
		{
			size, err := m.ValueFrom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Value != nil {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Default != nil {
		i -= len(*m.Default)
		copy(dAtA[i:], *m.Default)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Default)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PodGC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodGC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodGC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Strategy != nil {
		i -= len(*m.Strategy)
		copy(dAtA[i:], *m.Strategy)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Strategy)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Prometheus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prometheus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Prometheus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Counter != nil {
		{
			size, err := m.Counter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Histogram != nil {
		{
			size, err := m.Histogram.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Gauge != nil {
		{
			size, err := m.Gauge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.When != nil {
		i -= len(*m.When)
		copy(dAtA[i:], *m.When)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.When)))
		i--
		dAtA[i] = 0x22
	}
	if m.Help != nil {
		i -= len(*m.Help)
		copy(dAtA[i:], *m.Help)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Help)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		i -= len(*m.Data)
		copy(dAtA[i:], *m.Data)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Flags) > 0 {
		for iNdEx := len(m.Flags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Flags[iNdEx])
			copy(dAtA[i:], m.Flags[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Flags[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.FailureCondition != nil {
		i -= len(*m.FailureCondition)
		copy(dAtA[i:], *m.FailureCondition)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.FailureCondition)))
		i--
		dAtA[i] = 0x32
	}
	if m.SuccessCondition != nil {
		i -= len(*m.SuccessCondition)
		copy(dAtA[i:], *m.SuccessCondition)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SuccessCondition)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SetOwnerReference != nil {
		i--
		if *m.SetOwnerReference {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Manifest != nil {
		i -= len(*m.Manifest)
		copy(dAtA[i:], *m.Manifest)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Manifest)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MergeStrategy != nil {
		i -= len(*m.MergeStrategy)
		copy(dAtA[i:], *m.MergeStrategy)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.MergeStrategy)))
		i--
		dAtA[i] = 0x12
	}
	if m.Action != nil {
		i -= len(*m.Action)
		copy(dAtA[i:], *m.Action)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Action)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RetryStrategy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryStrategy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryStrategy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Backoff != nil {
		{
			size, err := m.Backoff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RetryPolicy != nil {
		i -= len(*m.RetryPolicy)
		copy(dAtA[i:], *m.RetryPolicy)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.RetryPolicy)))
		i--
		dAtA[i] = 0x12
	}
	if m.Limit != nil {
		{
			size, err := m.Limit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S3Artifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S3Artifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S3Artifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		i -= len(*m.Key)
		copy(dAtA[i:], *m.Key)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.S3Bucket != nil {
		{
			size, err := m.S3Bucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S3Bucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S3Bucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S3Bucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseSDKCreds != nil {
		i--
		if *m.UseSDKCreds {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.RoleARN != nil {
		i -= len(*m.RoleARN)
		copy(dAtA[i:], *m.RoleARN)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.RoleARN)))
		i--
		dAtA[i] = 0x3a
	}
	if m.SecretKeySecret != nil {
		{
			size, err := m.SecretKeySecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.AccessKeySecret != nil {
		{
			size, err := m.AccessKeySecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Insecure != nil {
		i--
		if *m.Insecure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Region != nil {
		i -= len(*m.Region)
		copy(dAtA[i:], *m.Region)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Region)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Bucket != nil {
		i -= len(*m.Bucket)
		copy(dAtA[i:], *m.Bucket)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Bucket)))
		i--
		dAtA[i] = 0x12
	}
	if m.Endpoint != nil {
		i -= len(*m.Endpoint)
		copy(dAtA[i:], *m.Endpoint)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScriptTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScriptTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScriptTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Source != nil {
		i -= len(*m.Source)
		copy(dAtA[i:], *m.Source)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Source)))
		i--
		dAtA[i] = 0x12
	}
	if m.Container != nil {
		{
			size, err := m.Container.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SemaphoreHolding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SemaphoreHolding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SemaphoreHolding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Holders) > 0 {
		for iNdEx := len(m.Holders) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Holders[iNdEx])
			copy(dAtA[i:], m.Holders[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Holders[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Semaphore != nil {
		i -= len(*m.Semaphore)
		copy(dAtA[i:], *m.Semaphore)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Semaphore)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SemaphoreRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SemaphoreRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SemaphoreRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConfigMapKeyRef != nil {
		{
			size, err := m.ConfigMapKeyRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SemaphoreStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SemaphoreStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SemaphoreStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Waiting) > 0 {
		for iNdEx := len(m.Waiting) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Waiting[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Holding) > 0 {
		for iNdEx := len(m.Holding) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Holding[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Sequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Format != nil {
		i -= len(*m.Format)
		copy(dAtA[i:], *m.Format)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Format)))
		i--
		dAtA[i] = 0x22
	}
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Count != nil {
		{
			size, err := m.Count.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Submit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Submit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Submit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Arguments != nil {
		{
			size, err := m.Arguments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.WorkflowTemplateRef != nil {
		{
			size, err := m.WorkflowTemplateRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubmitOpts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitOpts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubmitOpts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OwnerReference != nil {
		{
			size, err := m.OwnerReference.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Labels != nil {
		i -= len(*m.Labels)
		copy(dAtA[i:], *m.Labels)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Labels)))
		i--
		dAtA[i] = 0x52
	}
	if m.ServerDryRun != nil {
		i--
		if *m.ServerDryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.DryRun != nil {
		i--
		if *m.DryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ServiceAccount != nil {
		i -= len(*m.ServiceAccount)
		copy(dAtA[i:], *m.ServiceAccount)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ServiceAccount)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ParameterFile != nil {
		i -= len(*m.ParameterFile)
		copy(dAtA[i:], *m.ParameterFile)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ParameterFile)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Parameters[iNdEx])
			copy(dAtA[i:], m.Parameters[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Parameters[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Entrypoint != nil {
		i -= len(*m.Entrypoint)
		copy(dAtA[i:], *m.Entrypoint)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Entrypoint)))
		i--
		dAtA[i] = 0x22
	}
	if m.GenerateName != nil {
		i -= len(*m.GenerateName)
		copy(dAtA[i:], *m.GenerateName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GenerateName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SuppliedValueFrom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuppliedValueFrom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuppliedValueFrom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SuspendTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuspendTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuspendTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Duration != nil {
		i -= len(*m.Duration)
		copy(dAtA[i:], *m.Duration)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Duration)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Synchronization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Synchronization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Synchronization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mutex != nil {
		{
			size, err := m.Mutex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Semaphore != nil {
		{
			size, err := m.Semaphore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SynchronizationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SynchronizationStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SynchronizationStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mutex != nil {
		{
			size, err := m.Mutex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Semaphore != nil {
		{
			size, err := m.Semaphore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TTLStrategy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TTLStrategy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TTLStrategy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SecondsAfterFailure != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.SecondsAfterFailure))
		i--
		dAtA[i] = 0x18
	}
	if m.SecondsAfterSuccess != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.SecondsAfterSuccess))
		i--
		dAtA[i] = 0x10
	}
	if m.SecondsAfterCompletion != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.SecondsAfterCompletion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TarStrategy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TarStrategy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TarStrategy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompressionLevel != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.CompressionLevel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Template) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Template) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Template) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timeout != nil {
		i -= len(*m.Timeout)
		copy(dAtA[i:], *m.Timeout)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Timeout)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.Memoize != nil {
		{
			size, err := m.Memoize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.Synchronization != nil {
		{
			size, err := m.Synchronization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.Executor != nil {
		{
			size, err := m.Executor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.AutomountServiceAccountToken != nil {
		i--
		if *m.AutomountServiceAccountToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.PodSpecPatch != nil {
		i -= len(*m.PodSpecPatch)
		copy(dAtA[i:], *m.PodSpecPatch)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.PodSpecPatch)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.SecurityContext != nil {
		{
			size, err := m.SecurityContext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.HostAliases) > 0 {
		for iNdEx := len(m.HostAliases) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HostAliases[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xea
		}
	}
	if m.ServiceAccountName != nil {
		i -= len(*m.ServiceAccountName)
		copy(dAtA[i:], *m.ServiceAccountName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ServiceAccountName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.Priority != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Priority))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.PriorityClassName != nil {
		i -= len(*m.PriorityClassName)
		copy(dAtA[i:], *m.PriorityClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.PriorityClassName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.SchedulerName != nil {
		i -= len(*m.SchedulerName)
		copy(dAtA[i:], *m.SchedulerName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SchedulerName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.Tolerations) > 0 {
		for iNdEx := len(m.Tolerations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tolerations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if m.Parallelism != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Parallelism))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.RetryStrategy != nil {
		{
			size, err := m.RetryStrategy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.ActiveDeadlineSeconds != nil {
		{
			size, err := m.ActiveDeadlineSeconds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ArchiveLocation != nil {
		{
			size, err := m.ArchiveLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Sidecars) > 0 {
		for iNdEx := len(m.Sidecars) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sidecars[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.InitContainers) > 0 {
		for iNdEx := len(m.InitContainers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InitContainers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.Volumes) > 0 {
		for iNdEx := len(m.Volumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Volumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.Suspend != nil {
		{
			size, err := m.Suspend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Dag != nil {
		{
			size, err := m.Dag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Resource != nil {
		{
			size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Script != nil {
		{
			size, err := m.Script.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Container != nil {
		{
			size, err := m.Container.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.Daemon != nil {
		i--
		if *m.Daemon {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Affinity != nil {
		{
			size, err := m.Affinity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.NodeSelector) > 0 {
		for k := range m.NodeSelector {
			v := m.NodeSelector[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGenerated(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Outputs != nil {
		{
			size, err := m.Outputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Inputs != nil {
		{
			size, err := m.Inputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TemplateRef != nil {
		{
			size, err := m.TemplateRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Arguments != nil {
		{
			size, err := m.Arguments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Template != nil {
		i -= len(*m.Template)
		copy(dAtA[i:], *m.Template)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Template)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TemplateRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TemplateRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TemplateRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClusterScope != nil {
		i--
		if *m.ClusterScope {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.RuntimeResolution != nil {
		i--
		if *m.RuntimeResolution {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Template != nil {
		i -= len(*m.Template)
		copy(dAtA[i:], *m.Template)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Template)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserContainer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserContainer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MirrorVolumeMounts != nil {
		i--
		if *m.MirrorVolumeMounts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Container != nil {
		{
			size, err := m.Container.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValueFrom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueFrom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueFrom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Event != nil {
		i -= len(*m.Event)
		copy(dAtA[i:], *m.Event)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Event)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Supplied != nil {
		{
			size, err := m.Supplied.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Default != nil {
		i -= len(*m.Default)
		copy(dAtA[i:], *m.Default)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Default)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Parameter != nil {
		i -= len(*m.Parameter)
		copy(dAtA[i:], *m.Parameter)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Parameter)))
		i--
		dAtA[i] = 0x22
	}
	if m.JqFilter != nil {
		i -= len(*m.JqFilter)
		copy(dAtA[i:], *m.JqFilter)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.JqFilter)))
		i--
		dAtA[i] = 0x1a
	}
	if m.JsonPath != nil {
		i -= len(*m.JsonPath)
		copy(dAtA[i:], *m.JsonPath)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.JsonPath)))
		i--
		dAtA[i] = 0x12
	}
	if m.Path != nil {
		i -= len(*m.Path)
		copy(dAtA[i:], *m.Path)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Version) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Platform != nil {
		i -= len(*m.Platform)
		copy(dAtA[i:], *m.Platform)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Platform)))
		i--
		dAtA[i] = 0x42
	}
	if m.Compiler != nil {
		i -= len(*m.Compiler)
		copy(dAtA[i:], *m.Compiler)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Compiler)))
		i--
		dAtA[i] = 0x3a
	}
	if m.GoVersion != nil {
		i -= len(*m.GoVersion)
		copy(dAtA[i:], *m.GoVersion)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GoVersion)))
		i--
		dAtA[i] = 0x32
	}
	if m.GitTreeState != nil {
		i -= len(*m.GitTreeState)
		copy(dAtA[i:], *m.GitTreeState)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GitTreeState)))
		i--
		dAtA[i] = 0x2a
	}
	if m.GitTag != nil {
		i -= len(*m.GitTag)
		copy(dAtA[i:], *m.GitTag)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GitTag)))
		i--
		dAtA[i] = 0x22
	}
	if m.GitCommit != nil {
		i -= len(*m.GitCommit)
		copy(dAtA[i:], *m.GitCommit)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.GitCommit)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BuildDate != nil {
		i -= len(*m.BuildDate)
		copy(dAtA[i:], *m.BuildDate)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.BuildDate)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version != nil {
		i -= len(*m.Version)
		copy(dAtA[i:], *m.Version)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VolumeClaimGC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeClaimGC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolumeClaimGC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Strategy != nil {
		i -= len(*m.Strategy)
		copy(dAtA[i:], *m.Strategy)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Strategy)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Workflow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Workflow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Workflow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowEventBinding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowEventBinding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowEventBinding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowEventBindingList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowEventBindingList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowEventBindingList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowEventBindingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowEventBindingSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowEventBindingSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Submit != nil {
		{
			size, err := m.Submit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Event != nil {
		{
			size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RetryStrategy != nil {
		{
			size, err := m.RetryStrategy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.VolumeClaimGC != nil {
		{
			size, err := m.VolumeClaimGC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.Synchronization != nil {
		{
			size, err := m.Synchronization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.WorkflowTemplateRef != nil {
		{
			size, err := m.WorkflowTemplateRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.Shutdown != nil {
		i -= len(*m.Shutdown)
		copy(dAtA[i:], *m.Shutdown)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Shutdown)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.PodDisruptionBudget != nil {
		{
			size, err := m.PodDisruptionBudget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.TtlStrategy != nil {
		{
			size, err := m.TtlStrategy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.Executor != nil {
		{
			size, err := m.Executor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.AutomountServiceAccountToken != nil {
		i--
		if *m.AutomountServiceAccountToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.PodSpecPatch != nil {
		i -= len(*m.PodSpecPatch)
		copy(dAtA[i:], *m.PodSpecPatch)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.PodSpecPatch)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.SecurityContext != nil {
		{
			size, err := m.SecurityContext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.HostAliases) > 0 {
		for iNdEx := len(m.HostAliases) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HostAliases[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.PodPriority != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.PodPriority))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.PodPriorityClassName != nil {
		i -= len(*m.PodPriorityClassName)
		copy(dAtA[i:], *m.PodPriorityClassName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.PodPriorityClassName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.PodGC != nil {
		{
			size, err := m.PodGC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.SchedulerName != nil {
		i -= len(*m.SchedulerName)
		copy(dAtA[i:], *m.SchedulerName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.SchedulerName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Priority != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Priority))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ActiveDeadlineSeconds != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.ActiveDeadlineSeconds))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.TtlSecondsAfterFinished != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TtlSecondsAfterFinished))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.OnExit != nil {
		i -= len(*m.OnExit)
		copy(dAtA[i:], *m.OnExit)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.OnExit)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.DnsConfig != nil {
		{
			size, err := m.DnsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.DnsPolicy != nil {
		i -= len(*m.DnsPolicy)
		copy(dAtA[i:], *m.DnsPolicy)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.DnsPolicy)))
		i--
		dAtA[i] = 0x7a
	}
	if m.HostNetwork != nil {
		i--
		if *m.HostNetwork {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.ImagePullSecrets) > 0 {
		for iNdEx := len(m.ImagePullSecrets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ImagePullSecrets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Tolerations) > 0 {
		for iNdEx := len(m.Tolerations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tolerations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.Affinity != nil {
		{
			size, err := m.Affinity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.NodeSelector) > 0 {
		for k := range m.NodeSelector {
			v := m.NodeSelector[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGenerated(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Suspend != nil {
		i--
		if *m.Suspend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.ArtifactRepositoryRef != nil {
		{
			size, err := m.ArtifactRepositoryRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Parallelism != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.Parallelism))
		i--
		dAtA[i] = 0x38
	}
	if len(m.VolumeClaimTemplates) > 0 {
		for iNdEx := len(m.VolumeClaimTemplates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VolumeClaimTemplates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Volumes) > 0 {
		for iNdEx := len(m.Volumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Volumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ServiceAccountName != nil {
		i -= len(*m.ServiceAccountName)
		copy(dAtA[i:], *m.ServiceAccountName)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.ServiceAccountName)))
		i--
		dAtA[i] = 0x22
	}
	if m.Arguments != nil {
		{
			size, err := m.Arguments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Entrypoint != nil {
		i -= len(*m.Entrypoint)
		copy(dAtA[i:], *m.Entrypoint)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Entrypoint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Templates) > 0 {
		for iNdEx := len(m.Templates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Templates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EstimatedDuration != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.EstimatedDuration))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Synchronization != nil {
		{
			size, err := m.Synchronization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.StoredWorkflowTemplateSpec != nil {
		{
			size, err := m.StoredWorkflowTemplateSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.ResourcesDuration) > 0 {
		for k := range m.ResourcesDuration {
			v := m.ResourcesDuration[k]
			baseI := i
			i = encodeVarintGenerated(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGenerated(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.OffloadNodeStatusVersion != nil {
		i -= len(*m.OffloadNodeStatusVersion)
		copy(dAtA[i:], *m.OffloadNodeStatusVersion)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.OffloadNodeStatusVersion)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.StoredTemplates) > 0 {
		for k := range m.StoredTemplates {
			v := m.StoredTemplates[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintGenerated(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGenerated(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Outputs != nil {
		{
			size, err := m.Outputs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.PersistentVolumeClaims) > 0 {
		for iNdEx := len(m.PersistentVolumeClaims) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PersistentVolumeClaims[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Nodes) > 0 {
		for k := range m.Nodes {
			v := m.Nodes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintGenerated(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGenerated(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.CompressedNodes != nil {
		i -= len(*m.CompressedNodes)
		copy(dAtA[i:], *m.CompressedNodes)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.CompressedNodes)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Message != nil {
		i -= len(*m.Message)
		copy(dAtA[i:], *m.Message)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if m.FinishedAt != nil {
		{
			size, err := m.FinishedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartedAt != nil {
		{
			size, err := m.StartedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Phase != nil {
		i -= len(*m.Phase)
		copy(dAtA[i:], *m.Phase)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Phase)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OnExit != nil {
		i -= len(*m.OnExit)
		copy(dAtA[i:], *m.OnExit)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.OnExit)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ContinueOn != nil {
		{
			size, err := m.ContinueOn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.When != nil {
		i -= len(*m.When)
		copy(dAtA[i:], *m.When)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.When)))
		i--
		dAtA[i] = 0x42
	}
	if m.WithSequence != nil {
		{
			size, err := m.WithSequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.WithParam != nil {
		i -= len(*m.WithParam)
		copy(dAtA[i:], *m.WithParam)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.WithParam)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.WithItems) > 0 {
		for iNdEx := len(m.WithItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WithItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TemplateRef != nil {
		{
			size, err := m.TemplateRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Arguments != nil {
		{
			size, err := m.Arguments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Template != nil {
		i -= len(*m.Template)
		copy(dAtA[i:], *m.Template)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Template)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowTemplateList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowTemplateList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowTemplateList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowTemplateRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowTemplateRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowTemplateRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClusterScope != nil {
		i--
		if *m.ClusterScope {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowTemplateSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowTemplateSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowTemplateSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WorkflowMeta != nil {
		{
			size, err := m.WorkflowMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.WorkflowSpec != nil {
		{
			size, err := m.WorkflowSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZipStrategy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZipStrategy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZipStrategy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenerated(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenerated(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Amount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArchiveStrategy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tar != nil {
		l = m.Tar.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.None != nil {
		l = m.None.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Zip != nil {
		l = m.Zip.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Arguments) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Artifacts) > 0 {
		for _, e := range m.Artifacts {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Artifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Path != nil {
		l = len(*m.Path)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Mode != nil {
		n += 1 + sovGenerated(uint64(*m.Mode))
	}
	if m.From != nil {
		l = len(*m.From)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ArtifactLocation != nil {
		l = m.ArtifactLocation.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GlobalName != nil {
		l = len(*m.GlobalName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Archive != nil {
		l = m.Archive.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Optional != nil {
		n += 2
	}
	if m.SubPath != nil {
		l = len(*m.SubPath)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.RecurseMode != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArtifactLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ArchiveLogs != nil {
		n += 2
	}
	if m.S3 != nil {
		l = m.S3.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Git != nil {
		l = m.Git.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Artifactory != nil {
		l = m.Artifactory.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Hdfs != nil {
		l = m.Hdfs.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Raw != nil {
		l = m.Raw.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Oss != nil {
		l = m.Oss.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Gcs != nil {
		l = m.Gcs.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArtifactRepositoryRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigMap != nil {
		l = len(*m.ConfigMap)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArtifactoryArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Url != nil {
		l = len(*m.Url)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ArtifactoryAuth != nil {
		l = m.ArtifactoryAuth.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArtifactoryAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UsernameSecret != nil {
		l = m.UsernameSecret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.PasswordSecret != nil {
		l = m.PasswordSecret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Backoff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Duration != nil {
		l = len(*m.Duration)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Factor != nil {
		l = m.Factor.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.MaxDuration != nil {
		l = len(*m.MaxDuration)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cache) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigMap != nil {
		l = m.ConfigMap.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterWorkflowTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterWorkflowTemplateList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Status != nil {
		l = len(*m.Status)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContinueOn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		n += 2
	}
	if m.Failed != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Counter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CronWorkflow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CronWorkflowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CronWorkflowSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkflowSpec != nil {
		l = m.WorkflowSpec.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Schedule != nil {
		l = len(*m.Schedule)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ConcurrencyPolicy != nil {
		l = len(*m.ConcurrencyPolicy)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Suspend != nil {
		n += 2
	}
	if m.StartingDeadlineSeconds != nil {
		n += 1 + sovGenerated(uint64(*m.StartingDeadlineSeconds))
	}
	if m.SuccessfulJobsHistoryLimit != nil {
		n += 1 + sovGenerated(uint64(*m.SuccessfulJobsHistoryLimit))
	}
	if m.FailedJobsHistoryLimit != nil {
		n += 1 + sovGenerated(uint64(*m.FailedJobsHistoryLimit))
	}
	if m.Timezone != nil {
		l = len(*m.Timezone)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.WorkflowMeta != nil {
		l = m.WorkflowMeta.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CronWorkflowStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Active) > 0 {
		for _, e := range m.Active {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.LastScheduledTime != nil {
		l = m.LastScheduledTime.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DAGTask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Template != nil {
		l = len(*m.Template)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Arguments != nil {
		l = m.Arguments.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TemplateRef != nil {
		l = m.TemplateRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Dependencies) > 0 {
		for _, s := range m.Dependencies {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.WithItems) > 0 {
		for _, e := range m.WithItems {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.WithParam != nil {
		l = len(*m.WithParam)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.WithSequence != nil {
		l = m.WithSequence.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.When != nil {
		l = len(*m.When)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ContinueOn != nil {
		l = m.ContinueOn.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.OnExit != nil {
		l = len(*m.OnExit)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Depends != nil {
		l = len(*m.Depends)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DAGTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != nil {
		l = len(*m.Target)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.FailFast != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Selector != nil {
		l = len(*m.Selector)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecutorConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceAccountName != nil {
		l = len(*m.ServiceAccountName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GCSArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GCSBucket != nil {
		l = m.GCSBucket.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GCSBucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(*m.Bucket)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ServiceAccountKeySecret != nil {
		l = m.ServiceAccountKeySecret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Gauge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Realtime != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GitArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = len(*m.Repo)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Revision != nil {
		l = len(*m.Revision)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Depth != nil {
		n += 1 + sovGenerated(uint64(*m.Depth))
	}
	if len(m.Fetch) > 0 {
		for _, s := range m.Fetch {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.UsernameSecret != nil {
		l = m.UsernameSecret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.PasswordSecret != nil {
		l = m.PasswordSecret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SshPrivateKeySecret != nil {
		l = m.SshPrivateKeySecret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.InsecureIgnoreHostKey != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HDFSArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HDFSConfig != nil {
		l = m.HDFSConfig.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Path != nil {
		l = len(*m.Path)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Force != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HDFSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HDFSKrbConfig != nil {
		l = m.HDFSKrbConfig.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.HdfsUser != nil {
		l = len(*m.HdfsUser)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HDFSKrbConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KrbCCacheSecret != nil {
		l = m.KrbCCacheSecret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.KrbKeytabSecret != nil {
		l = m.KrbKeytabSecret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.KrbUsername != nil {
		l = len(*m.KrbUsername)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.KrbRealm != nil {
		l = len(*m.KrbRealm)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.KrbConfigConfigMap != nil {
		l = m.KrbConfigConfigMap.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.KrbServicePrincipalName != nil {
		l = len(*m.KrbServicePrincipalName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HTTPArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Url != nil {
		l = len(*m.Url)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Histogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Buckets) > 0 {
		for _, e := range m.Buckets {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Inputs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Artifacts) > 0 {
		for _, e := range m.Artifacts {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Scope != nil {
		l = len(*m.Scope)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Url != nil {
		l = len(*m.Url)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoizationStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hit != nil {
		n += 2
	}
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CacheName != nil {
		l = len(*m.CacheName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Memoize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Cache != nil {
		l = m.Cache.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.MaxAge != nil {
		l = len(*m.MaxAge)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetricLabel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Prometheus) > 0 {
		for _, e := range m.Prometheus {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Mutex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MutexHolding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mutex != nil {
		l = len(*m.Mutex)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Holder != nil {
		l = len(*m.Holder)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MutexStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Holding) > 0 {
		for _, e := range m.Holding {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Waiting) > 0 {
		for _, e := range m.Waiting {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DisplayName != nil {
		l = len(*m.DisplayName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TemplateName != nil {
		l = len(*m.TemplateName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TemplateRef != nil {
		l = m.TemplateRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Phase != nil {
		l = len(*m.Phase)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.BoundaryID != nil {
		l = len(*m.BoundaryID)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FinishedAt != nil {
		l = m.FinishedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.PodIP != nil {
		l = len(*m.PodIP)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Daemoned != nil {
		n += 2
	}
	if m.Inputs != nil {
		l = m.Inputs.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Outputs != nil {
		l = m.Outputs.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, s := range m.Children {
			l = len(s)
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.OutboundNodes) > 0 {
		for _, s := range m.OutboundNodes {
			l = len(s)
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	if m.StoredTemplateID != nil {
		l = len(*m.StoredTemplateID)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.WorkflowTemplateName != nil {
		l = len(*m.WorkflowTemplateName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.TemplateScope != nil {
		l = len(*m.TemplateScope)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if len(m.ResourcesDuration) > 0 {
		for k, v := range m.ResourcesDuration {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + sovGenerated(uint64(v))
			n += mapEntrySize + 2 + sovGenerated(uint64(mapEntrySize))
		}
	}
	if m.HostNodeName != nil {
		l = len(*m.HostNodeName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.MemoizationStatus != nil {
		l = m.MemoizationStatus.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.EstimatedDuration != nil {
		n += 2 + sovGenerated(uint64(*m.EstimatedDuration))
	}
	if m.SynchronizationStatus != nil {
		l = m.SynchronizationStatus.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeSynchronizationStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Waiting != nil {
		l = len(*m.Waiting)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoneStrategy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OSSArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OSSBucket != nil {
		l = m.OSSBucket.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OSSBucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Endpoint != nil {
		l = len(*m.Endpoint)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Bucket != nil {
		l = len(*m.Bucket)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.AccessKeySecret != nil {
		l = m.AccessKeySecret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SecretKeySecret != nil {
		l = m.SecretKeySecret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Outputs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Artifacts) > 0 {
		for _, e := range m.Artifacts {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Result != nil {
		l = len(*m.Result)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ExitCode != nil {
		l = len(*m.ExitCode)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ParallelSteps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Parameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Default != nil {
		l = len(*m.Default)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ValueFrom != nil {
		l = m.ValueFrom.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GlobalName != nil {
		l = len(*m.GlobalName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PodGC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Strategy != nil {
		l = len(*m.Strategy)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Prometheus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Help != nil {
		l = len(*m.Help)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.When != nil {
		l = len(*m.When)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Gauge != nil {
		l = m.Gauge.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Histogram != nil {
		l = m.Histogram.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Counter != nil {
		l = m.Counter.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = len(*m.Data)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		l = len(*m.Action)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.MergeStrategy != nil {
		l = len(*m.MergeStrategy)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Manifest != nil {
		l = len(*m.Manifest)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SetOwnerReference != nil {
		n += 2
	}
	if m.SuccessCondition != nil {
		l = len(*m.SuccessCondition)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FailureCondition != nil {
		l = len(*m.FailureCondition)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Flags) > 0 {
		for _, s := range m.Flags {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RetryStrategy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != nil {
		l = m.Limit.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.RetryPolicy != nil {
		l = len(*m.RetryPolicy)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Backoff != nil {
		l = m.Backoff.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S3Artifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.S3Bucket != nil {
		l = m.S3Bucket.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S3Bucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Endpoint != nil {
		l = len(*m.Endpoint)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Bucket != nil {
		l = len(*m.Bucket)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Region != nil {
		l = len(*m.Region)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Insecure != nil {
		n += 2
	}
	if m.AccessKeySecret != nil {
		l = m.AccessKeySecret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SecretKeySecret != nil {
		l = m.SecretKeySecret.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.RoleARN != nil {
		l = len(*m.RoleARN)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.UseSDKCreds != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScriptTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Container != nil {
		l = m.Container.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Source != nil {
		l = len(*m.Source)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SemaphoreHolding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Semaphore != nil {
		l = len(*m.Semaphore)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Holders) > 0 {
		for _, s := range m.Holders {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SemaphoreRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigMapKeyRef != nil {
		l = m.ConfigMapKeyRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SemaphoreStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Holding) > 0 {
		for _, e := range m.Holding {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Waiting) > 0 {
		for _, e := range m.Waiting {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Sequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != nil {
		l = m.Count.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Format != nil {
		l = len(*m.Format)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Submit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkflowTemplateRef != nil {
		l = m.WorkflowTemplateRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Arguments != nil {
		l = m.Arguments.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubmitOpts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GenerateName != nil {
		l = len(*m.GenerateName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Entrypoint != nil {
		l = len(*m.Entrypoint)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for _, s := range m.Parameters {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.ParameterFile != nil {
		l = len(*m.ParameterFile)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ServiceAccount != nil {
		l = len(*m.ServiceAccount)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DryRun != nil {
		n += 2
	}
	if m.ServerDryRun != nil {
		n += 2
	}
	if m.Labels != nil {
		l = len(*m.Labels)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.OwnerReference != nil {
		l = m.OwnerReference.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SuppliedValueFrom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SuspendTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Duration != nil {
		l = len(*m.Duration)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Synchronization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Semaphore != nil {
		l = m.Semaphore.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Mutex != nil {
		l = m.Mutex.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SynchronizationStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Semaphore != nil {
		l = m.Semaphore.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Mutex != nil {
		l = m.Mutex.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TTLStrategy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SecondsAfterCompletion != nil {
		n += 1 + sovGenerated(uint64(*m.SecondsAfterCompletion))
	}
	if m.SecondsAfterSuccess != nil {
		n += 1 + sovGenerated(uint64(*m.SecondsAfterSuccess))
	}
	if m.SecondsAfterFailure != nil {
		n += 1 + sovGenerated(uint64(*m.SecondsAfterFailure))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TarStrategy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompressionLevel != nil {
		n += 1 + sovGenerated(uint64(*m.CompressionLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Template) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Template != nil {
		l = len(*m.Template)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Arguments != nil {
		l = m.Arguments.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TemplateRef != nil {
		l = m.TemplateRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Inputs != nil {
		l = m.Inputs.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Outputs != nil {
		l = m.Outputs.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	if m.Affinity != nil {
		l = m.Affinity.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Daemon != nil {
		n += 2
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Container != nil {
		l = m.Container.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Script != nil {
		l = m.Script.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Dag != nil {
		l = m.Dag.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Suspend != nil {
		l = m.Suspend.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.InitContainers) > 0 {
		for _, e := range m.InitContainers {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Sidecars) > 0 {
		for _, e := range m.Sidecars {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	if m.ArchiveLocation != nil {
		l = m.ArchiveLocation.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.ActiveDeadlineSeconds != nil {
		l = m.ActiveDeadlineSeconds.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.RetryStrategy != nil {
		l = m.RetryStrategy.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Parallelism != nil {
		n += 2 + sovGenerated(uint64(*m.Parallelism))
	}
	if len(m.Tolerations) > 0 {
		for _, e := range m.Tolerations {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	if m.SchedulerName != nil {
		l = len(*m.SchedulerName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.PriorityClassName != nil {
		l = len(*m.PriorityClassName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Priority != nil {
		n += 2 + sovGenerated(uint64(*m.Priority))
	}
	if m.ServiceAccountName != nil {
		l = len(*m.ServiceAccountName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if len(m.HostAliases) > 0 {
		for _, e := range m.HostAliases {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	if m.SecurityContext != nil {
		l = m.SecurityContext.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.PodSpecPatch != nil {
		l = len(*m.PodSpecPatch)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.AutomountServiceAccountToken != nil {
		n += 3
	}
	if m.Executor != nil {
		l = m.Executor.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Synchronization != nil {
		l = m.Synchronization.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Memoize != nil {
		l = m.Memoize.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Timeout != nil {
		l = len(*m.Timeout)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TemplateRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Template != nil {
		l = len(*m.Template)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.RuntimeResolution != nil {
		n += 2
	}
	if m.ClusterScope != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Container != nil {
		l = m.Container.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.MirrorVolumeMounts != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValueFrom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Path != nil {
		l = len(*m.Path)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.JsonPath != nil {
		l = len(*m.JsonPath)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.JqFilter != nil {
		l = len(*m.JqFilter)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Parameter != nil {
		l = len(*m.Parameter)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Default != nil {
		l = len(*m.Default)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Supplied != nil {
		l = m.Supplied.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Event != nil {
		l = len(*m.Event)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.BuildDate != nil {
		l = len(*m.BuildDate)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GitCommit != nil {
		l = len(*m.GitCommit)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GitTag != nil {
		l = len(*m.GitTag)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GitTreeState != nil {
		l = len(*m.GitTreeState)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.GoVersion != nil {
		l = len(*m.GoVersion)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Compiler != nil {
		l = len(*m.Compiler)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Platform != nil {
		l = len(*m.Platform)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VolumeClaimGC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Strategy != nil {
		l = len(*m.Strategy)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Workflow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowEventBinding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowEventBindingList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowEventBindingSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Submit != nil {
		l = m.Submit.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Templates) > 0 {
		for _, e := range m.Templates {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Entrypoint != nil {
		l = len(*m.Entrypoint)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Arguments != nil {
		l = m.Arguments.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ServiceAccountName != nil {
		l = len(*m.ServiceAccountName)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.VolumeClaimTemplates) > 0 {
		for _, e := range m.VolumeClaimTemplates {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Parallelism != nil {
		n += 1 + sovGenerated(uint64(*m.Parallelism))
	}
	if m.ArtifactRepositoryRef != nil {
		l = m.ArtifactRepositoryRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Suspend != nil {
		n += 2
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	if m.Affinity != nil {
		l = m.Affinity.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Tolerations) > 0 {
		for _, e := range m.Tolerations {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, e := range m.ImagePullSecrets {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.HostNetwork != nil {
		n += 2
	}
	if m.DnsPolicy != nil {
		l = len(*m.DnsPolicy)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.DnsConfig != nil {
		l = m.DnsConfig.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.OnExit != nil {
		l = len(*m.OnExit)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.TtlSecondsAfterFinished != nil {
		n += 2 + sovGenerated(uint64(*m.TtlSecondsAfterFinished))
	}
	if m.ActiveDeadlineSeconds != nil {
		n += 2 + sovGenerated(uint64(*m.ActiveDeadlineSeconds))
	}
	if m.Priority != nil {
		n += 2 + sovGenerated(uint64(*m.Priority))
	}
	if m.SchedulerName != nil {
		l = len(*m.SchedulerName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.PodGC != nil {
		l = m.PodGC.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.PodPriorityClassName != nil {
		l = len(*m.PodPriorityClassName)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.PodPriority != nil {
		n += 2 + sovGenerated(uint64(*m.PodPriority))
	}
	if len(m.HostAliases) > 0 {
		for _, e := range m.HostAliases {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	if m.SecurityContext != nil {
		l = m.SecurityContext.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.PodSpecPatch != nil {
		l = len(*m.PodSpecPatch)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.AutomountServiceAccountToken != nil {
		n += 3
	}
	if m.Executor != nil {
		l = m.Executor.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.TtlStrategy != nil {
		l = m.TtlStrategy.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.PodDisruptionBudget != nil {
		l = m.PodDisruptionBudget.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Shutdown != nil {
		l = len(*m.Shutdown)
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.WorkflowTemplateRef != nil {
		l = m.WorkflowTemplateRef.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.Synchronization != nil {
		l = m.Synchronization.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.VolumeClaimGC != nil {
		l = m.VolumeClaimGC.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.RetryStrategy != nil {
		l = m.RetryStrategy.Size()
		n += 2 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Phase != nil {
		l = len(*m.Phase)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.FinishedAt != nil {
		l = m.FinishedAt.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CompressedNodes != nil {
		l = len(*m.CompressedNodes)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGenerated(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	if len(m.PersistentVolumeClaims) > 0 {
		for _, e := range m.PersistentVolumeClaims {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Outputs != nil {
		l = m.Outputs.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.StoredTemplates) > 0 {
		for k, v := range m.StoredTemplates {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGenerated(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	if m.OffloadNodeStatusVersion != nil {
		l = len(*m.OffloadNodeStatusVersion)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.ResourcesDuration) > 0 {
		for k, v := range m.ResourcesDuration {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + sovGenerated(uint64(v))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.StoredWorkflowTemplateSpec != nil {
		l = m.StoredWorkflowTemplateSpec.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Synchronization != nil {
		l = m.Synchronization.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.EstimatedDuration != nil {
		n += 2 + sovGenerated(uint64(*m.EstimatedDuration))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Template != nil {
		l = len(*m.Template)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Arguments != nil {
		l = m.Arguments.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.TemplateRef != nil {
		l = m.TemplateRef.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.WithItems) > 0 {
		for _, e := range m.WithItems {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.WithParam != nil {
		l = len(*m.WithParam)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.WithSequence != nil {
		l = m.WithSequence.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.When != nil {
		l = len(*m.When)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ContinueOn != nil {
		l = m.ContinueOn.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.OnExit != nil {
		l = len(*m.OnExit)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowTemplateList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowTemplateRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ClusterScope != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowTemplateSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkflowSpec != nil {
		l = m.WorkflowSpec.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.WorkflowMeta != nil {
		l = m.WorkflowMeta.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZipStrategy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGenerated(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenerated(x uint64) (n int) {
	return sovGenerated(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Amount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Amount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Amount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArchiveStrategy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArchiveStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArchiveStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tar == nil {
				m.Tar = &TarStrategy{}
			}
			if err := m.Tar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field None", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.None == nil {
				m.None = &NoneStrategy{}
			}
			if err := m.None.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zip == nil {
				m.Zip = &ZipStrategy{}
			}
			if err := m.Zip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Arguments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Arguments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Arguments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &Parameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifacts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Artifacts = append(m.Artifacts, &Artifact{})
			if err := m.Artifacts[len(m.Artifacts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Artifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Artifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Artifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Path = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mode = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.From = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArtifactLocation == nil {
				m.ArtifactLocation = &ArtifactLocation{}
			}
			if err := m.ArtifactLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GlobalName = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Archive == nil {
				m.Archive = &ArchiveStrategy{}
			}
			if err := m.Archive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Optional", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Optional = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SubPath = &s
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecurseMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RecurseMode = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArtifactLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArtifactLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArtifactLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchiveLogs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ArchiveLogs = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.S3 == nil {
				m.S3 = &S3Artifact{}
			}
			if err := m.S3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Git", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Git == nil {
				m.Git = &GitArtifact{}
			}
			if err := m.Git.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http == nil {
				m.Http = &HTTPArtifact{}
			}
			if err := m.Http.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifactory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Artifactory == nil {
				m.Artifactory = &ArtifactoryArtifact{}
			}
			if err := m.Artifactory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hdfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hdfs == nil {
				m.Hdfs = &HDFSArtifact{}
			}
			if err := m.Hdfs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Raw == nil {
				m.Raw = &RawArtifact{}
			}
			if err := m.Raw.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oss", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Oss == nil {
				m.Oss = &OSSArtifact{}
			}
			if err := m.Oss.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gcs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gcs == nil {
				m.Gcs = &GCSArtifact{}
			}
			if err := m.Gcs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArtifactRepositoryRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArtifactRepositoryRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArtifactRepositoryRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigMap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ConfigMap = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArtifactoryArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArtifactoryArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArtifactoryArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Url = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactoryAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArtifactoryAuth == nil {
				m.ArtifactoryAuth = &ArtifactoryAuth{}
			}
			if err := m.ArtifactoryAuth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArtifactoryAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArtifactoryAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArtifactoryAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsernameSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsernameSecret == nil {
				m.UsernameSecret = &v1.SecretKeySelector{}
			}
			if err := m.UsernameSecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PasswordSecret == nil {
				m.PasswordSecret = &v1.SecretKeySelector{}
			}
			if err := m.PasswordSecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Backoff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Backoff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Backoff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Duration = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Factor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Factor == nil {
				m.Factor = &intstr.IntOrString{}
			}
			if err := m.Factor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MaxDuration = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cache) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cache: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cache: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigMap == nil {
				m.ConfigMap = &v1.ConfigMapKeySelector{}
			}
			if err := m.ConfigMap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterWorkflowTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterWorkflowTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterWorkflowTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &v11.ObjectMeta{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &WorkflowTemplateSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterWorkflowTemplateList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterWorkflowTemplateList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterWorkflowTemplateList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &v11.ListMeta{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ClusterWorkflowTemplate{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Status = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContinueOn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContinueOn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContinueOn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Error = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Failed = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Counter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Counter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Counter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronWorkflow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronWorkflow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronWorkflow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &v11.ObjectMeta{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &CronWorkflowSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CronWorkflowStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronWorkflowList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronWorkflowList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronWorkflowList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &v11.ListMeta{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &CronWorkflow{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronWorkflowSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronWorkflowSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronWorkflowSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkflowSpec == nil {
				m.WorkflowSpec = &WorkflowSpec{}
			}
			if err := m.WorkflowSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Schedule = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcurrencyPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ConcurrencyPolicy = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suspend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Suspend = &b
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingDeadlineSeconds", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartingDeadlineSeconds = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessfulJobsHistoryLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SuccessfulJobsHistoryLimit = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedJobsHistoryLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FailedJobsHistoryLimit = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timezone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Timezone = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkflowMeta == nil {
				m.WorkflowMeta = &v11.ObjectMeta{}
			}
			if err := m.WorkflowMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronWorkflowStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronWorkflowStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronWorkflowStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Active = append(m.Active, &v1.ObjectReference{})
			if err := m.Active[len(m.Active)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastScheduledTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastScheduledTime == nil {
				m.LastScheduledTime = &v11.Time{}
			}
			if err := m.LastScheduledTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DAGTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DAGTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DAGTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Template = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arguments == nil {
				m.Arguments = &Arguments{}
			}
			if err := m.Arguments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemplateRef == nil {
				m.TemplateRef = &TemplateRef{}
			}
			if err := m.TemplateRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependencies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dependencies = append(m.Dependencies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithItems = append(m.WithItems, &Item{})
			if err := m.WithItems[len(m.WithItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithParam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WithParam = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithSequence == nil {
				m.WithSequence = &Sequence{}
			}
			if err := m.WithSequence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field When", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.When = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinueOn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContinueOn == nil {
				m.ContinueOn = &ContinueOn{}
			}
			if err := m.ContinueOn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OnExit = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depends", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Depends = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DAGTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DAGTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DAGTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Target = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, &DAGTask{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailFast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FailFast = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Selector = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutorConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutorConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutorConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServiceAccountName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCSArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCSArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCSArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCSBucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GCSBucket == nil {
				m.GCSBucket = &GCSBucket{}
			}
			if err := m.GCSBucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCSBucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCSBucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCSBucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Bucket = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccountKeySecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceAccountKeySecret == nil {
				m.ServiceAccountKeySecret = &v1.SecretKeySelector{}
			}
			if err := m.ServiceAccountKeySecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Gauge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gauge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gauge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Realtime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Realtime = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Repo = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Revision = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depth", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Depth = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fetch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fetch = append(m.Fetch, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsernameSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsernameSecret == nil {
				m.UsernameSecret = &v1.SecretKeySelector{}
			}
			if err := m.UsernameSecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PasswordSecret == nil {
				m.PasswordSecret = &v1.SecretKeySelector{}
			}
			if err := m.PasswordSecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshPrivateKeySecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SshPrivateKeySecret == nil {
				m.SshPrivateKeySecret = &v1.SecretKeySelector{}
			}
			if err := m.SshPrivateKeySecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsecureIgnoreHostKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.InsecureIgnoreHostKey = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HDFSArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HDFSArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HDFSArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HDFSConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HDFSConfig == nil {
				m.HDFSConfig = &HDFSConfig{}
			}
			if err := m.HDFSConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Path = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Force = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HDFSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HDFSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HDFSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HDFSKrbConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HDFSKrbConfig == nil {
				m.HDFSKrbConfig = &HDFSKrbConfig{}
			}
			if err := m.HDFSKrbConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HdfsUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HdfsUser = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HDFSKrbConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HDFSKrbConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HDFSKrbConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KrbCCacheSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KrbCCacheSecret == nil {
				m.KrbCCacheSecret = &v1.SecretKeySelector{}
			}
			if err := m.KrbCCacheSecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KrbKeytabSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KrbKeytabSecret == nil {
				m.KrbKeytabSecret = &v1.SecretKeySelector{}
			}
			if err := m.KrbKeytabSecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KrbUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.KrbUsername = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KrbRealm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.KrbRealm = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KrbConfigConfigMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KrbConfigConfigMap == nil {
				m.KrbConfigConfigMap = &v1.ConfigMapKeySelector{}
			}
			if err := m.KrbConfigConfigMap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KrbServicePrincipalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.KrbServicePrincipalName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Url = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Histogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Histogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Histogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buckets = append(m.Buckets, &Amount{})
			if err := m.Buckets[len(m.Buckets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Inputs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inputs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inputs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &Parameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifacts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Artifacts = append(m.Artifacts, &Artifact{})
			if err := m.Artifacts[len(m.Artifacts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Scope = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Url = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoizationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoizationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoizationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Hit = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CacheName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Memoize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Memoize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Memoize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cache == nil {
				m.Cache = &Cache{}
			}
			if err := m.Cache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MaxAge = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricLabel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricLabel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricLabel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prometheus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prometheus = append(m.Prometheus, &Prometheus{})
			if err := m.Prometheus[len(m.Prometheus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mutex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mutex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mutex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MutexHolding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MutexHolding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MutexHolding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Mutex = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Holder = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MutexStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MutexStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MutexStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holding = append(m.Holding, &MutexHolding{})
			if err := m.Holding[len(m.Holding)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waiting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Waiting = append(m.Waiting, &MutexHolding{})
			if err := m.Waiting[len(m.Waiting)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DisplayName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TemplateName = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemplateRef == nil {
				m.TemplateRef = &TemplateRef{}
			}
			if err := m.TemplateRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Phase = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundaryID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BoundaryID = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &v11.Time{}
			}
			if err := m.StartedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinishedAt == nil {
				m.FinishedAt = &v11.Time{}
			}
			if err := m.FinishedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PodIP = &s
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Daemoned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Daemoned = &b
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inputs == nil {
				m.Inputs = &Inputs{}
			}
			if err := m.Inputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outputs == nil {
				m.Outputs = &Outputs{}
			}
			if err := m.Outputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutboundNodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutboundNodes = append(m.OutboundNodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoredTemplateID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.StoredTemplateID = &s
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowTemplateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkflowTemplateName = &s
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateScope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TemplateScope = &s
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcesDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourcesDuration == nil {
				m.ResourcesDuration = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResourcesDuration[mapkey] = mapvalue
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HostNodeName = &s
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoizationStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoizationStatus == nil {
				m.MemoizationStatus = &MemoizationStatus{}
			}
			if err := m.MemoizationStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedDuration", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EstimatedDuration = &v
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynchronizationStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SynchronizationStatus == nil {
				m.SynchronizationStatus = &NodeSynchronizationStatus{}
			}
			if err := m.SynchronizationStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeSynchronizationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeSynchronizationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeSynchronizationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waiting", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Waiting = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoneStrategy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoneStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoneStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSSArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSSArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSSArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OSSBucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OSSBucket == nil {
				m.OSSBucket = &OSSBucket{}
			}
			if err := m.OSSBucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSSBucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSSBucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSSBucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Endpoint = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Bucket = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKeySecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessKeySecret == nil {
				m.AccessKeySecret = &v1.SecretKeySelector{}
			}
			if err := m.AccessKeySecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKeySecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretKeySecret == nil {
				m.SecretKeySecret = &v1.SecretKeySelector{}
			}
			if err := m.SecretKeySecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Outputs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Outputs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Outputs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &Parameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifacts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Artifacts = append(m.Artifacts, &Artifact{})
			if err := m.Artifacts[len(m.Artifacts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Result = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ExitCode = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParallelSteps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParallelSteps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParallelSteps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &WorkflowStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Parameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Default = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValueFrom == nil {
				m.ValueFrom = &ValueFrom{}
			}
			if err := m.ValueFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GlobalName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodGC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodGC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodGC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Strategy = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prometheus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prometheus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prometheus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &MetricLabel{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Help", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Help = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field When", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.When = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gauge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gauge == nil {
				m.Gauge = &Gauge{}
			}
			if err := m.Gauge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Histogram", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Histogram == nil {
				m.Histogram = &Histogram{}
			}
			if err := m.Histogram.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Counter == nil {
				m.Counter = &Counter{}
			}
			if err := m.Counter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Data = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Action = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MergeStrategy = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manifest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Manifest = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetOwnerReference", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SetOwnerReference = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessCondition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SuccessCondition = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureCondition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FailureCondition = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flags = append(m.Flags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryStrategy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &intstr.IntOrString{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RetryPolicy = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backoff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Backoff == nil {
				m.Backoff = &Backoff{}
			}
			if err := m.Backoff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S3Artifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S3Artifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S3Artifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3Bucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.S3Bucket == nil {
				m.S3Bucket = &S3Bucket{}
			}
			if err := m.S3Bucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S3Bucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S3Bucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S3Bucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Endpoint = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Bucket = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Region = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insecure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Insecure = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKeySecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessKeySecret == nil {
				m.AccessKeySecret = &v1.SecretKeySelector{}
			}
			if err := m.AccessKeySecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKeySecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretKeySecret == nil {
				m.SecretKeySecret = &v1.SecretKeySelector{}
			}
			if err := m.SecretKeySecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleARN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RoleARN = &s
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSDKCreds", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UseSDKCreds = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScriptTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScriptTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScriptTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &v1.Container{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Source = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SemaphoreHolding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SemaphoreHolding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SemaphoreHolding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Semaphore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Semaphore = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holders = append(m.Holders, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SemaphoreRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SemaphoreRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SemaphoreRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigMapKeyRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigMapKeyRef == nil {
				m.ConfigMapKeyRef = &v1.ConfigMapKeySelector{}
			}
			if err := m.ConfigMapKeyRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SemaphoreStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SemaphoreStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SemaphoreStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holding = append(m.Holding, &SemaphoreHolding{})
			if err := m.Holding[len(m.Holding)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waiting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Waiting = append(m.Waiting, &SemaphoreHolding{})
			if err := m.Waiting[len(m.Waiting)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Count == nil {
				m.Count = &intstr.IntOrString{}
			}
			if err := m.Count.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &intstr.IntOrString{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &intstr.IntOrString{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Format = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Submit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Submit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Submit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowTemplateRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkflowTemplateRef == nil {
				m.WorkflowTemplateRef = &WorkflowTemplateRef{}
			}
			if err := m.WorkflowTemplateRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arguments == nil {
				m.Arguments = &Arguments{}
			}
			if err := m.Arguments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitOpts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitOpts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitOpts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GenerateName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entrypoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Entrypoint = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ParameterFile = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServiceAccount = &s
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DryRun = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerDryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ServerDryRun = &b
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Labels = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerReference == nil {
				m.OwnerReference = &v11.OwnerReference{}
			}
			if err := m.OwnerReference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuppliedValueFrom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuppliedValueFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuppliedValueFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuspendTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuspendTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuspendTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Duration = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Synchronization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Synchronization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Synchronization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Semaphore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Semaphore == nil {
				m.Semaphore = &SemaphoreRef{}
			}
			if err := m.Semaphore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mutex == nil {
				m.Mutex = &Mutex{}
			}
			if err := m.Mutex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SynchronizationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SynchronizationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SynchronizationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Semaphore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Semaphore == nil {
				m.Semaphore = &SemaphoreStatus{}
			}
			if err := m.Semaphore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mutex == nil {
				m.Mutex = &MutexStatus{}
			}
			if err := m.Mutex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TTLStrategy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TTLStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TTLStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondsAfterCompletion", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SecondsAfterCompletion = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondsAfterSuccess", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SecondsAfterSuccess = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondsAfterFailure", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SecondsAfterFailure = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TarStrategy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TarStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TarStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CompressionLevel = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Template) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Template: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Template: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Template = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arguments == nil {
				m.Arguments = &Arguments{}
			}
			if err := m.Arguments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemplateRef == nil {
				m.TemplateRef = &TemplateRef{}
			}
			if err := m.TemplateRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inputs == nil {
				m.Inputs = &Inputs{}
			}
			if err := m.Inputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outputs == nil {
				m.Outputs = &Outputs{}
			}
			if err := m.Outputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Affinity == nil {
				m.Affinity = &v1.Affinity{}
			}
			if err := m.Affinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Daemon", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Daemon = &b
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &ParallelSteps{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &v1.Container{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Script == nil {
				m.Script = &ScriptTemplate{}
			}
			if err := m.Script.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &ResourceTemplate{}
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dag == nil {
				m.Dag = &DAGTemplate{}
			}
			if err := m.Dag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suspend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Suspend == nil {
				m.Suspend = &SuspendTemplate{}
			}
			if err := m.Suspend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, &v1.Volume{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitContainers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitContainers = append(m.InitContainers, &UserContainer{})
			if err := m.InitContainers[len(m.InitContainers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sidecars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sidecars = append(m.Sidecars, &UserContainer{})
			if err := m.Sidecars[len(m.Sidecars)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchiveLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArchiveLocation == nil {
				m.ArchiveLocation = &ArtifactLocation{}
			}
			if err := m.ArchiveLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDeadlineSeconds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActiveDeadlineSeconds == nil {
				m.ActiveDeadlineSeconds = &intstr.IntOrString{}
			}
			if err := m.ActiveDeadlineSeconds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryStrategy == nil {
				m.RetryStrategy = &RetryStrategy{}
			}
			if err := m.RetryStrategy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallelism", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Parallelism = &v
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tolerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tolerations = append(m.Tolerations, &v1.Toleration{})
			if err := m.Tolerations[len(m.Tolerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SchedulerName = &s
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PriorityClassName = &s
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Priority = &v
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServiceAccountName = &s
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAliases = append(m.HostAliases, &v1.HostAlias{})
			if err := m.HostAliases[len(m.HostAliases)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityContext == nil {
				m.SecurityContext = &v1.PodSecurityContext{}
			}
			if err := m.SecurityContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpecPatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PodSpecPatch = &s
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomountServiceAccountToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AutomountServiceAccountToken = &b
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Executor == nil {
				m.Executor = &ExecutorConfig{}
			}
			if err := m.Executor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &Metrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Synchronization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Synchronization == nil {
				m.Synchronization = &Synchronization{}
			}
			if err := m.Synchronization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memoize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memoize == nil {
				m.Memoize = &Memoize{}
			}
			if err := m.Memoize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Timeout = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TemplateRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TemplateRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TemplateRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Template = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeResolution", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RuntimeResolution = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterScope", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ClusterScope = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &v1.Container{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorVolumeMounts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MirrorVolumeMounts = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueFrom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Path = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.JsonPath = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JqFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.JqFilter = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Parameter = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Default = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supplied", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Supplied == nil {
				m.Supplied = &SuppliedValueFrom{}
			}
			if err := m.Supplied.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Event = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BuildDate = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitCommit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GitCommit = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GitTag = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitTreeState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GitTreeState = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GoVersion = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compiler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Compiler = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Platform = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeClaimGC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeClaimGC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeClaimGC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Strategy = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Workflow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Workflow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Workflow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &v11.ObjectMeta{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &WorkflowSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &WorkflowStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowEventBinding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowEventBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowEventBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &v11.ObjectMeta{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &WorkflowEventBindingSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowEventBindingList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowEventBindingList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowEventBindingList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &v11.ListMeta{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &WorkflowEventBinding{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowEventBindingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowEventBindingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowEventBindingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &Event{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Submit == nil {
				m.Submit = &Submit{}
			}
			if err := m.Submit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &v11.ListMeta{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Workflow{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Templates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Templates = append(m.Templates, &Template{})
			if err := m.Templates[len(m.Templates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entrypoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Entrypoint = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arguments == nil {
				m.Arguments = &Arguments{}
			}
			if err := m.Arguments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServiceAccountName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, &v1.Volume{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeClaimTemplates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeClaimTemplates = append(m.VolumeClaimTemplates, &v1.PersistentVolumeClaim{})
			if err := m.VolumeClaimTemplates[len(m.VolumeClaimTemplates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallelism", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Parallelism = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactRepositoryRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArtifactRepositoryRef == nil {
				m.ArtifactRepositoryRef = &ArtifactRepositoryRef{}
			}
			if err := m.ArtifactRepositoryRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suspend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Suspend = &b
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Affinity == nil {
				m.Affinity = &v1.Affinity{}
			}
			if err := m.Affinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tolerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tolerations = append(m.Tolerations, &v1.Toleration{})
			if err := m.Tolerations[len(m.Tolerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullSecrets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullSecrets = append(m.ImagePullSecrets, &v1.LocalObjectReference{})
			if err := m.ImagePullSecrets[len(m.ImagePullSecrets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNetwork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HostNetwork = &b
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DnsPolicy = &s
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DnsConfig == nil {
				m.DnsConfig = &v1.PodDNSConfig{}
			}
			if err := m.DnsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OnExit = &s
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlSecondsAfterFinished", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TtlSecondsAfterFinished = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDeadlineSeconds", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ActiveDeadlineSeconds = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Priority = &v
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SchedulerName = &s
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodGC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodGC == nil {
				m.PodGC = &PodGC{}
			}
			if err := m.PodGC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodPriorityClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PodPriorityClassName = &s
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodPriority", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PodPriority = &v
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAliases = append(m.HostAliases, &v1.HostAlias{})
			if err := m.HostAliases[len(m.HostAliases)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityContext == nil {
				m.SecurityContext = &v1.PodSecurityContext{}
			}
			if err := m.SecurityContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpecPatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PodSpecPatch = &s
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomountServiceAccountToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AutomountServiceAccountToken = &b
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Executor == nil {
				m.Executor = &ExecutorConfig{}
			}
			if err := m.Executor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TtlStrategy == nil {
				m.TtlStrategy = &TTLStrategy{}
			}
			if err := m.TtlStrategy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodDisruptionBudget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodDisruptionBudget == nil {
				m.PodDisruptionBudget = &v1beta1.PodDisruptionBudgetSpec{}
			}
			if err := m.PodDisruptionBudget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &Metrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shutdown", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Shutdown = &s
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowTemplateRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkflowTemplateRef == nil {
				m.WorkflowTemplateRef = &WorkflowTemplateRef{}
			}
			if err := m.WorkflowTemplateRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Synchronization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Synchronization == nil {
				m.Synchronization = &Synchronization{}
			}
			if err := m.Synchronization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeClaimGC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeClaimGC == nil {
				m.VolumeClaimGC = &VolumeClaimGC{}
			}
			if err := m.VolumeClaimGC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryStrategy == nil {
				m.RetryStrategy = &RetryStrategy{}
			}
			if err := m.RetryStrategy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Phase = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &v11.Time{}
			}
			if err := m.StartedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinishedAt == nil {
				m.FinishedAt = &v11.Time{}
			}
			if err := m.FinishedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressedNodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CompressedNodes = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nodes == nil {
				m.Nodes = make(map[string]*NodeStatus)
			}
			var mapkey string
			var mapvalue *NodeStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGenerated
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGenerated
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NodeStatus{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistentVolumeClaims", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistentVolumeClaims = append(m.PersistentVolumeClaims, &v1.Volume{})
			if err := m.PersistentVolumeClaims[len(m.PersistentVolumeClaims)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outputs == nil {
				m.Outputs = &Outputs{}
			}
			if err := m.Outputs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoredTemplates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StoredTemplates == nil {
				m.StoredTemplates = make(map[string]*Template)
			}
			var mapkey string
			var mapvalue *Template
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGenerated
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGenerated
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Template{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StoredTemplates[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffloadNodeStatusVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OffloadNodeStatusVersion = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcesDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourcesDuration == nil {
				m.ResourcesDuration = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResourcesDuration[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoredWorkflowTemplateSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StoredWorkflowTemplateSpec == nil {
				m.StoredWorkflowTemplateSpec = &WorkflowSpec{}
			}
			if err := m.StoredWorkflowTemplateSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Synchronization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Synchronization == nil {
				m.Synchronization = &SynchronizationStatus{}
			}
			if err := m.Synchronization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedDuration", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EstimatedDuration = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Template = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arguments == nil {
				m.Arguments = &Arguments{}
			}
			if err := m.Arguments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemplateRef == nil {
				m.TemplateRef = &TemplateRef{}
			}
			if err := m.TemplateRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithItems = append(m.WithItems, &Item{})
			if err := m.WithItems[len(m.WithItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithParam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WithParam = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithSequence == nil {
				m.WithSequence = &Sequence{}
			}
			if err := m.WithSequence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field When", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.When = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinueOn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContinueOn == nil {
				m.ContinueOn = &ContinueOn{}
			}
			if err := m.ContinueOn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OnExit = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &v11.ObjectMeta{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &WorkflowTemplateSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowTemplateList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowTemplateList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowTemplateList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &v11.ListMeta{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &WorkflowTemplate{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowTemplateRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowTemplateRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowTemplateRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterScope", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ClusterScope = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowTemplateSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowTemplateSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowTemplateSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkflowSpec == nil {
				m.WorkflowSpec = &WorkflowSpec{}
			}
			if err := m.WorkflowSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkflowMeta == nil {
				m.WorkflowMeta = &v11.ObjectMeta{}
			}
			if err := m.WorkflowMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZipStrategy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZipStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZipStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenerated(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenerated
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenerated
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenerated
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenerated        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenerated          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenerated = fmt.Errorf("proto: unexpected end of group")
)
