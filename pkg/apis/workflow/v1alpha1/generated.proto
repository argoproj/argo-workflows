
// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.argoproj.argo_workflows.v3.pkg.apis.workflow.v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/api/policy/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

// Amount represent a numeric amount.
// +kubebuilder:validation:Type=number
message Amount {
  optional string value = 1;
}

// ArchiveStrategy describes how to archive files/directory when saving artifacts
message ArchiveStrategy {
  optional TarStrategy tar = 1;

  optional NoneStrategy none = 2;

  optional ZipStrategy zip = 3;
}

// Arguments to a template
message Arguments {
  // Parameters is the list of parameters to pass to the template or workflow
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated Parameter parameters = 1;

  // Artifacts is the list of artifacts to pass to the template or workflow
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated Artifact artifacts = 2;
}

// ArtGCStatus maintains state related to ArtifactGC
message ArtGCStatus {
  // have Pods been started to perform this strategy? (enables us not to re-process what we've already done)
  map<string, bool> strategiesProcessed = 1;

  // have completed Pods been processed? (mapped by Pod name)
  // used to prevent re-processing the Status of a Pod more than once
  map<string, bool> podsRecouped = 2;

  // if this is true, we already checked to see if we need to do it and we don't
  optional bool notSpecified = 3;
}

// Artifact indicates an artifact to place at a specified path
message Artifact {
  // name of the artifact. must be unique within a template's inputs/outputs.
  optional string name = 1;

  // Path is the container path to the artifact
  optional string path = 2;

  // mode bits to use on this file, must be a value between 0 and 0777
  // set when loading input artifacts.
  optional int32 mode = 3;

  // From allows an artifact to reference an artifact from a previous step
  optional string from = 4;

  // ArtifactLocation contains the location of the artifact
  optional ArtifactLocation artifactLocation = 5;

  // GlobalName exports an output artifact to the global scope, making it available as
  // '{{workflow.outputs.artifacts.XXXX}} and in workflow.status.outputs.artifacts
  optional string globalName = 6;

  // Archive controls how the artifact will be saved to the artifact repository.
  optional ArchiveStrategy archive = 7;

  // Make Artifacts optional, if Artifacts doesn't generate or exist
  optional bool optional = 8;

  // SubPath allows an artifact to be sourced from a subpath within the specified source
  optional string subPath = 9;

  // If mode is set, apply the permission recursively into the artifact if it is a folder
  optional bool recurseMode = 10;

  // FromExpression, if defined, is evaluated to specify the value for the artifact
  optional string fromExpression = 11;

  // ArtifactGC describes the strategy to use when to deleting an artifact from completed or deleted workflows
  optional ArtifactGC artifactGC = 12;

  // Has this been deleted?
  optional bool deleted = 13;
}

// ArtifactGC describes how to delete artifacts from completed Workflows - this is embedded into the WorkflowLevelArtifactGC, and also used for individual Artifacts to override that as needed
message ArtifactGC {
  // Strategy is the strategy to use.
  // +kubebuilder:validation:Enum="";OnWorkflowCompletion;OnWorkflowDeletion;Never
  optional string strategy = 1;

  // PodMetadata is an optional field for specifying the Labels and Annotations that should be assigned to the Pod doing the deletion
  optional Metadata podMetadata = 2;

  // ServiceAccountName is an optional field for specifying the Service Account that should be assigned to the Pod doing the deletion
  optional string serviceAccountName = 3;
}

// ArtifactGCSpec specifies the Artifacts that need to be deleted
message ArtifactGCSpec {
  // ArtifactsByNode maps Node name to information pertaining to Artifacts on that Node
  map<string, ArtifactNodeSpec> artifactsByNode = 1;
}

// ArtifactGCStatus describes the result of the deletion
message ArtifactGCStatus {
  // ArtifactResultsByNode maps Node name to result
  map<string, ArtifactResultNodeStatus> artifactResultsByNode = 1;
}

// ArtifactLocation describes a location for a single or multiple artifacts.
// It is used as single artifact in the context of inputs/outputs (e.g. outputs.artifacts.artname).
// It is also used to describe the location of multiple artifacts such as the archive location
// of a single workflow step, which the executor will use as a default location to store its files.
message ArtifactLocation {
  // ArchiveLogs indicates if the container logs should be archived
  optional bool archiveLogs = 1;

  // S3 contains S3 artifact location details
  optional S3Artifact s3 = 2;

  // Git contains git artifact location details
  optional GitArtifact git = 3;

  // HTTP contains HTTP artifact location details
  optional HTTPArtifact http = 4;

  // Artifactory contains artifactory artifact location details
  optional ArtifactoryArtifact artifactory = 5;

  // HDFS contains HDFS artifact location details
  optional HDFSArtifact hdfs = 6;

  // Raw contains raw artifact location details
  optional RawArtifact raw = 7;

  // OSS contains OSS artifact location details
  optional OSSArtifact oss = 8;

  // GCS contains GCS artifact location details
  optional GCSArtifact gcs = 9;

  // Azure contains Azure Storage artifact location details
  optional AzureArtifact azure = 10;
}

// ArtifactNodeSpec specifies the Artifacts that need to be deleted for a given Node
message ArtifactNodeSpec {
  // ArchiveLocation is the template-level Artifact location specification
  optional ArtifactLocation archiveLocation = 1;

  // Artifacts maps artifact name to Artifact description
  map<string, Artifact> artifacts = 2;
}

// ArtifactPaths expands a step from a collection of artifacts
message ArtifactPaths {
  // Artifact is the artifact location from which to source the artifacts, it can be a directory
  optional Artifact artifact = 1;
}

// ArtifactRepository represents an artifact repository in which a controller will store its artifacts
message ArtifactRepository {
  // ArchiveLogs enables log archiving
  optional bool archiveLogs = 1;

  // S3 stores artifact in a S3-compliant object store
  optional S3ArtifactRepository s3 = 2;

  // Artifactory stores artifacts to JFrog Artifactory
  optional ArtifactoryArtifactRepository artifactory = 3;

  // HDFS stores artifacts in HDFS
  optional HDFSArtifactRepository hdfs = 4;

  // OSS stores artifact in a OSS-compliant object store
  optional OSSArtifactRepository oss = 5;

  // GCS stores artifact in a GCS object store
  optional GCSArtifactRepository gcs = 6;

  // Azure stores artifact in an Azure Storage account
  optional AzureArtifactRepository azure = 7;
}

// +protobuf.options.(gogoproto.goproto_stringer)=false
message ArtifactRepositoryRef {
  // The name of the config map. Defaults to "artifact-repositories".
  optional string configMap = 1;

  // The config map key. Defaults to the value of the "workflows.argoproj.io/default-artifact-repository" annotation.
  optional string key = 2;
}

// +protobuf.options.(gogoproto.goproto_stringer)=false
message ArtifactRepositoryRefStatus {
  optional ArtifactRepositoryRef artifactRepositoryRef = 1;

  // The namespace of the config map. Defaults to the workflow's namespace, or the controller's namespace (if found).
  optional string namespace = 2;

  // If this ref represents the default artifact repository, rather than a config map.
  optional bool default = 3;

  // The repository the workflow will use. This maybe empty before v3.1.
  optional ArtifactRepository artifactRepository = 4;
}

// ArtifactResult describes the result of attempting to delete a given Artifact
message ArtifactResult {
  // Name is the name of the Artifact
  optional string name = 1;

  // Success describes whether the deletion succeeded
  optional bool success = 2;

  // Error is an optional error message which should be set if Success==false
  optional string error = 3;
}

// ArtifactResultNodeStatus describes the result of the deletion on a given node
message ArtifactResultNodeStatus {
  // ArtifactResults maps Artifact name to result of the deletion
  map<string, ArtifactResult> artifactResults = 1;
}

message ArtifactSearchQuery {
  map<string, bool> artifactGCStrategies = 1;

  optional string artifactName = 2;

  optional string templateName = 3;

  optional string nodeId = 4;

  optional bool deleted = 5;

  map<string, bool> nodeTypes = 6;
}

message ArtifactSearchResult {
  optional Artifact artifact = 1;

  optional string nodeID = 2;
}

// ArtifactoryArtifact is the location of an artifactory artifact
message ArtifactoryArtifact {
  // URL of the artifact
  optional string url = 1;

  optional ArtifactoryAuth artifactoryAuth = 2;
}

// ArtifactoryArtifactRepository defines the controller configuration for an artifactory artifact repository
message ArtifactoryArtifactRepository {
  optional ArtifactoryAuth artifactoryAuth = 1;

  // RepoURL is the url for artifactory repo.
  optional string repoURL = 2;

  // KeyFormat defines the format of how to store keys and can reference workflow variables.
  optional string keyFormat = 3;
}

// ArtifactoryAuth describes the secret selectors required for authenticating to artifactory
message ArtifactoryAuth {
  // UsernameSecret is the secret selector to the repository username
  optional k8s.io.api.core.v1.SecretKeySelector usernameSecret = 1;

  // PasswordSecret is the secret selector to the repository password
  optional k8s.io.api.core.v1.SecretKeySelector passwordSecret = 2;
}

// AzureArtifact is the location of an Azure Storage artifact
message AzureArtifact {
  optional AzureBlobContainer azureBlobContainer = 1;

  // Blob is the blob name (i.e., path) in the container where the artifact resides
  optional string blob = 2;
}

// AzureArtifactRepository defines the controller configuration for an Azure Blob Storage artifact repository
message AzureArtifactRepository {
  optional AzureBlobContainer blobContainer = 1;

  // BlobNameFormat is defines the format of how to store blob names. Can reference workflow variables
  optional string blobNameFormat = 2;
}

// AzureBlobContainer contains the access information for interfacing with an Azure Blob Storage container
message AzureBlobContainer {
  // Endpoint is the service url associated with an account. It is most likely "https://<ACCOUNT_NAME>.blob.core.windows.net"
  optional string endpoint = 1;

  // Container is the container where resources will be stored
  optional string container = 2;

  // AccountKeySecret is the secret selector to the Azure Blob Storage account access key
  optional k8s.io.api.core.v1.SecretKeySelector accountKeySecret = 3;

  // UseSDKCreds tells the driver to figure out credentials based on sdk defaults.
  optional bool useSDKCreds = 4;
}

// Backoff is a backoff strategy to use within retryStrategy
message Backoff {
  // Duration is the amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h")
  optional string duration = 1;

  // Factor is a factor to multiply the base duration after each failed retry
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString factor = 2;

  // MaxDuration is the maximum amount of time allowed for a workflow in the backoff strategy.
  // It is important to note that if the workflow template includes activeDeadlineSeconds, the pod's deadline is initially set with activeDeadlineSeconds.
  // However, when the workflow fails, the pod's deadline is then overridden by maxDuration.
  // This ensures that the workflow does not exceed the specified maximum duration when retries are involved.
  optional string maxDuration = 3;

  // Cap is a limit on revised values of the duration parameter. If a
  // multiplication by the factor parameter would make the duration
  // exceed the cap then the duration is set to the cap
  optional string cap = 4;
}

// BasicAuth describes the secret selectors required for basic authentication
message BasicAuth {
  // UsernameSecret is the secret selector to the repository username
  optional k8s.io.api.core.v1.SecretKeySelector usernameSecret = 1;

  // PasswordSecret is the secret selector to the repository password
  optional k8s.io.api.core.v1.SecretKeySelector passwordSecret = 2;
}

// Cache is the configuration for the type of cache to be used
message Cache {
  // ConfigMap sets a ConfigMap-based cache
  optional k8s.io.api.core.v1.ConfigMapKeySelector configMap = 1;
}

// ClientCertAuth holds necessary information for client authentication via certificates
message ClientCertAuth {
  optional k8s.io.api.core.v1.SecretKeySelector clientCertSecret = 1;

  optional k8s.io.api.core.v1.SecretKeySelector clientKeySecret = 2;
}

// ClusterWorkflowTemplate is the definition of a workflow template resource in cluster scope
// +genclient
// +genclient:noStatus
// +genclient:nonNamespaced
// +kubebuilder:resource:scope=Cluster,shortName=clusterwftmpl;cwft
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ClusterWorkflowTemplate {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional WorkflowSpec spec = 2;
}

// ClusterWorkflowTemplateList is list of ClusterWorkflowTemplate resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ClusterWorkflowTemplateList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ClusterWorkflowTemplate items = 2;
}

// Column is a custom column that will be exposed in the Workflow List View.
// +patchStrategy=merge
// +patchMergeKey=name
message Column {
  // The name of this column, e.g., "Workflow Completed".
  optional string name = 1;

  // The type of this column, "label" or "annotation".
  optional string type = 2;

  // The key of the label or annotation, e.g., "workflows.argoproj.io/completed".
  optional string key = 3;
}

message Condition {
  // Type is the type of condition
  optional string type = 1;

  // Status is the status of the condition
  optional string status = 2;

  // Message is the condition message
  optional string message = 3;
}

message ContainerNode {
  optional k8s.io.api.core.v1.Container container = 1;

  repeated string dependencies = 2;
}

// ContainerSetRetryStrategy provides controls on how to retry a container set
message ContainerSetRetryStrategy {
  // Duration is the time between each retry, examples values are "300ms", "1s" or "5m".
  // Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h".
  optional string duration = 1;

  // Retries is the maximum number of retry attempts for each container. It does not include the
  // first, original attempt; the maximum number of total attempts will be `retries + 1`.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString retries = 2;
}

message ContainerSetTemplate {
  repeated ContainerNode containers = 4;

  repeated k8s.io.api.core.v1.VolumeMount volumeMounts = 3;

  // RetryStrategy describes how to retry container nodes if the container set fails.
  // Note that this works differently from the template-level `retryStrategy` as it is a process-level retry that does not create new Pods or containers.
  optional ContainerSetRetryStrategy retryStrategy = 5;
}

// ContinueOn defines if a workflow should continue even if a task or step fails/errors.
// It can be specified if the workflow should continue when the pod errors, fails or both.
message ContinueOn {
  // +optional
  optional bool error = 1;

  // +optional
  optional bool failed = 2;
}

// Counter is a Counter prometheus metric
message Counter {
  // Value is the value of the metric
  optional string value = 1;
}

// CreateS3BucketOptions options used to determine automatic automatic bucket-creation process
message CreateS3BucketOptions {
  // ObjectLocking Enable object locking
  optional bool objectLocking = 3;
}

// CronWorkflow is the definition of a scheduled workflow resource
// +genclient
// +genclient:noStatus
// +kubebuilder:resource:shortName=cwf;cronwf
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message CronWorkflow {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional CronWorkflowSpec spec = 2;

  optional CronWorkflowStatus status = 3;
}

// CronWorkflowList is list of CronWorkflow resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message CronWorkflowList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated CronWorkflow items = 2;
}

// CronWorkflowSpec is the specification of a CronWorkflow
message CronWorkflowSpec {
  // WorkflowSpec is the spec of the workflow to be run
  optional WorkflowSpec workflowSpec = 1;

  // Schedule is a schedule to run the Workflow in Cron format. Deprecated, use Schedules
  optional string schedule = 2;

  // ConcurrencyPolicy is the K8s-style concurrency policy that will be used
  optional string concurrencyPolicy = 3;

  // Suspend is a flag that will stop new CronWorkflows from running if set to true
  optional bool suspend = 4;

  // StartingDeadlineSeconds is the K8s-style deadline that will limit the time a CronWorkflow will be run after its
  // original scheduled time if it is missed.
  optional int64 startingDeadlineSeconds = 5;

  // SuccessfulJobsHistoryLimit is the number of successful jobs to be kept at a time
  optional int32 successfulJobsHistoryLimit = 6;

  // FailedJobsHistoryLimit is the number of failed jobs to be kept at a time
  optional int32 failedJobsHistoryLimit = 7;

  // Timezone is the timezone against which the cron schedule will be calculated, e.g. "Asia/Tokyo". Default is machine's local time.
  optional string timezone = 8;

  // WorkflowMetadata contains some metadata of the workflow to be run
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta workflowMeta = 9;

  // v3.6 and after: StopStrategy defines if the CronWorkflow should stop scheduling based on a condition
  optional StopStrategy stopStrategy = 10;

  // v3.6 and after: Schedules is a list of schedules to run the Workflow in Cron format
  repeated string schedules = 11;

  // v3.6 and after: When is an expression that determines if a run should be scheduled.
  optional string when = 12;
}

// CronWorkflowStatus is the status of a CronWorkflow
message CronWorkflowStatus {
  // Active is a list of active workflows stemming from this CronWorkflow
  // +optional
  repeated k8s.io.api.core.v1.ObjectReference active = 1;

  // LastScheduleTime is the last time the CronWorkflow was scheduled
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScheduledTime = 2;

  // Conditions is a list of conditions the CronWorkflow may have
  // +optional
  repeated Condition conditions = 3;

  // v3.6 and after: Succeeded counts how many times child workflows succeeded
  // +optional
  optional int64 succeeded = 4;

  // v3.6 and after: Failed counts how many times child workflows failed
  // +optional
  optional int64 failed = 5;

  // v3.6 and after: Phase is an enum of Active or Stopped. It changes to Stopped when stopStrategy.expression is true
  // +optional
  optional string phase = 6;
}

// DAGTask represents a node in the graph during DAG execution
message DAGTask {
  // Name is the name of the target
  optional string name = 1;

  // Name of template to execute
  optional string template = 2;

  // Inline is the template. Template must be empty if this is declared (and vice-versa).
  // Note: As mentioned in the corresponding definition in WorkflowStep, this struct is defined recursively,
  // so we need "x-kubernetes-preserve-unknown-fields: true" in the validation schema.
  // +kubebuilder:pruning:PreserveUnknownFields
  optional Template inline = 14;

  // Arguments are the parameter and artifact arguments to the template
  optional Arguments arguments = 3;

  // TemplateRef is the reference to the template resource to execute.
  optional TemplateRef templateRef = 4;

  // Dependencies are name of other targets which this depends on
  repeated string dependencies = 5;

  // WithItems expands a task into multiple parallel tasks from the items in the list
  // Note: The structure of WithItems is free-form, so we need
  // "x-kubernetes-preserve-unknown-fields: true" in the validation schema.
  // +kubebuilder:validation:Schemaless
  // +kubebuilder:pruning:PreserveUnknownFields
  repeated Item withItems = 6;

  // WithParam expands a task into multiple parallel tasks from the value in the parameter,
  // which is expected to be a JSON list.
  optional string withParam = 7;

  // WithSequence expands a task into a numeric sequence
  optional Sequence withSequence = 8;

  // When is an expression in which the task should conditionally execute
  optional string when = 9;

  // ContinueOn makes argo to proceed with the following step even if this step fails.
  // Errors and Failed states can be specified
  optional ContinueOn continueOn = 10;

  // OnExit is a template reference which is invoked at the end of the
  // template, irrespective of the success, failure, or error of the
  // primary template.
  // DEPRECATED: Use Hooks[exit].Template instead.
  optional string onExit = 11;

  // Depends are name of other targets which this depends on
  optional string depends = 12;

  // Hooks hold the lifecycle hook which is invoked at lifecycle of
  // task, irrespective of the success, failure, or error status of the primary task
  map<string, LifecycleHook> hooks = 13;
}

// DAGTemplate is a template subtype for directed acyclic graph templates
message DAGTemplate {
  // Target are one or more names of targets to execute in a DAG
  optional string target = 1;

  // Tasks are a list of DAG tasks
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated DAGTask tasks = 2;

  // This flag is for DAG logic. The DAG logic has a built-in "fail fast" feature to stop scheduling new steps,
  // as soon as it detects that one of the DAG nodes is failed. Then it waits until all DAG nodes are completed
  // before failing the DAG itself.
  // The FailFast flag default is true,  if set to false, it will allow a DAG to run all branches of the DAG to
  // completion (either success or failure), regardless of the failed outcomes of branches in the DAG.
  // More info and example about this feature at https://github.com/argoproj/argo-workflows/issues/1442
  optional bool failFast = 3;
}

// Data is a data template
message Data {
  // Source sources external data into a data template
  optional DataSource source = 1;

  // Transformation applies a set of transformations
  repeated TransformationStep transformation = 2;
}

// DataSource sources external data into a data template
message DataSource {
  // ArtifactPaths is a data transformation that collects a list of artifact paths
  optional ArtifactPaths artifactPaths = 1;
}

message Event {
  // Selector (https://github.com/expr-lang/expr) that we must must match the event. E.g. `payload.message == "test"`
  optional string selector = 1;
}

// ExecutorConfig holds configurations of an executor container.
message ExecutorConfig {
  // ServiceAccountName specifies the service account name of the executor container.
  optional string serviceAccountName = 1;
}

// GCSArtifact is the location of a GCS artifact
message GCSArtifact {
  optional GCSBucket gCSBucket = 1;

  // Key is the path in the bucket where the artifact resides
  optional string key = 2;
}

// GCSArtifactRepository defines the controller configuration for a GCS artifact repository
message GCSArtifactRepository {
  optional GCSBucket gCSBucket = 1;

  // KeyFormat defines the format of how to store keys and can reference workflow variables.
  optional string keyFormat = 2;
}

// GCSBucket contains the access information for interfacring with a GCS bucket
message GCSBucket {
  // Bucket is the name of the bucket
  optional string bucket = 1;

  // ServiceAccountKeySecret is the secret selector to the bucket's service account key
  optional k8s.io.api.core.v1.SecretKeySelector serviceAccountKeySecret = 2;
}

// Gauge is a Gauge prometheus metric
message Gauge {
  // Value is the value to be used in the operation with the metric's current value. If no operation is set,
  // value is the value of the metric
  optional string value = 1;

  // Realtime emits this metric in real time if applicable
  optional bool realtime = 2;

  // Operation defines the operation to apply with value and the metrics' current value
  // +optional
  optional string operation = 3;
}

// GitArtifact is the location of a git artifact
message GitArtifact {
  // Repo is the git repository
  optional string repo = 1;

  // Revision is the git commit, tag, branch to checkout
  optional string revision = 2;

  // Depth specifies clones/fetches should be shallow and include the given
  // number of commits from the branch tip
  optional uint64 depth = 3;

  // Fetch specifies a number of refs that should be fetched before checkout
  repeated string fetch = 4;

  // UsernameSecret is the secret selector to the repository username
  optional k8s.io.api.core.v1.SecretKeySelector usernameSecret = 5;

  // PasswordSecret is the secret selector to the repository password
  optional k8s.io.api.core.v1.SecretKeySelector passwordSecret = 6;

  // SSHPrivateKeySecret is the secret selector to the repository ssh private key
  optional k8s.io.api.core.v1.SecretKeySelector sshPrivateKeySecret = 7;

  // InsecureIgnoreHostKey disables SSH strict host key checking during git clone
  optional bool insecureIgnoreHostKey = 8;

  // DisableSubmodules disables submodules during git clone
  optional bool disableSubmodules = 9;

  // SingleBranch enables single branch clone, using the `branch` parameter
  optional bool singleBranch = 10;

  // Branch is the branch to fetch when `SingleBranch` is enabled
  optional string branch = 11;

  // InsecureSkipTLS disables server certificate verification resulting in insecure HTTPS connections
  optional bool insecureSkipTLS = 12;
}

// HDFSArtifact is the location of an HDFS artifact
message HDFSArtifact {
  optional HDFSConfig hDFSConfig = 1;

  // Path is a file path in HDFS
  optional string path = 2;

  // Force copies a file forcibly even if it exists
  optional bool force = 3;
}

// HDFSArtifactRepository defines the controller configuration for an HDFS artifact repository
message HDFSArtifactRepository {
  optional HDFSConfig hDFSConfig = 1;

  // PathFormat is defines the format of path to store a file. Can reference workflow variables
  optional string pathFormat = 2;

  // Force copies a file forcibly even if it exists
  optional bool force = 3;
}

// HDFSConfig is configurations for HDFS
message HDFSConfig {
  optional HDFSKrbConfig hDFSKrbConfig = 1;

  // Addresses is accessible addresses of HDFS name nodes
  repeated string addresses = 2;

  // HDFSUser is the user to access HDFS file system.
  // It is ignored if either ccache or keytab is used.
  optional string hdfsUser = 3;

  // DataTransferProtection is the protection level for HDFS data transfer.
  // It corresponds to the dfs.data.transfer.protection configuration in HDFS.
  optional string dataTransferProtection = 4;
}

// HDFSKrbConfig is auth configurations for Kerberos
message HDFSKrbConfig {
  // KrbCCacheSecret is the secret selector for Kerberos ccache
  // Either ccache or keytab can be set to use Kerberos.
  optional k8s.io.api.core.v1.SecretKeySelector krbCCacheSecret = 1;

  // KrbKeytabSecret is the secret selector for Kerberos keytab
  // Either ccache or keytab can be set to use Kerberos.
  optional k8s.io.api.core.v1.SecretKeySelector krbKeytabSecret = 2;

  // KrbUsername is the Kerberos username used with Kerberos keytab
  // It must be set if keytab is used.
  optional string krbUsername = 3;

  // KrbRealm is the Kerberos realm used with Kerberos keytab
  // It must be set if keytab is used.
  optional string krbRealm = 4;

  // KrbConfig is the configmap selector for Kerberos config as string
  // It must be set if either ccache or keytab is used.
  optional k8s.io.api.core.v1.ConfigMapKeySelector krbConfigConfigMap = 5;

  // KrbServicePrincipalName is the principal name of Kerberos service
  // It must be set if either ccache or keytab is used.
  optional string krbServicePrincipalName = 6;
}

message HTTP {
  // Method is HTTP methods for HTTP Request
  optional string method = 1;

  // URL of the HTTP Request
  optional string url = 2;

  // Headers are an optional list of headers to send with HTTP requests
  repeated HTTPHeader headers = 3;

  // TimeoutSeconds is request timeout for HTTP Request. Default is 30 seconds
  optional int64 timeoutSeconds = 4;

  // SuccessCondition is an expression if evaluated to true is considered successful
  optional string successCondition = 6;

  // Body is content of the HTTP Request
  optional string body = 5;

  // BodyFrom is  content of the HTTP Request as Bytes
  optional HTTPBodySource bodyFrom = 8;

  // InsecureSkipVerify is a bool when if set to true will skip TLS verification for the HTTP client
  optional bool insecureSkipVerify = 7;
}

// HTTPArtifact allows a file served on HTTP to be placed as an input artifact in a container
message HTTPArtifact {
  // URL of the artifact
  optional string url = 1;

  // Headers are an optional list of headers to send with HTTP requests for artifacts
  repeated Header headers = 2;

  // Auth contains information for client authentication
  optional HTTPAuth auth = 3;
}

message HTTPAuth {
  optional ClientCertAuth clientCert = 1;

  optional OAuth2Auth oauth2 = 2;

  optional BasicAuth basicAuth = 3;
}

// HTTPBodySource contains the source of the HTTP body.
message HTTPBodySource {
  optional bytes bytes = 1;
}

message HTTPHeader {
  optional string name = 1;

  optional string value = 2;

  optional HTTPHeaderSource valueFrom = 3;
}

message HTTPHeaderSource {
  optional k8s.io.api.core.v1.SecretKeySelector secretKeyRef = 1;
}

// Header indicate a key-value request header to be used when fetching artifacts over HTTP
message Header {
  // Name is the header name
  optional string name = 1;

  // Value is the literal value to use for the header
  optional string value = 2;
}

// Histogram is a Histogram prometheus metric
message Histogram {
  // Value is the value of the metric
  optional string value = 3;

  // Buckets is a list of bucket divisors for the histogram
  repeated Amount buckets = 4;
}

// Inputs are the mechanism for passing parameters, artifacts, volumes from one template to another
message Inputs {
  // Parameters are a list of parameters passed as inputs
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated Parameter parameters = 1;

  // Artifact are a list of artifacts passed as inputs
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated Artifact artifacts = 2;

  // ArtifactRepositoryRef specifies the configMap name and key containing the artifact repository config for input artifacts.
  optional ArtifactRepositoryRef artifactRepositoryRef = 3;

  // Location in which all files related to the input will be stored.
  optional ArtifactLocation artifactLocation = 4;
}

// Item expands a single workflow step into multiple parallel steps
// The value of Item can be a map, string, bool, or number
//
// +protobuf.options.(gogoproto.goproto_stringer)=false
message Item {
  optional bytes value = 1;
}

// LabelKeys is list of keys
message LabelKeys {
  repeated string items = 1;
}

message LabelValueFrom {
  optional string expression = 1;
}

// Labels is list of workflow labels
message LabelValues {
  repeated string items = 1;
}

message LifecycleHook {
  // Template is the name of the template to execute by the hook
  optional string template = 1;

  // Arguments hold arguments to the template
  optional Arguments arguments = 2;

  // TemplateRef is the reference to the template resource to execute by the hook
  optional TemplateRef templateRef = 3;

  // Expression is a condition expression for when a node will be retried. If it evaluates to false, the node will not
  // be retried and the retry strategy will be ignored
  optional string expression = 4;
}

// A link to another app.
// +patchStrategy=merge
// +patchMergeKey=name
message Link {
  // The name of the link, E.g. "Workflow Logs" or "Pod Logs"
  optional string name = 1;

  // "workflow", "pod", "pod-logs", "event-source-logs", "sensor-logs", "workflow-list" or "chat"
  optional string scope = 2;

  // The URL. Can contain "${metadata.namespace}", "${metadata.name}", "${status.startedAt}", "${status.finishedAt}" or any other element in workflow yaml, e.g. "${workflow.metadata.annotations.userDefinedKey}"
  optional string url = 3;

  // Target attribute specifies where a linked document will be opened when a user clicks on a link. E.g. "_blank", "_self". If the target is _blank, it will open in a new tab.
  optional string target = 4;
}

message ManifestFrom {
  // Artifact contains the artifact to use
  optional Artifact artifact = 1;
}

// MemoizationStatus is the status of this memoized node
message MemoizationStatus {
  // Hit indicates whether this node was created from a cache entry
  optional bool hit = 1;

  // Key is the name of the key used for this node's cache
  optional string key = 2;

  // Cache is the name of the cache that was used
  optional string cacheName = 3;
}

// Memoization enables caching for the Outputs of the template
message Memoize {
  // Key is the key to use as the caching key
  optional string key = 1;

  // Cache sets and configures the kind of cache
  optional Cache cache = 2;

  // MaxAge is the maximum age (e.g. "180s", "24h") of an entry that is still considered valid. If an entry is older
  // than the MaxAge, it will be ignored.
  optional string maxAge = 3;
}

// Pod metdata
message Metadata {
  map<string, string> annotations = 1;

  map<string, string> labels = 2;
}

// MetricLabel is a single label for a prometheus metric
message MetricLabel {
  optional string key = 1;

  optional string value = 2;
}

// Metrics are a list of metrics emitted from a Workflow/Template
message Metrics {
  // Prometheus is a list of prometheus metrics to be emitted
  repeated Prometheus prometheus = 1;
}

// Mutex holds Mutex configuration
message Mutex {
  // name of the mutex
  optional string name = 1;

  // Namespace is the namespace of the mutex, default: [namespace of workflow]
  optional string namespace = 2;

  // Database specifies this is database controlled if this is set true
  optional bool database = 3;
}

// MutexHolding describes the mutex and the object which is holding it.
message MutexHolding {
  // Reference for the mutex
  // e.g: ${namespace}/mutex/${mutexName}
  optional string mutex = 1;

  // Holder is a reference to the object which holds the Mutex.
  // Holding Scenario:
  //   1. Current workflow's NodeID which is holding the lock.
  //      e.g: ${NodeID}
  // Waiting Scenario:
  //   1. Current workflow or other workflow NodeID which is holding the lock.
  //      e.g: ${WorkflowName}/${NodeID}
  optional string holder = 2;
}

// MutexStatus contains which objects hold  mutex locks, and which objects this workflow is waiting on to release locks.
message MutexStatus {
  // Holding is a list of mutexes and their respective objects that are held by mutex lock for this workflow.
  // +listType=atomic
  repeated MutexHolding holding = 1;

  // Waiting is a list of mutexes and their respective objects this workflow is waiting for.
  // +listType=atomic
  repeated MutexHolding waiting = 2;
}

message NodeFlag {
  // Hooked tracks whether or not this node was triggered by hook or onExit
  optional bool hooked = 1;

  // Retried tracks whether or not this node was retried by retryStrategy
  optional bool retried = 2;
}

message NodeResult {
  optional string phase = 1;

  optional string message = 2;

  optional Outputs outputs = 3;

  optional string progress = 4;
}

// NodeStatus contains status information about an individual node in the workflow
message NodeStatus {
  // ID is a unique identifier of a node within the worklow
  // It is implemented as a hash of the node name, which makes the ID deterministic
  optional string id = 1;

  // Name is unique name in the node tree used to generate the node ID
  optional string name = 2;

  // DisplayName is a human readable representation of the node. Unique within a template boundary
  optional string displayName = 3;

  // Type indicates type of node
  optional string type = 4;

  // TemplateName is the template name which this node corresponds to.
  // Not applicable to virtual nodes (e.g. Retry, StepGroup)
  optional string templateName = 5;

  // TemplateRef is the reference to the template resource which this node corresponds to.
  // Not applicable to virtual nodes (e.g. Retry, StepGroup)
  optional TemplateRef templateRef = 6;

  // TemplateScope is the template scope in which the template of this node was retrieved.
  optional string templateScope = 20;

  // Phase a simple, high-level summary of where the node is in its lifecycle.
  // Can be used as a state machine.
  // Will be one of these values "Pending", "Running" before the node is completed, or "Succeeded",
  // "Skipped", "Failed", "Error", or "Omitted" as a final state.
  optional string phase = 7;

  // BoundaryID indicates the node ID of the associated template root node in which this node belongs to
  optional string boundaryID = 8;

  // A human readable message indicating details about why the node is in this condition.
  optional string message = 9;

  // Time at which this node started
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 10;

  // Time at which this node completed
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 11;

  // EstimatedDuration in seconds.
  optional int64 estimatedDuration = 24;

  // Progress to completion
  optional string progress = 26;

  // ResourcesDuration is indicative, but not accurate, resource duration. This is populated when the nodes completes.
  map<string, int64> resourcesDuration = 21;

  // PodIP captures the IP of the pod for daemoned steps
  optional string podIP = 12;

  // Daemoned tracks whether or not this node was daemoned and need to be terminated
  optional bool daemoned = 13;

  // NodeFlag tracks some history of node. e.g.) hooked, retried, etc.
  optional NodeFlag nodeFlag = 27;

  // Inputs captures input parameter values and artifact locations supplied to this template invocation
  optional Inputs inputs = 14;

  // Outputs captures output parameter values and artifact locations produced by this template invocation
  optional Outputs outputs = 15;

  // Children is a list of child node IDs
  repeated string children = 16;

  // OutboundNodes tracks the node IDs which are considered "outbound" nodes to a template invocation.
  // For every invocation of a template, there are nodes which we considered as "outbound". Essentially,
  // these are last nodes in the execution sequence to run, before the template is considered completed.
  // These nodes are then connected as parents to a following step.
  //
  // In the case of single pod steps (i.e. container, script, resource templates), this list will be nil
  // since the pod itself is already considered the "outbound" node.
  // In the case of DAGs, outbound nodes are the "target" tasks (tasks with no children).
  // In the case of steps, outbound nodes are all the containers involved in the last step group.
  // NOTE: since templates are composable, the list of outbound nodes are carried upwards when
  // a DAG/steps template invokes another DAG/steps template. In other words, the outbound nodes of
  // a template, will be a superset of the outbound nodes of its last children.
  repeated string outboundNodes = 17;

  // HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
  optional string hostNodeName = 22;

  // MemoizationStatus holds information about cached nodes
  optional MemoizationStatus memoizationStatus = 23;

  // SynchronizationStatus is the synchronization status of the node
  optional NodeSynchronizationStatus synchronizationStatus = 25;

  // TaskResultSynced is used to determine if the node's output has been received
  optional bool taskResultSynced = 28;
}

// NodeSynchronizationStatus stores the status of a node
message NodeSynchronizationStatus {
  // Waiting is the name of the lock that this node is waiting for
  optional string waiting = 1;
}

// NoneStrategy indicates to skip tar process and upload the files or directory tree as independent
// files. Note that if the artifact is a directory, the artifact driver must support the ability to
// save/load the directory appropriately.
message NoneStrategy {
}

// OAuth2Auth holds all information for client authentication via OAuth2 tokens
message OAuth2Auth {
  optional k8s.io.api.core.v1.SecretKeySelector clientIDSecret = 1;

  optional k8s.io.api.core.v1.SecretKeySelector clientSecretSecret = 2;

  optional k8s.io.api.core.v1.SecretKeySelector tokenURLSecret = 3;

  repeated string scopes = 5;

  repeated OAuth2EndpointParam endpointParams = 6;
}

// EndpointParam is for requesting optional fields that should be sent in the oauth request
message OAuth2EndpointParam {
  // Name is the header name
  optional string key = 1;

  // Value is the literal value to use for the header
  optional string value = 2;
}

// OSSArtifact is the location of an Alibaba Cloud OSS artifact
message OSSArtifact {
  optional OSSBucket oSSBucket = 1;

  // Key is the path in the bucket where the artifact resides
  optional string key = 2;
}

// OSSArtifactRepository defines the controller configuration for an OSS artifact repository
message OSSArtifactRepository {
  optional OSSBucket oSSBucket = 1;

  // KeyFormat defines the format of how to store keys and can reference workflow variables.
  optional string keyFormat = 2;
}

// OSSBucket contains the access information required for interfacing with an Alibaba Cloud OSS bucket
message OSSBucket {
  // Endpoint is the hostname of the bucket endpoint
  optional string endpoint = 1;

  // Bucket is the name of the bucket
  optional string bucket = 2;

  // AccessKeySecret is the secret selector to the bucket's access key
  optional k8s.io.api.core.v1.SecretKeySelector accessKeySecret = 3;

  // SecretKeySecret is the secret selector to the bucket's secret key
  optional k8s.io.api.core.v1.SecretKeySelector secretKeySecret = 4;

  // CreateBucketIfNotPresent tells the driver to attempt to create the OSS bucket for output artifacts, if it doesn't exist
  optional bool createBucketIfNotPresent = 5;

  // SecurityToken is the user's temporary security token. For more details, check out: https://www.alibabacloud.com/help/doc-detail/100624.htm
  optional string securityToken = 6;

  // LifecycleRule specifies how to manage bucket's lifecycle
  optional OSSLifecycleRule lifecycleRule = 7;

  // UseSDKCreds tells the driver to figure out credentials based on sdk defaults.
  optional bool useSDKCreds = 8;
}

// OSSLifecycleRule specifies how to manage bucket's lifecycle
message OSSLifecycleRule {
  // MarkInfrequentAccessAfterDays is the number of days before we convert the objects in the bucket to Infrequent Access (IA) storage type
  optional int32 markInfrequentAccessAfterDays = 1;

  // MarkDeletionAfterDays is the number of days before we delete objects in the bucket
  optional int32 markDeletionAfterDays = 2;
}

// +kubebuilder:validation:Type=object
message Object {
  optional bytes value = 1;
}

// Outputs hold parameters, artifacts, and results from a step
message Outputs {
  // Parameters holds the list of output parameters produced by a step
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated Parameter parameters = 1;

  // Artifacts holds the list of output artifacts produced by a step
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated Artifact artifacts = 2;

  // Result holds the result (stdout) of a script or container template, or the response body of an HTTP template
  optional string result = 3;

  // ExitCode holds the exit code of a script template
  optional string exitCode = 4;

  // ArtifactRepositoryRef specifies the configMap name and key containing the artifact repository config for output artifacts.
  optional ArtifactRepositoryRef artifactRepositoryRef = 5;

  // Location in which all files related to the output will be stored.
  optional ArtifactLocation artifactLocation = 6;
}

// swagger:ignore
message ParallelSteps {
  // Note: the `json:"steps"` part exists to workaround kubebuilder limitations.
  // There isn't actually a "steps" key in the JSON serialization; this is an anonymous list.
  // See the custom Unmarshaller below and ./hack/manifests/crd.go
  repeated WorkflowStep steps = 1;
}

// Parameter indicate a passed string parameter to a service template with an optional default value
message Parameter {
  // Name is the parameter name
  optional string name = 1;

  // Default is the default value to use for an input parameter if a value was not supplied
  optional string default = 2;

  // Value is the literal value to use for the parameter.
  // If specified in the context of an input parameter, any passed values take precedence over the specified value
  optional string value = 3;

  // ValueFrom is the source for the output parameter's value
  optional ValueFrom valueFrom = 4;

  // GlobalName exports an output parameter to the global scope, making it available as
  // '{{workflow.outputs.parameters.XXXX}} and in workflow.status.outputs.parameters
  optional string globalName = 5;

  // Enum holds a list of string values to choose from, for the actual value of the parameter
  repeated string enum = 6;

  // Description is the parameter description
  optional string description = 7;
}

// Plugin is an Object with exactly one key
message Plugin {
  optional Object object = 1;
}

// PodGC describes how to delete completed pods as they complete
message PodGC {
  // Strategy is the strategy to use. One of "OnPodCompletion", "OnPodSuccess", "OnWorkflowCompletion", "OnWorkflowSuccess". If unset, does not delete Pods
  optional string strategy = 1;

  // LabelSelector is the label selector to check if the pods match the labels before being added to the pod GC queue.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 2;

  // DeleteDelayDuration specifies the duration before pods in the GC queue get deleted.
  optional string deleteDelayDuration = 3;
}

// Prometheus is a prometheus metric to be emitted
message Prometheus {
  // Name is the name of the metric
  optional string name = 1;

  // Labels is a list of metric labels
  repeated MetricLabel labels = 2;

  // Help is a string that describes the metric
  optional string help = 3;

  // When is a conditional statement that decides when to emit the metric
  optional string when = 4;

  // Gauge is a gauge metric
  optional Gauge gauge = 5;

  // Histogram is a histogram metric
  optional Histogram histogram = 6;

  // Counter is a counter metric
  optional Counter counter = 7;
}

// RawArtifact allows raw string content to be placed as an artifact in a container
message RawArtifact {
  // Data is the string contents of the artifact
  optional string data = 1;
}

// ResourceTemplate is a template subtype to manipulate kubernetes resources
message ResourceTemplate {
  // Action is the action to perform to the resource.
  // Must be one of: get, create, apply, delete, replace, patch
  optional string action = 1;

  // MergeStrategy is the strategy used to merge a patch. It defaults to "strategic"
  // Must be one of: strategic, merge, json
  optional string mergeStrategy = 2;

  // Manifest contains the kubernetes manifest
  optional string manifest = 3;

  // ManifestFrom is the source for a single kubernetes manifest
  optional ManifestFrom manifestFrom = 8;

  // SetOwnerReference sets the reference to the workflow on the OwnerReference of generated resource.
  optional bool setOwnerReference = 4;

  // SuccessCondition is a label selector expression which describes the conditions
  // of the k8s resource in which it is acceptable to proceed to the following step
  optional string successCondition = 5;

  // FailureCondition is a label selector expression which describes the conditions
  // of the k8s resource in which the step was considered failed
  optional string failureCondition = 6;

  // Flags is a set of additional options passed to kubectl before submitting a resource
  // I.e. to disable resource validation:
  // flags: [
  // 	"--validate=false"  # disable resource validation
  // ]
  repeated string flags = 7;
}

// RetryAffinity prevents running steps on the same host.
message RetryAffinity {
  optional RetryNodeAntiAffinity nodeAntiAffinity = 1;
}

// RetryNodeAntiAffinity is a placeholder for future expansion, only empty nodeAntiAffinity is allowed.
// In order to prevent running steps on the same host, it uses "kubernetes.io/hostname".
message RetryNodeAntiAffinity {
}

// RetryStrategy provides controls on how to retry a workflow step
message RetryStrategy {
  // Limit is the maximum number of retry attempts when retrying a container. It does not include the original
  // container; the maximum number of total attempts will be `limit + 1`.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString limit = 1;

  // RetryPolicy is a policy of NodePhase statuses that will be retried
  optional string retryPolicy = 2;

  // Backoff is a backoff strategy
  optional Backoff backoff = 3;

  // Affinity prevents running workflow's step on the same host
  optional RetryAffinity affinity = 4;

  // Expression is a condition expression for when a node will be retried. If it evaluates to false, the node will not
  // be retried and the retry strategy will be ignored
  optional string expression = 5;
}

// S3Artifact is the location of an S3 artifact
message S3Artifact {
  optional S3Bucket s3Bucket = 1;

  // Key is the key in the bucket where the artifact resides
  optional string key = 2;
}

// S3ArtifactRepository defines the controller configuration for an S3 artifact repository
message S3ArtifactRepository {
  optional S3Bucket s3Bucket = 1;

  // KeyFormat defines the format of how to store keys and can reference workflow variables.
  optional string keyFormat = 2;

  // KeyPrefix is prefix used as part of the bucket key in which the controller will store artifacts.
  // DEPRECATED. Use KeyFormat instead
  optional string keyPrefix = 3;
}

// S3Bucket contains the access information required for interfacing with an S3 bucket
message S3Bucket {
  // Endpoint is the hostname of the bucket endpoint
  optional string endpoint = 1;

  // Bucket is the name of the bucket
  optional string bucket = 2;

  // Region contains the optional bucket region
  optional string region = 3;

  // Insecure will connect to the service with TLS
  optional bool insecure = 4;

  // AccessKeySecret is the secret selector to the bucket's access key
  optional k8s.io.api.core.v1.SecretKeySelector accessKeySecret = 5;

  // SecretKeySecret is the secret selector to the bucket's secret key
  optional k8s.io.api.core.v1.SecretKeySelector secretKeySecret = 6;

  // SessionTokenSecret is used for ephemeral credentials like an IAM assume role or S3 access grant
  optional k8s.io.api.core.v1.SecretKeySelector sessionTokenSecret = 12;

  // RoleARN is the Amazon Resource Name (ARN) of the role to assume.
  optional string roleARN = 7;

  // UseSDKCreds tells the driver to figure out credentials based on sdk defaults.
  optional bool useSDKCreds = 8;

  // CreateBucketIfNotPresent tells the driver to attempt to create the S3 bucket for output artifacts, if it doesn't exist. Setting Enabled Encryption will apply either SSE-S3 to the bucket if KmsKeyId is not set or SSE-KMS if it is.
  optional CreateS3BucketOptions createBucketIfNotPresent = 9;

  optional S3EncryptionOptions encryptionOptions = 10;

  // CASecret specifies the secret that contains the CA, used to verify the TLS connection
  optional k8s.io.api.core.v1.SecretKeySelector caSecret = 11;
}

// S3EncryptionOptions used to determine encryption options during s3 operations
message S3EncryptionOptions {
  // KMSKeyId tells the driver to encrypt the object using the specified KMS Key.
  optional string kmsKeyId = 1;

  // KmsEncryptionContext is a json blob that contains an encryption context. See https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context for more information
  optional string kmsEncryptionContext = 2;

  // EnableEncryption tells the driver to encrypt objects if set to true. If kmsKeyId and serverSideCustomerKeySecret are not set, SSE-S3 will be used
  optional bool enableEncryption = 3;

  // ServerSideCustomerKeySecret tells the driver to encrypt the output artifacts using SSE-C with the specified secret.
  optional k8s.io.api.core.v1.SecretKeySelector serverSideCustomerKeySecret = 4;
}

// ScriptTemplate is a template subtype to enable scripting through code steps
message ScriptTemplate {
  optional k8s.io.api.core.v1.Container container = 1;

  // Source contains the source code of the script to execute
  // +optional
  optional string source = 2;
}

message SemaphoreHolding {
  // Semaphore stores the semaphore name.
  optional string semaphore = 1;

  // Holders stores the list of current holder names in the workflow.
  // +listType=atomic
  repeated string holders = 2;
}

// SemaphoreRef is a reference of Semaphore
message SemaphoreRef {
  // ConfigMapKeyRef is a configmap selector for Semaphore configuration
  optional k8s.io.api.core.v1.ConfigMapKeySelector configMapKeyRef = 1;

  // Namespace is the namespace of the configmap, default: [namespace of workflow]
  optional string namespace = 2;

  // SyncDatabaseRef is a database reference for Semaphore configuration
  optional SyncDatabaseRef database = 3;
}

message SemaphoreStatus {
  // Holding stores the list of resource acquired synchronization lock for workflows.
  repeated SemaphoreHolding holding = 1;

  // Waiting indicates the list of current synchronization lock holders.
  repeated SemaphoreHolding waiting = 2;
}

// Sequence expands a workflow step into numeric range
message Sequence {
  // Count is number of elements in the sequence (default: 0). Not to be used with end
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString count = 1;

  // Number at which to start the sequence (default: 0)
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString start = 2;

  // Number at which to end the sequence (default: 0). Not to be used with Count
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString end = 3;

  // Format is a printf format string to format the value in the sequence
  optional string format = 4;
}

// StopStrategy defines if the CronWorkflow should stop scheduling based on an expression. v3.6 and after
message StopStrategy {
  // v3.6 and after: Expression is an expression that stops scheduling workflows when true. Use the variables
  // `cronworkflow`.`failed` or `cronworkflow`.`succeeded` to access the number of failed or successful child workflows.
  optional string expression = 1;
}

message Submit {
  // WorkflowTemplateRef the workflow template to submit
  optional WorkflowTemplateRef workflowTemplateRef = 1;

  // Metadata optional means to customize select fields of the workflow metadata
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 3;

  // Arguments extracted from the event and then set as arguments to the workflow created.
  optional Arguments arguments = 2;
}

// SubmitOpts are workflow submission options
message SubmitOpts {
  // Name overrides metadata.name
  optional string name = 1;

  // GenerateName overrides metadata.generateName
  optional string generateName = 2;

  // Entrypoint overrides spec.entrypoint
  optional string entrypoint = 4;

  // Parameters passes input parameters to workflow
  repeated string parameters = 5;

  // ServiceAccount runs all pods in the workflow using specified ServiceAccount.
  optional string serviceAccount = 7;

  // DryRun validates the workflow on the client-side without creating it. This option is not supported in API
  optional bool dryRun = 8;

  // ServerDryRun validates the workflow on the server-side without creating it
  optional bool serverDryRun = 9;

  // Labels adds to metadata.labels
  optional string labels = 10;

  // OwnerReference creates a metadata.ownerReference
  optional k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReference = 11;

  // Annotations adds to metadata.labels
  optional string annotations = 12;

  // Set the podPriorityClassName of the workflow
  optional string podPriorityClassName = 13;

  // Priority is used if controller is configured to process limited number of workflows in parallel, higher priority workflows
  // are processed first.
  optional int32 priority = 14;
}

// SuppliedValueFrom is a placeholder for a value to be filled in directly, either through the CLI, API, etc.
message SuppliedValueFrom {
}

// SuspendTemplate is a template subtype to suspend a workflow at a predetermined point in time
message SuspendTemplate {
  // Duration is the seconds to wait before automatically resuming a template. Must be a string. Default unit is seconds.
  // Could also be a Duration, e.g.: "2m", "6h"
  optional string duration = 1;
}

message SyncDatabaseRef {
  optional string key = 1;
}

// Synchronization holds synchronization lock configuration
message Synchronization {
  // Semaphore holds the Semaphore configuration - deprecated, use semaphores instead
  optional SemaphoreRef semaphore = 1;

  // Mutex holds the Mutex lock details - deprecated, use mutexes instead
  optional Mutex mutex = 2;

  // v3.6 and after: Semaphores holds the list of Semaphores configuration
  repeated SemaphoreRef semaphores = 3;

  // v3.6 and after: Mutexes holds the list of Mutex lock details
  repeated Mutex mutexes = 4;
}

// SynchronizationStatus stores the status of semaphore and mutex.
message SynchronizationStatus {
  // Semaphore stores this workflow's Semaphore holder details
  optional SemaphoreStatus semaphore = 1;

  // Mutex stores this workflow's mutex holder details
  optional MutexStatus mutex = 2;
}

// TTLStrategy is the strategy for the time to live depending on if the workflow succeeded or failed
message TTLStrategy {
  // SecondsAfterCompletion is the number of seconds to live after completion
  optional int32 secondsAfterCompletion = 1;

  // SecondsAfterSuccess is the number of seconds to live after success
  optional int32 secondsAfterSuccess = 2;

  // SecondsAfterFailure is the number of seconds to live after failure
  optional int32 secondsAfterFailure = 3;
}

// TarStrategy will tar and gzip the file or directory when saving
message TarStrategy {
  // CompressionLevel specifies the gzip compression level to use for the artifact.
  // Defaults to gzip.DefaultCompression.
  optional int32 compressionLevel = 1;
}

// Template is a reusable and composable unit of execution in a workflow
message Template {
  // Name is the name of the template
  optional string name = 1;

  // Inputs describe what inputs parameters and artifacts are supplied to this template
  optional Inputs inputs = 5;

  // Outputs describe the parameters and artifacts that this template produces
  optional Outputs outputs = 6;

  // NodeSelector is a selector to schedule this step of the workflow to be
  // run on the selected node(s). Overrides the selector set at the workflow level.
  map<string, string> nodeSelector = 7;

  // Affinity sets the pod's scheduling constraints
  // Overrides the affinity set at the workflow level (if any)
  optional k8s.io.api.core.v1.Affinity affinity = 8;

  // Metdata sets the pods's metadata, i.e. annotations and labels
  optional Metadata metadata = 9;

  // Daemon will allow a workflow to proceed to the next step so long as the container reaches readiness
  optional bool daemon = 10;

  // Steps define a series of sequential/parallel workflow steps
  repeated ParallelSteps steps = 11;

  // Container is the main container image to run in the pod
  optional k8s.io.api.core.v1.Container container = 12;

  // ContainerSet groups multiple containers within a single pod.
  optional ContainerSetTemplate containerSet = 40;

  // Script runs a portion of code against an interpreter
  optional ScriptTemplate script = 13;

  // Resource template subtype which can run k8s resources
  optional ResourceTemplate resource = 14;

  // DAG template subtype which runs a DAG
  optional DAGTemplate dag = 15;

  // Suspend template subtype which can suspend a workflow when reaching the step
  optional SuspendTemplate suspend = 16;

  // Data is a data template
  optional Data data = 39;

  // HTTP makes a HTTP request
  optional HTTP http = 42;

  // Plugin is a plugin template
  // Note: the structure of a plugin template is free-form, so we need to have
  // "x-kubernetes-preserve-unknown-fields: true" in the validation schema.
  // +kubebuilder:pruning:PreserveUnknownFields
  optional Plugin plugin = 43;

  // Volumes is a list of volumes that can be mounted by containers in a template.
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated k8s.io.api.core.v1.Volume volumes = 17;

  // InitContainers is a list of containers which run before the main container.
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated UserContainer initContainers = 18;

  // Sidecars is a list of containers which run alongside the main container
  // Sidecars are automatically killed when the main container completes
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated UserContainer sidecars = 19;

  // Location in which all files related to the step will be stored (logs, artifacts, etc...).
  // Can be overridden by individual items in Outputs. If omitted, will use the default
  // artifact repository location configured in the controller, appended with the
  // <workflowname>/<nodename> in the key.
  optional ArtifactLocation archiveLocation = 20;

  // Optional duration in seconds relative to the StartTime that the pod may be active on a node
  // before the system actively tries to terminate the pod; value must be positive integer
  // This field is only applicable to container and script templates.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString activeDeadlineSeconds = 21;

  // RetryStrategy describes how to retry a template when it fails
  optional RetryStrategy retryStrategy = 22;

  // Parallelism limits the max total parallel pods that can execute at the same time within the
  // boundaries of this template invocation. If additional steps/dag templates are invoked, the
  // pods created by those templates will not be counted towards this total.
  optional int64 parallelism = 23;

  // FailFast, if specified, will fail this template if any of its child pods has failed. This is useful for when this
  // template is expanded with `withItems`, etc.
  optional bool failFast = 41;

  // Tolerations to apply to workflow pods.
  // +patchStrategy=merge
  // +patchMergeKey=key
  repeated k8s.io.api.core.v1.Toleration tolerations = 24;

  // If specified, the pod will be dispatched by specified scheduler.
  // Or it will be dispatched by workflow scope scheduler if specified.
  // If neither specified, the pod will be dispatched by default scheduler.
  // +optional
  optional string schedulerName = 25;

  // PriorityClassName to apply to workflow pods.
  optional string priorityClassName = 26;

  // ServiceAccountName to apply to workflow pods
  optional string serviceAccountName = 28;

  // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods.
  // ServiceAccountName of ExecutorConfig must be specified if this value is false.
  optional bool automountServiceAccountToken = 32;

  // Executor holds configurations of the executor container.
  optional ExecutorConfig executor = 33;

  // HostAliases is an optional list of hosts and IPs that will be injected into the pod spec
  // +patchStrategy=merge
  // +patchMergeKey=ip
  repeated k8s.io.api.core.v1.HostAlias hostAliases = 29;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  // +optional
  optional k8s.io.api.core.v1.PodSecurityContext securityContext = 30;

  // PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of
  // container fields which are not strings (e.g. resource limits).
  optional string podSpecPatch = 31;

  // Metrics are a list of metrics emitted from this template
  optional Metrics metrics = 35;

  // Synchronization holds synchronization lock configuration for this template
  optional Synchronization synchronization = 36;

  // Memoize allows templates to use outputs generated from already executed templates
  optional Memoize memoize = 37;

  // Timeout allows to set the total node execution timeout duration counting from the node's start time.
  // This duration also includes time in which the node spends in Pending state. This duration may not be applied to Step or DAG templates.
  optional string timeout = 38;

  // Annotations is a list of annotations to add to the template at runtime
  map<string, string> annotations = 44;
}

// TemplateRef is a reference of template resource.
message TemplateRef {
  // Name is the resource name of the template.
  optional string name = 1;

  // Template is the name of referred template in the resource.
  optional string template = 2;

  // ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate).
  optional bool clusterScope = 4;
}

message TransformationStep {
  // Expression defines an expr expression to apply
  optional string expression = 1;
}

// UserContainer is a container specified by a user.
message UserContainer {
  optional k8s.io.api.core.v1.Container container = 1;

  // MirrorVolumeMounts will mount the same volumes specified in the main container
  // to the container (including artifacts), at the same mountPaths. This enables
  // dind daemon to partially see the same filesystem as the main container in
  // order to use features such as docker volume binding
  optional bool mirrorVolumeMounts = 2;
}

// ValueFrom describes a location in which to obtain the value to a parameter
message ValueFrom {
  // Path in the container to retrieve an output parameter value from in container templates
  optional string path = 1;

  // JSONPath of a resource to retrieve an output parameter value from in resource templates
  optional string jsonPath = 2;

  // JQFilter expression against the resource object in resource templates
  optional string jqFilter = 3;

  // Selector (https://github.com/expr-lang/expr) that is evaluated against the event to get the value of the parameter. E.g. `payload.message`
  optional string event = 7;

  // Parameter reference to a step or dag task in which to retrieve an output parameter value from
  // (e.g. '{{steps.mystep.outputs.myparam}}')
  optional string parameter = 4;

  // Supplied value to be filled in directly, either through the CLI, API, etc.
  optional SuppliedValueFrom supplied = 6;

  // ConfigMapKeyRef is configmap selector for input parameter configuration
  optional k8s.io.api.core.v1.ConfigMapKeySelector configMapKeyRef = 9;

  // Default specifies a value to be used if retrieving the value from the specified source fails
  optional string default = 5;

  // Expression, if defined, is evaluated to specify the value for the parameter
  optional string expression = 8;
}

message Version {
  optional string version = 1;

  optional string buildDate = 2;

  optional string gitCommit = 3;

  optional string gitTag = 4;

  optional string gitTreeState = 5;

  optional string goVersion = 6;

  optional string compiler = 7;

  optional string platform = 8;
}

// VolumeClaimGC describes how to delete volumes from completed Workflows
message VolumeClaimGC {
  // Strategy is the strategy to use. One of "OnWorkflowCompletion", "OnWorkflowSuccess". Defaults to "OnWorkflowSuccess"
  optional string strategy = 1;
}

// Workflow is the definition of a workflow resource
// +genclient
// +genclient:noStatus
// +kubebuilder:resource:shortName=wf
// +kubebuilder:printcolumn:name="Status",type="string",JSONPath=".status.phase",description="Status of the workflow"
// +kubebuilder:printcolumn:name="Age",type="date",format="date-time",JSONPath=".status.startedAt",description="When the workflow was started"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.message",description="Human readable message indicating details about why the workflow is in this condition."
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message Workflow {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional WorkflowSpec spec  = 2;

  optional WorkflowStatus status = 3;
}

// WorkflowArtifactGCTask specifies the Artifacts that need to be deleted as well as the status of deletion
// +genclient
// +kubebuilder:resource:shortName=wfat
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:subresource:status
message WorkflowArtifactGCTask {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ArtifactGCSpec spec = 2;

  optional ArtifactGCStatus status = 3;
}

// WorkflowArtifactGCTaskList is list of WorkflowArtifactGCTask resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message WorkflowArtifactGCTaskList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated WorkflowArtifactGCTask items = 2;
}

// WorkflowEventBinding is the definition of an event resource
// +genclient
// +genclient:noStatus
// +kubebuilder:resource:shortName=wfeb
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message WorkflowEventBinding {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional WorkflowEventBindingSpec spec = 2;
}

// WorkflowEventBindingList is list of event resources
// +kubebuilder:resource:shortName=wfebs
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message WorkflowEventBindingList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated WorkflowEventBinding items = 2;
}

message WorkflowEventBindingSpec {
  // Event is the event to bind to
  optional Event event = 1;

  // Submit is the workflow template to submit
  optional Submit submit = 2;
}

// WorkflowLevelArtifactGC describes how to delete artifacts from completed Workflows - this spec is used on the Workflow level
message WorkflowLevelArtifactGC {
  // ArtifactGC is an embedded struct
  optional ArtifactGC artifactGC = 1;

  // ForceFinalizerRemoval: if set to true, the finalizer will be removed in the case that Artifact GC fails
  optional bool forceFinalizerRemoval = 2;

  // PodSpecPatch holds strategic merge patch to apply against the artgc pod spec.
  optional string podSpecPatch = 3;
}

// WorkflowList is list of Workflow resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message WorkflowList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Workflow items = 2;
}

message WorkflowMetadata {
  map<string, string> labels = 1;

  map<string, string> annotations = 2;

  map<string, LabelValueFrom> labelsFrom = 3;
}

// WorkflowSpec is the specification of a Workflow.
message WorkflowSpec {
  // Templates is a list of workflow templates used in a workflow
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated Template templates = 1;

  // Entrypoint is a template reference to the starting point of the workflow.
  optional string entrypoint = 2;

  // Arguments contain the parameters and artifacts sent to the workflow entrypoint
  // Parameters are referencable globally using the 'workflow' variable prefix.
  // e.g. {{workflow.parameters.myparam}}
  optional Arguments arguments = 3;

  // ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.
  optional string serviceAccountName = 4;

  // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods.
  // ServiceAccountName of ExecutorConfig must be specified if this value is false.
  optional bool automountServiceAccountToken = 28;

  // Executor holds configurations of executor containers of the workflow.
  optional ExecutorConfig executor = 29;

  // Volumes is a list of volumes that can be mounted by containers in a workflow.
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated k8s.io.api.core.v1.Volume volumes = 5;

  // VolumeClaimTemplates is a list of claims that containers are allowed to reference.
  // The Workflow controller will create the claims at the beginning of the workflow
  // and delete the claims upon completion of the workflow
  repeated k8s.io.api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 6;

  // Parallelism limits the max total parallel pods that can execute at the same time in a workflow
  optional int64 parallelism = 7;

  // ArtifactRepositoryRef specifies the configMap name and key containing the artifact repository config.
  optional ArtifactRepositoryRef artifactRepositoryRef = 8;

  // Suspend will suspend the workflow and prevent execution of any future steps in the workflow
  optional bool suspend = 9;

  // NodeSelector is a selector which will result in all pods of the workflow
  // to be scheduled on the selected node(s). This is able to be overridden by
  // a nodeSelector specified in the template.
  map<string, string> nodeSelector = 10;

  // Affinity sets the scheduling constraints for all pods in the workflow.
  // Can be overridden by an affinity specified in the template
  optional k8s.io.api.core.v1.Affinity affinity = 11;

  // Tolerations to apply to workflow pods.
  // +patchStrategy=merge
  // +patchMergeKey=key
  repeated k8s.io.api.core.v1.Toleration tolerations = 12;

  // ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
  // in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets
  // can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
  // More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 13;

  // Host networking requested for this workflow pod. Default to false.
  optional bool hostNetwork = 14;

  // Set DNS policy for workflow pods.
  // Defaults to "ClusterFirst".
  // Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
  // DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
  // To have DNS options set along with hostNetwork, you have to specify DNS policy
  // explicitly to 'ClusterFirstWithHostNet'.
  optional string dnsPolicy = 15;

  // PodDNSConfig defines the DNS parameters of a pod in addition to
  // those generated from DNSPolicy.
  optional k8s.io.api.core.v1.PodDNSConfig dnsConfig = 16;

  // OnExit is a template reference which is invoked at the end of the
  // workflow, irrespective of the success, failure, or error of the
  // primary workflow.
  optional string onExit = 17;

  // TTLStrategy limits the lifetime of a Workflow that has finished execution depending on if it
  // Succeeded or Failed. If this struct is set, once the Workflow finishes, it will be
  // deleted after the time to live expires. If this field is unset,
  // the controller config map will hold the default values.
  optional TTLStrategy ttlStrategy = 30;

  // Optional duration in seconds relative to the workflow start time which the workflow is
  // allowed to run before the controller terminates the workflow. A value of zero is used to
  // terminate a Running workflow
  optional int64 activeDeadlineSeconds = 19;

  // Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first.
  optional int32 priority = 20;

  // Set scheduler name for all pods.
  // Will be overridden if container/script template's scheduler name is set.
  // Default scheduler will be used if neither specified.
  // +optional
  optional string schedulerName = 21;

  // PodGC describes the strategy to use when deleting completed pods
  optional PodGC podGC = 22;

  // PriorityClassName to apply to workflow pods.
  optional string podPriorityClassName = 23;

  // +patchStrategy=merge
  // +patchMergeKey=ip
  repeated k8s.io.api.core.v1.HostAlias hostAliases = 25;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  // +optional
  optional k8s.io.api.core.v1.PodSecurityContext securityContext = 26;

  // PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of
  // container fields which are not strings (e.g. resource limits).
  optional string podSpecPatch = 27;

  // PodDisruptionBudget holds the number of concurrent disruptions that you allow for Workflow's Pods.
  // Controller will automatically add the selector with workflow name, if selector is empty.
  // Optional: Defaults to empty.
  // +optional
  optional k8s.io.api.policy.v1.PodDisruptionBudgetSpec podDisruptionBudget = 31;

  // Metrics are a list of metrics emitted from this Workflow
  optional Metrics metrics = 32;

  // Shutdown will shutdown the workflow according to its ShutdownStrategy
  optional string shutdown = 33;

  // WorkflowTemplateRef holds a reference to a WorkflowTemplate for execution
  optional WorkflowTemplateRef workflowTemplateRef = 34;

  // Synchronization holds synchronization lock configuration for this Workflow
  optional Synchronization synchronization = 35;

  // VolumeClaimGC describes the strategy to use when deleting volumes from completed workflows
  optional VolumeClaimGC volumeClaimGC = 36;

  // RetryStrategy for all templates in the workflow.
  optional RetryStrategy retryStrategy = 37;

  // PodMetadata defines additional metadata that should be applied to workflow pods
  optional Metadata podMetadata = 38;

  // TemplateDefaults holds default template values that will apply to all templates in the Workflow, unless overridden on the template-level
  optional Template templateDefaults = 39;

  // ArchiveLogs indicates if the container logs should be archived
  optional bool archiveLogs = 40;

  // Hooks holds the lifecycle hook which is invoked at lifecycle of
  // step, irrespective of the success, failure, or error status of the primary step
  map<string, LifecycleHook> hooks = 41;

  // WorkflowMetadata contains some metadata of the workflow to refer to
  optional WorkflowMetadata workflowMetadata = 42;

  // ArtifactGC describes the strategy to use when deleting artifacts from completed or deleted workflows (applies to all output Artifacts
  // unless Artifact.ArtifactGC is specified, which overrides this)
  optional WorkflowLevelArtifactGC artifactGC = 43;
}

// WorkflowStatus contains overall status information about a workflow
message WorkflowStatus {
  // Phase a simple, high-level summary of where the workflow is in its lifecycle.
  // Will be "" (Unknown), "Pending", or "Running" before the workflow is completed, and "Succeeded",
  // "Failed" or "Error" once the workflow has completed.
  optional string phase = 1;

  // Time at which this workflow started
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 2;

  // Time at which this workflow completed
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 3;

  // EstimatedDuration in seconds.
  optional int64 estimatedDuration = 16;

  // Progress to completion
  optional string progress = 17;

  // A human readable message indicating details about why the workflow is in this condition.
  optional string message = 4;

  // Compressed and base64 decoded Nodes map
  optional string compressedNodes = 5;

  // Nodes is a mapping between a node ID and the node's status.
  map<string, NodeStatus> nodes = 6;

  // Whether on not node status has been offloaded to a database. If exists, then Nodes and CompressedNodes will be empty.
  // This will actually be populated with a hash of the offloaded data.
  optional string offloadNodeStatusVersion = 10;

  // StoredTemplates is a mapping between a template ref and the node's status.
  map<string, Template> storedTemplates = 9;

  // PersistentVolumeClaims tracks all PVCs that were created as part of the workflow.
  // The contents of this list are drained at the end of the workflow.
  repeated k8s.io.api.core.v1.Volume persistentVolumeClaims = 7;

  // Outputs captures output values and artifact locations produced by the workflow via global outputs
  optional Outputs outputs = 8;

  // Conditions is a list of conditions the Workflow may have
  repeated Condition conditions = 13;

  // ResourcesDuration is the total for the workflow
  map<string, int64> resourcesDuration = 12;

  // StoredWorkflowSpec stores the WorkflowTemplate spec for future execution.
  optional WorkflowSpec storedWorkflowTemplateSpec = 14;

  // Synchronization stores the status of synchronization locks
  optional SynchronizationStatus synchronization = 15;

  // ArtifactRepositoryRef is used to cache the repository to use so we do not need to determine it everytime we reconcile.
  optional ArtifactRepositoryRefStatus artifactRepositoryRef = 18;

  // ArtifactGCStatus maintains the status of Artifact Garbage Collection
  optional ArtGCStatus artifactGCStatus = 19;

  // TaskResultsCompletionStatus tracks task result completion status (mapped by node ID). Used to prevent premature archiving and garbage collection.
  map<string, bool> taskResultsCompletionStatus = 20;
}

// WorkflowStep is a reference to a template to execute in a series of step
message WorkflowStep {
  // Name of the step
  optional string name = 1;

  // Template is the name of the template to execute as the step
  optional string template = 2;

  // Inline is the template. Template must be empty if this is declared (and vice-versa).
  // Note: This struct is defined recursively, since the inline template can potentially contain
  // steps/DAGs that also has an "inline" field. Kubernetes doesn't allow recursive types, so we
  // need "x-kubernetes-preserve-unknown-fields: true" in the validation schema.
  // +kubebuilder:pruning:PreserveUnknownFields
  optional Template inline = 13;

  // Arguments hold arguments to the template
  optional Arguments arguments = 3;

  // TemplateRef is the reference to the template resource to execute as the step.
  optional TemplateRef templateRef = 4;

  // WithItems expands a step into multiple parallel steps from the items in the list
  // Note: The structure of WithItems is free-form, so we need
  // "x-kubernetes-preserve-unknown-fields: true" in the validation schema.
  // +kubebuilder:validation:Schemaless
  // +kubebuilder:pruning:PreserveUnknownFields
  repeated Item withItems = 5;

  // WithParam expands a step into multiple parallel steps from the value in the parameter,
  // which is expected to be a JSON list.
  optional string withParam = 6;

  // WithSequence expands a step into a numeric sequence
  optional Sequence withSequence = 7;

  // When is an expression in which the step should conditionally execute
  optional string when = 8;

  // ContinueOn makes argo to proceed with the following step even if this step fails.
  // Errors and Failed states can be specified
  optional ContinueOn continueOn = 9;

  // OnExit is a template reference which is invoked at the end of the
  // template, irrespective of the success, failure, or error of the
  // primary template.
  // DEPRECATED: Use Hooks[exit].Template instead.
  optional string onExit = 11;

  // Hooks holds the lifecycle hook which is invoked at lifecycle of
  // step, irrespective of the success, failure, or error status of the primary step
  map<string, LifecycleHook> hooks = 12;
}

// WorkflowTaskResult is a used to communicate a result back to the controller. Unlike WorkflowTaskSet, it has
// more capacity. This is an internal type. Users should never create this resource directly, much like you would
// never create a ReplicaSet directly.
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message WorkflowTaskResult {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional NodeResult nodeResult = 2;
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message WorkflowTaskResultList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated WorkflowTaskResult items = 2;
}

// +genclient
// +kubebuilder:resource:shortName=wfts
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:subresource:status
message WorkflowTaskSet {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional WorkflowTaskSetSpec spec = 2;

  optional WorkflowTaskSetStatus status = 3;
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message WorkflowTaskSetList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated WorkflowTaskSet items = 2;
}

message WorkflowTaskSetSpec {
  map<string, Template> tasks = 1;
}

message WorkflowTaskSetStatus {
  map<string, NodeResult> nodes = 1;
}

// WorkflowTemplate is the definition of a workflow template resource
// +genclient
// +genclient:noStatus
// +kubebuilder:resource:shortName=wftmpl
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message WorkflowTemplate {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional WorkflowSpec spec = 2;
}

// WorkflowTemplateList is list of WorkflowTemplate resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message WorkflowTemplateList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated WorkflowTemplate items = 2;
}

// WorkflowTemplateRef is a reference to a WorkflowTemplate resource.
message WorkflowTemplateRef {
  // Name is the resource name of the workflow template.
  optional string name = 1;

  // ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate).
  optional bool clusterScope = 2;
}

// ZipStrategy will unzip zipped input artifacts
message ZipStrategy {
}

