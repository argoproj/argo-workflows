// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/argoproj/argo-workflows/v4/pkg/apiclient/workflow"
	"github.com/argoproj/argo-workflows/v4/pkg/apis/workflow/v1alpha1"
	mock "github.com/stretchr/testify/mock"
	"google.golang.org/grpc"
)

// NewWorkflowServiceClient creates a new instance of WorkflowServiceClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWorkflowServiceClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *WorkflowServiceClient {
	mock := &WorkflowServiceClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// WorkflowServiceClient is an autogenerated mock type for the WorkflowServiceClient type
type WorkflowServiceClient struct {
	mock.Mock
}

type WorkflowServiceClient_Expecter struct {
	mock *mock.Mock
}

func (_m *WorkflowServiceClient) EXPECT() *WorkflowServiceClient_Expecter {
	return &WorkflowServiceClient_Expecter{mock: &_m.Mock}
}

// CreateWorkflow provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) CreateWorkflow(ctx context.Context, in *workflow.WorkflowCreateRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflow")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowCreateRequest, ...grpc.CallOption) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowCreateRequest, ...grpc.CallOption) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowCreateRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_CreateWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflow'
type WorkflowServiceClient_CreateWorkflow_Call struct {
	*mock.Call
}

// CreateWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowCreateRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) CreateWorkflow(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_CreateWorkflow_Call {
	return &WorkflowServiceClient_CreateWorkflow_Call{Call: _e.mock.On("CreateWorkflow",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_CreateWorkflow_Call) Run(run func(ctx context.Context, in *workflow.WorkflowCreateRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_CreateWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowCreateRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowCreateRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_CreateWorkflow_Call) Return(workflow1 *v1alpha1.Workflow, err error) *WorkflowServiceClient_CreateWorkflow_Call {
	_c.Call.Return(workflow1, err)
	return _c
}

func (_c *WorkflowServiceClient_CreateWorkflow_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowCreateRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error)) *WorkflowServiceClient_CreateWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWorkflow provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) DeleteWorkflow(ctx context.Context, in *workflow.WorkflowDeleteRequest, opts ...grpc.CallOption) (*workflow.WorkflowDeleteResponse, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflow")
	}

	var r0 *workflow.WorkflowDeleteResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowDeleteRequest, ...grpc.CallOption) (*workflow.WorkflowDeleteResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowDeleteRequest, ...grpc.CallOption) *workflow.WorkflowDeleteResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow.WorkflowDeleteResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowDeleteRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_DeleteWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWorkflow'
type WorkflowServiceClient_DeleteWorkflow_Call struct {
	*mock.Call
}

// DeleteWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowDeleteRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) DeleteWorkflow(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_DeleteWorkflow_Call {
	return &WorkflowServiceClient_DeleteWorkflow_Call{Call: _e.mock.On("DeleteWorkflow",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_DeleteWorkflow_Call) Run(run func(ctx context.Context, in *workflow.WorkflowDeleteRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_DeleteWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowDeleteRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowDeleteRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_DeleteWorkflow_Call) Return(workflowDeleteResponse *workflow.WorkflowDeleteResponse, err error) *WorkflowServiceClient_DeleteWorkflow_Call {
	_c.Call.Return(workflowDeleteResponse, err)
	return _c
}

func (_c *WorkflowServiceClient_DeleteWorkflow_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowDeleteRequest, opts ...grpc.CallOption) (*workflow.WorkflowDeleteResponse, error)) *WorkflowServiceClient_DeleteWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflow provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) GetWorkflow(ctx context.Context, in *workflow.WorkflowGetRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflow")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowGetRequest, ...grpc.CallOption) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowGetRequest, ...grpc.CallOption) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowGetRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_GetWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflow'
type WorkflowServiceClient_GetWorkflow_Call struct {
	*mock.Call
}

// GetWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowGetRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) GetWorkflow(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_GetWorkflow_Call {
	return &WorkflowServiceClient_GetWorkflow_Call{Call: _e.mock.On("GetWorkflow",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_GetWorkflow_Call) Run(run func(ctx context.Context, in *workflow.WorkflowGetRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_GetWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowGetRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowGetRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_GetWorkflow_Call) Return(workflow1 *v1alpha1.Workflow, err error) *WorkflowServiceClient_GetWorkflow_Call {
	_c.Call.Return(workflow1, err)
	return _c
}

func (_c *WorkflowServiceClient_GetWorkflow_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowGetRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error)) *WorkflowServiceClient_GetWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// LintWorkflow provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) LintWorkflow(ctx context.Context, in *workflow.WorkflowLintRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LintWorkflow")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowLintRequest, ...grpc.CallOption) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowLintRequest, ...grpc.CallOption) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowLintRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_LintWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LintWorkflow'
type WorkflowServiceClient_LintWorkflow_Call struct {
	*mock.Call
}

// LintWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowLintRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) LintWorkflow(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_LintWorkflow_Call {
	return &WorkflowServiceClient_LintWorkflow_Call{Call: _e.mock.On("LintWorkflow",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_LintWorkflow_Call) Run(run func(ctx context.Context, in *workflow.WorkflowLintRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_LintWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowLintRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowLintRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_LintWorkflow_Call) Return(workflow1 *v1alpha1.Workflow, err error) *WorkflowServiceClient_LintWorkflow_Call {
	_c.Call.Return(workflow1, err)
	return _c
}

func (_c *WorkflowServiceClient_LintWorkflow_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowLintRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error)) *WorkflowServiceClient_LintWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// ListWorkflows provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) ListWorkflows(ctx context.Context, in *workflow.WorkflowListRequest, opts ...grpc.CallOption) (*v1alpha1.WorkflowList, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListWorkflows")
	}

	var r0 *v1alpha1.WorkflowList
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowListRequest, ...grpc.CallOption) (*v1alpha1.WorkflowList, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowListRequest, ...grpc.CallOption) *v1alpha1.WorkflowList); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.WorkflowList)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowListRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_ListWorkflows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWorkflows'
type WorkflowServiceClient_ListWorkflows_Call struct {
	*mock.Call
}

// ListWorkflows is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowListRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) ListWorkflows(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_ListWorkflows_Call {
	return &WorkflowServiceClient_ListWorkflows_Call{Call: _e.mock.On("ListWorkflows",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_ListWorkflows_Call) Run(run func(ctx context.Context, in *workflow.WorkflowListRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_ListWorkflows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowListRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowListRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_ListWorkflows_Call) Return(workflowList *v1alpha1.WorkflowList, err error) *WorkflowServiceClient_ListWorkflows_Call {
	_c.Call.Return(workflowList, err)
	return _c
}

func (_c *WorkflowServiceClient_ListWorkflows_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowListRequest, opts ...grpc.CallOption) (*v1alpha1.WorkflowList, error)) *WorkflowServiceClient_ListWorkflows_Call {
	_c.Call.Return(run)
	return _c
}

// PodLogs provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) PodLogs(ctx context.Context, in *workflow.WorkflowLogRequest, opts ...grpc.CallOption) (workflow.WorkflowService_PodLogsClient, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PodLogs")
	}

	var r0 workflow.WorkflowService_PodLogsClient
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowLogRequest, ...grpc.CallOption) (workflow.WorkflowService_PodLogsClient, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowLogRequest, ...grpc.CallOption) workflow.WorkflowService_PodLogsClient); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(workflow.WorkflowService_PodLogsClient)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowLogRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_PodLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PodLogs'
type WorkflowServiceClient_PodLogs_Call struct {
	*mock.Call
}

// PodLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowLogRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) PodLogs(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_PodLogs_Call {
	return &WorkflowServiceClient_PodLogs_Call{Call: _e.mock.On("PodLogs",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_PodLogs_Call) Run(run func(ctx context.Context, in *workflow.WorkflowLogRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_PodLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowLogRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowLogRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_PodLogs_Call) Return(workflowService_PodLogsClient workflow.WorkflowService_PodLogsClient, err error) *WorkflowServiceClient_PodLogs_Call {
	_c.Call.Return(workflowService_PodLogsClient, err)
	return _c
}

func (_c *WorkflowServiceClient_PodLogs_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowLogRequest, opts ...grpc.CallOption) (workflow.WorkflowService_PodLogsClient, error)) *WorkflowServiceClient_PodLogs_Call {
	_c.Call.Return(run)
	return _c
}

// ResubmitWorkflow provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) ResubmitWorkflow(ctx context.Context, in *workflow.WorkflowResubmitRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResubmitWorkflow")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowResubmitRequest, ...grpc.CallOption) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowResubmitRequest, ...grpc.CallOption) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowResubmitRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_ResubmitWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResubmitWorkflow'
type WorkflowServiceClient_ResubmitWorkflow_Call struct {
	*mock.Call
}

// ResubmitWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowResubmitRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) ResubmitWorkflow(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_ResubmitWorkflow_Call {
	return &WorkflowServiceClient_ResubmitWorkflow_Call{Call: _e.mock.On("ResubmitWorkflow",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_ResubmitWorkflow_Call) Run(run func(ctx context.Context, in *workflow.WorkflowResubmitRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_ResubmitWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowResubmitRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowResubmitRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_ResubmitWorkflow_Call) Return(workflow1 *v1alpha1.Workflow, err error) *WorkflowServiceClient_ResubmitWorkflow_Call {
	_c.Call.Return(workflow1, err)
	return _c
}

func (_c *WorkflowServiceClient_ResubmitWorkflow_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowResubmitRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error)) *WorkflowServiceClient_ResubmitWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// ResumeWorkflow provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) ResumeWorkflow(ctx context.Context, in *workflow.WorkflowResumeRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResumeWorkflow")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowResumeRequest, ...grpc.CallOption) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowResumeRequest, ...grpc.CallOption) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowResumeRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_ResumeWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResumeWorkflow'
type WorkflowServiceClient_ResumeWorkflow_Call struct {
	*mock.Call
}

// ResumeWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowResumeRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) ResumeWorkflow(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_ResumeWorkflow_Call {
	return &WorkflowServiceClient_ResumeWorkflow_Call{Call: _e.mock.On("ResumeWorkflow",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_ResumeWorkflow_Call) Run(run func(ctx context.Context, in *workflow.WorkflowResumeRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_ResumeWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowResumeRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowResumeRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_ResumeWorkflow_Call) Return(workflow1 *v1alpha1.Workflow, err error) *WorkflowServiceClient_ResumeWorkflow_Call {
	_c.Call.Return(workflow1, err)
	return _c
}

func (_c *WorkflowServiceClient_ResumeWorkflow_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowResumeRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error)) *WorkflowServiceClient_ResumeWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// RetryWorkflow provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) RetryWorkflow(ctx context.Context, in *workflow.WorkflowRetryRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RetryWorkflow")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowRetryRequest, ...grpc.CallOption) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowRetryRequest, ...grpc.CallOption) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowRetryRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_RetryWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetryWorkflow'
type WorkflowServiceClient_RetryWorkflow_Call struct {
	*mock.Call
}

// RetryWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowRetryRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) RetryWorkflow(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_RetryWorkflow_Call {
	return &WorkflowServiceClient_RetryWorkflow_Call{Call: _e.mock.On("RetryWorkflow",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_RetryWorkflow_Call) Run(run func(ctx context.Context, in *workflow.WorkflowRetryRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_RetryWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowRetryRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowRetryRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_RetryWorkflow_Call) Return(workflow1 *v1alpha1.Workflow, err error) *WorkflowServiceClient_RetryWorkflow_Call {
	_c.Call.Return(workflow1, err)
	return _c
}

func (_c *WorkflowServiceClient_RetryWorkflow_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowRetryRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error)) *WorkflowServiceClient_RetryWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// SetWorkflow provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) SetWorkflow(ctx context.Context, in *workflow.WorkflowSetRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetWorkflow")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowSetRequest, ...grpc.CallOption) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowSetRequest, ...grpc.CallOption) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowSetRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_SetWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetWorkflow'
type WorkflowServiceClient_SetWorkflow_Call struct {
	*mock.Call
}

// SetWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowSetRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) SetWorkflow(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_SetWorkflow_Call {
	return &WorkflowServiceClient_SetWorkflow_Call{Call: _e.mock.On("SetWorkflow",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_SetWorkflow_Call) Run(run func(ctx context.Context, in *workflow.WorkflowSetRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_SetWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowSetRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowSetRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_SetWorkflow_Call) Return(workflow1 *v1alpha1.Workflow, err error) *WorkflowServiceClient_SetWorkflow_Call {
	_c.Call.Return(workflow1, err)
	return _c
}

func (_c *WorkflowServiceClient_SetWorkflow_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowSetRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error)) *WorkflowServiceClient_SetWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// StopWorkflow provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) StopWorkflow(ctx context.Context, in *workflow.WorkflowStopRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopWorkflow")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowStopRequest, ...grpc.CallOption) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowStopRequest, ...grpc.CallOption) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowStopRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_StopWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopWorkflow'
type WorkflowServiceClient_StopWorkflow_Call struct {
	*mock.Call
}

// StopWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowStopRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) StopWorkflow(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_StopWorkflow_Call {
	return &WorkflowServiceClient_StopWorkflow_Call{Call: _e.mock.On("StopWorkflow",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_StopWorkflow_Call) Run(run func(ctx context.Context, in *workflow.WorkflowStopRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_StopWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowStopRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowStopRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_StopWorkflow_Call) Return(workflow1 *v1alpha1.Workflow, err error) *WorkflowServiceClient_StopWorkflow_Call {
	_c.Call.Return(workflow1, err)
	return _c
}

func (_c *WorkflowServiceClient_StopWorkflow_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowStopRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error)) *WorkflowServiceClient_StopWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// SubmitWorkflow provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) SubmitWorkflow(ctx context.Context, in *workflow.WorkflowSubmitRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubmitWorkflow")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowSubmitRequest, ...grpc.CallOption) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowSubmitRequest, ...grpc.CallOption) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowSubmitRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_SubmitWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubmitWorkflow'
type WorkflowServiceClient_SubmitWorkflow_Call struct {
	*mock.Call
}

// SubmitWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowSubmitRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) SubmitWorkflow(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_SubmitWorkflow_Call {
	return &WorkflowServiceClient_SubmitWorkflow_Call{Call: _e.mock.On("SubmitWorkflow",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_SubmitWorkflow_Call) Run(run func(ctx context.Context, in *workflow.WorkflowSubmitRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_SubmitWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowSubmitRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowSubmitRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_SubmitWorkflow_Call) Return(workflow1 *v1alpha1.Workflow, err error) *WorkflowServiceClient_SubmitWorkflow_Call {
	_c.Call.Return(workflow1, err)
	return _c
}

func (_c *WorkflowServiceClient_SubmitWorkflow_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowSubmitRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error)) *WorkflowServiceClient_SubmitWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// SuspendWorkflow provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) SuspendWorkflow(ctx context.Context, in *workflow.WorkflowSuspendRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SuspendWorkflow")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowSuspendRequest, ...grpc.CallOption) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowSuspendRequest, ...grpc.CallOption) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowSuspendRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_SuspendWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SuspendWorkflow'
type WorkflowServiceClient_SuspendWorkflow_Call struct {
	*mock.Call
}

// SuspendWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowSuspendRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) SuspendWorkflow(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_SuspendWorkflow_Call {
	return &WorkflowServiceClient_SuspendWorkflow_Call{Call: _e.mock.On("SuspendWorkflow",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_SuspendWorkflow_Call) Run(run func(ctx context.Context, in *workflow.WorkflowSuspendRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_SuspendWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowSuspendRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowSuspendRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_SuspendWorkflow_Call) Return(workflow1 *v1alpha1.Workflow, err error) *WorkflowServiceClient_SuspendWorkflow_Call {
	_c.Call.Return(workflow1, err)
	return _c
}

func (_c *WorkflowServiceClient_SuspendWorkflow_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowSuspendRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error)) *WorkflowServiceClient_SuspendWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// TerminateWorkflow provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) TerminateWorkflow(ctx context.Context, in *workflow.WorkflowTerminateRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TerminateWorkflow")
	}

	var r0 *v1alpha1.Workflow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowTerminateRequest, ...grpc.CallOption) (*v1alpha1.Workflow, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowTerminateRequest, ...grpc.CallOption) *v1alpha1.Workflow); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowTerminateRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_TerminateWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TerminateWorkflow'
type WorkflowServiceClient_TerminateWorkflow_Call struct {
	*mock.Call
}

// TerminateWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowTerminateRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) TerminateWorkflow(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_TerminateWorkflow_Call {
	return &WorkflowServiceClient_TerminateWorkflow_Call{Call: _e.mock.On("TerminateWorkflow",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_TerminateWorkflow_Call) Run(run func(ctx context.Context, in *workflow.WorkflowTerminateRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_TerminateWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowTerminateRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowTerminateRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_TerminateWorkflow_Call) Return(workflow1 *v1alpha1.Workflow, err error) *WorkflowServiceClient_TerminateWorkflow_Call {
	_c.Call.Return(workflow1, err)
	return _c
}

func (_c *WorkflowServiceClient_TerminateWorkflow_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowTerminateRequest, opts ...grpc.CallOption) (*v1alpha1.Workflow, error)) *WorkflowServiceClient_TerminateWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// WatchEvents provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) WatchEvents(ctx context.Context, in *workflow.WatchEventsRequest, opts ...grpc.CallOption) (workflow.WorkflowService_WatchEventsClient, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WatchEvents")
	}

	var r0 workflow.WorkflowService_WatchEventsClient
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WatchEventsRequest, ...grpc.CallOption) (workflow.WorkflowService_WatchEventsClient, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WatchEventsRequest, ...grpc.CallOption) workflow.WorkflowService_WatchEventsClient); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(workflow.WorkflowService_WatchEventsClient)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WatchEventsRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_WatchEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchEvents'
type WorkflowServiceClient_WatchEvents_Call struct {
	*mock.Call
}

// WatchEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WatchEventsRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) WatchEvents(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_WatchEvents_Call {
	return &WorkflowServiceClient_WatchEvents_Call{Call: _e.mock.On("WatchEvents",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_WatchEvents_Call) Run(run func(ctx context.Context, in *workflow.WatchEventsRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_WatchEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WatchEventsRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WatchEventsRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_WatchEvents_Call) Return(workflowService_WatchEventsClient workflow.WorkflowService_WatchEventsClient, err error) *WorkflowServiceClient_WatchEvents_Call {
	_c.Call.Return(workflowService_WatchEventsClient, err)
	return _c
}

func (_c *WorkflowServiceClient_WatchEvents_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WatchEventsRequest, opts ...grpc.CallOption) (workflow.WorkflowService_WatchEventsClient, error)) *WorkflowServiceClient_WatchEvents_Call {
	_c.Call.Return(run)
	return _c
}

// WatchWorkflows provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) WatchWorkflows(ctx context.Context, in *workflow.WatchWorkflowsRequest, opts ...grpc.CallOption) (workflow.WorkflowService_WatchWorkflowsClient, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WatchWorkflows")
	}

	var r0 workflow.WorkflowService_WatchWorkflowsClient
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WatchWorkflowsRequest, ...grpc.CallOption) (workflow.WorkflowService_WatchWorkflowsClient, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WatchWorkflowsRequest, ...grpc.CallOption) workflow.WorkflowService_WatchWorkflowsClient); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(workflow.WorkflowService_WatchWorkflowsClient)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WatchWorkflowsRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_WatchWorkflows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchWorkflows'
type WorkflowServiceClient_WatchWorkflows_Call struct {
	*mock.Call
}

// WatchWorkflows is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WatchWorkflowsRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) WatchWorkflows(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_WatchWorkflows_Call {
	return &WorkflowServiceClient_WatchWorkflows_Call{Call: _e.mock.On("WatchWorkflows",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_WatchWorkflows_Call) Run(run func(ctx context.Context, in *workflow.WatchWorkflowsRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_WatchWorkflows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WatchWorkflowsRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WatchWorkflowsRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_WatchWorkflows_Call) Return(workflowService_WatchWorkflowsClient workflow.WorkflowService_WatchWorkflowsClient, err error) *WorkflowServiceClient_WatchWorkflows_Call {
	_c.Call.Return(workflowService_WatchWorkflowsClient, err)
	return _c
}

func (_c *WorkflowServiceClient_WatchWorkflows_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WatchWorkflowsRequest, opts ...grpc.CallOption) (workflow.WorkflowService_WatchWorkflowsClient, error)) *WorkflowServiceClient_WatchWorkflows_Call {
	_c.Call.Return(run)
	return _c
}

// WorkflowLogs provides a mock function for the type WorkflowServiceClient
func (_mock *WorkflowServiceClient) WorkflowLogs(ctx context.Context, in *workflow.WorkflowLogRequest, opts ...grpc.CallOption) (workflow.WorkflowService_WorkflowLogsClient, error) {
	// grpc.CallOption
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WorkflowLogs")
	}

	var r0 workflow.WorkflowService_WorkflowLogsClient
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowLogRequest, ...grpc.CallOption) (workflow.WorkflowService_WorkflowLogsClient, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *workflow.WorkflowLogRequest, ...grpc.CallOption) workflow.WorkflowService_WorkflowLogsClient); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(workflow.WorkflowService_WorkflowLogsClient)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *workflow.WorkflowLogRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowServiceClient_WorkflowLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WorkflowLogs'
type WorkflowServiceClient_WorkflowLogs_Call struct {
	*mock.Call
}

// WorkflowLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - in *workflow.WorkflowLogRequest
//   - opts ...grpc.CallOption
func (_e *WorkflowServiceClient_Expecter) WorkflowLogs(ctx interface{}, in interface{}, opts ...interface{}) *WorkflowServiceClient_WorkflowLogs_Call {
	return &WorkflowServiceClient_WorkflowLogs_Call{Call: _e.mock.On("WorkflowLogs",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *WorkflowServiceClient_WorkflowLogs_Call) Run(run func(ctx context.Context, in *workflow.WorkflowLogRequest, opts ...grpc.CallOption)) *WorkflowServiceClient_WorkflowLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *workflow.WorkflowLogRequest
		if args[1] != nil {
			arg1 = args[1].(*workflow.WorkflowLogRequest)
		}
		var arg2 []grpc.CallOption
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowServiceClient_WorkflowLogs_Call) Return(workflowService_WorkflowLogsClient workflow.WorkflowService_WorkflowLogsClient, err error) *WorkflowServiceClient_WorkflowLogs_Call {
	_c.Call.Return(workflowService_WorkflowLogsClient, err)
	return _c
}

func (_c *WorkflowServiceClient_WorkflowLogs_Call) RunAndReturn(run func(ctx context.Context, in *workflow.WorkflowLogRequest, opts ...grpc.CallOption) (workflow.WorkflowService_WorkflowLogsClient, error)) *WorkflowServiceClient_WorkflowLogs_Call {
	_c.Call.Return(run)
	return _c
}
