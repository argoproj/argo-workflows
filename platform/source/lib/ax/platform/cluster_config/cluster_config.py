#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright 2015-2017 Applatix, Inc. All rights reserved.
#

import json
import logging

from ax.cloud import Cloud
from ax.meta import AXClusterId, AXClusterConfigPath
from ax.platform.exceptions import AXPlatformException
from ax.util.singleton import Singleton
from future.utils import with_metaclass
from . import AXClusterType, ClusterProvider

logger = logging.getLogger(__name__)


# TODO: Clean up cluster_config.
# A few problems:
# - Really need to define a hierarchy of config env and organize them better. Probably create AXClusterConfig generic
#   and then child classes with different variations.
# - Can we automate generate all get_* functions.
# - Why are we reloading S3 object for every get? That is very bad performance.


class AXClusterConfig(with_metaclass(Singleton, object)):

    def __init__(self, cluster_name_id=None, aws_profile=None, config=None):
        self._cluster_name_id = AXClusterId(name=cluster_name_id, aws_profile=aws_profile).get_cluster_name_id()
        self._bucket_name = AXClusterConfigPath(self._cluster_name_id).bucket()
        self._bucket = Cloud().get_bucket(self._bucket_name, aws_profile=aws_profile)
        self._cluster_config_key = AXClusterConfigPath(self._cluster_name_id).cluster_config()
        self._conf = config

    def _load_config(self):
        if not self._conf:
            data = self._bucket.get_object(self._cluster_config_key)
            assert data is not None, "No cluster config data get at {}/{}".format(self._bucket_name,
                                                                                  self._cluster_config_key)
            self._conf = json.loads(data.decode("utf-8"))

    def set_config(self, config):
        """
        Set a config generated by upper layer
        :param config:
        :return:
        """
        assert config, "Cannot set cluster config to None"
        self._conf = config

    def save_config(self):
        """
        Upload config to s3
        :return:
        """
        logger.info("Uploading cluster config to s3 at %s ...", self._cluster_config_key)
        if not self._conf:
            logger.warning("AXClusterConfig is not initialized with a valid config, NOT uploading.")
            return
        if not self._bucket.put_object(key=self._cluster_config_key, data=json.dumps(self._conf)):
            raise AXPlatformException("Failed to upload cluster config for {}".format(self._cluster_name_id))
        logger.info("Uploading cluster config to s3 ... DONE")

    def get_raw_config(self):
        """
        This method is mainly used for debugging purpsoe
        :return:
        """
        self._load_config()
        return self._conf

    def get_region(self):
        self._load_config()
        return str(self._conf["cloud"]["configure"]["region"])

    def get_zone(self):
        self._load_config()
        return str(self._conf["cloud"]["configure"]["placement"])

    def get_master_type(self):
        self._load_config()
        return str(self._conf["cloud"]["configure"]["master_type"])

    def get_axsys_node_type(self):
        self._load_config()
        return str(self._conf["cloud"]["configure"]["axsys_node_type"])

    def get_axuser_node_type(self):
        self._load_config()
        return str(self._conf["cloud"]["configure"]["axuser_node_type"])

    def get_max_node_count(self):
        self._load_config()
        return str(self._conf["cloud"]["configure"]["max_node_count"])

    def get_min_node_count(self):
        self._load_config()
        return str(self._conf["cloud"]["configure"]["min_node_count"])

    def get_asxys_node_count(self):
        self._load_config()
        try:
            return str(self._conf["cloud"]["configure"]["axsys_node_count"])
        except KeyError as ke:
            return "0"

    def get_axuser_on_demand_count(self):
        self._load_config()
        try:
            return str(self._conf["cloud"]["configure"]["axuser_on_demand_nodes"])
        except KeyError as ke:
            return "0"

    def get_autoscaler_scan_interval(self):
        self._load_config()
        try:
            return self._conf["cloud"]["configure"]["autoscaler_scan_interval"]
        except KeyError as ke:
            return "10s"

    def get_support_object_store_name(self):
        self._load_config()
        return str(self._conf.get("cloud", {}).get("configure", {}).get("support_object_store_name", ""))

    def get_provider(self):
        self._load_config()
        return str(self._conf["cloud"]["provider"])

    def get_trusted_cidr(self):
        self._load_config()
        return self._conf["cloud"]["trusted_cidr"]

    def get_vpc_cidr_base(self):
        self._load_config()
        return str(self._conf["cloud"]["vpc_cidr_base"])

    def get_node_tiers(self):
        self._load_config()
        return self._conf["cloud"]["configure"].get("node_tiers", None)

    def get_node_config(self):
        """ Get entire config of the node """
        self._load_config()
        return self._conf["cloud"]["configure"]

    def get_ax_vol_size(self):
        self._load_config()
        return self._conf["cloud"]["configure"].get("ax_vol_size", None)

    def get_ax_cluster_user(self):
        self._load_config()
        return self._conf["cloud"]["configure"].get("cluster_user", None)

    def get_ax_cluster_size(self):
        self._load_config()
        return self._conf["cloud"]["configure"].get("cluster_size", None)

    def get_ax_cluster_type(self):
        self._load_config()
        return self._conf["cloud"]["configure"].get("cluster_type", AXClusterType.STANDARD)

    def get_user_node_resouce_rsvp(self, key):
        self._load_config()
        if not self._conf["cloud"]["configure"].get("user_node_resource_rsvp", None):
            return -1
        return self._conf["cloud"]["configure"]["user_node_resource_rsvp"].get(key, -1)

    def get_sandbox_flag(self):
        self._load_config()
        return self._conf["cloud"]["configure"].get("sandbox_enabled", None)

    def get_master_pod_cidr(self):
        self._load_config()
        return self._conf["cloud"]["kube_installer_config"].get("MASTER_IP_RANGE", None)

    def get_ami_id(self):
        self._load_config()
        return self._conf["cloud"]["configure"].get("ami_id", None)

    def get_spot_instances_enabled(self):
        return self._conf["cloud"]["configure"].get("spot_instances_enabled", None)

    def get_spot_instances_option(self):
        return self._conf["cloud"]["configure"].get("spot_instances_option", "partial")

    def get_node_spot_price(self):
        return self._conf["cloud"].get("node_spot_price", None)

    def get_subnet_size(self):
        return self._conf["cloud"].get("subnet_size", None)

    def get_vpc_id(self):
        return self._conf["cloud"].get("vpc_id", None)

    def get_master_config_env(self):
        return self._conf["cloud"]["configure"]["master_config_env"]

    def get_kube_installer_config(self):
        return self._conf["cloud"]["kube_installer_config"]

    def get_cluster_provider(self):
        if self._conf and self._conf["cloud"]:
            return self._conf["cloud"].get("cluster_provider", None)
        return ClusterProvider.USER

    def get_bucket_endpoint(self):
        return self._conf["cloud"]["configure"].get("bucket_endpoint", None)

    # Setters. Currently only a very limited items is mutable
    def set_provider(self, provider):
        self._conf["cloud"]["provider"] = provider

    def set_ax_cluster_user(self, user):
        self._conf["cloud"]["configure"]["cluster_user"] = user

    def set_ax_vol_size(self, vol_size):
        self._conf["cloud"]["configure"]["ax_vol_size"] = vol_size

    def set_ax_cluster_size(self, cluster_size):
        self._conf["cloud"]["configure"]["ax_cluster_size"] = cluster_size

    def set_user_node_resource_rsvp(self, cpu, mem):
        if not self._conf["cloud"]["configure"].get("user_node_resource_rsvp", None):
            self._conf["cloud"]["configure"]["user_node_resource_rsvp"] = {}
        if cpu >= 0:
            self._conf["cloud"]["configure"]["user_node_resource_rsvp"]["cpu"] = cpu
        if mem >= 0:
            self._conf["cloud"]["configure"]["user_node_resource_rsvp"]["memory"] = mem

    def set_node_tiers(self, tiers):
        self._conf["cloud"]["configure"]["node_tiers"] = tiers

    def set_ami_id(self, ami_id):
        self._conf["cloud"]["configure"]["ami_id"] = ami_id

    def set_trusted_cidr(self, cidrs):
        assert isinstance(cidrs, list), "Trusted cidrs need to be a list"
        self._conf["cloud"]["trusted_cidr"] = cidrs

    def set_kube_installer_config(self, config):
        self._conf["cloud"]["kube_installer_config"] = config

    def set_support_object_store_name(self, bucket_name):
        self._conf["cloud"]["configure"]["support_object_store_name"] = bucket_name

    def set_cluster_provider(self, cluster_provider):
        self._conf["cloud"]["cluster_provider"] = cluster_provider

    def set_bucket_endpoint(self, bucket_endpoint):
        self._conf["cloud"]["configure"]["bucket_endpoint"] = bucket_endpoint

    def reload_config(self):
        """
        Python is ambiguous about updating members of singleton objects.
        Some flags in the cloud configuration may be updated. If callers
        want to latest configuration option, it has to be reloaded from
        S3.
        """
        self._conf = None
        return self.get_node_config()

    def load_cluster_meta(self, meta):
        """
        Cluster meta is generated after cluster is created, which should be part of cluster config
        Cluster meta format:

        cluster_name: ${AX_CLUSTER_NAME_ID}
        vpc: ${VPC_ID}
        internet_gateway: ${IGW_ID}
        route_table: ${ROUTE_TABLE_ID}
        security_group: ${NODE_SG_ID}
        subnets:
            ${ZONE}:
                subnet_id: ${SUBNET_ID}
                subnet_cidr: ${SUBNET_CIDR}

        :param meta:
        :return:
        """
        # Currently only add vpc_id / vpc_cidr_base and subnet_size for consistency among ax/non-ax clusters
        # and new VPC / existing VPC clusters
        self._conf["cloud"]["vpc_id"] = meta["vpc"]
        self._conf["cloud"]["vpc_cidr_base"] = meta["vpc_cidr_base"]
        for zone in meta["subnets"].keys():
            self._conf["cloud"]["subnet_size"] = meta["subnets"][zone]["subnet_cidr"].split("/")[1]
            # Getting the first one is fine as we only have 1 subnet
            break


class AXClusterConfigMock(AXClusterConfig):

    def __init__(self, config):
        assert config, "AXClusterConfigMock needs an actual cluster config to start with"
        self._cluster_name_id = "test-cluster-name-id-12345"
        self._conf = config

    def _load_config(self):
        pass

    def set_config(self, config):
        """
        Set a config generated by upper layer
        :param config:
        :return:
        """
        assert config, "Cannot set cluster config to None"
        self._conf = config

    def save_config(self):
        pass
