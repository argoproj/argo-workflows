//go:build tracing

package e2e

import (
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
	apiv1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	wfv1 "github.com/argoproj/argo-workflows/v3/pkg/apis/workflow/v1alpha1"
	"github.com/argoproj/argo-workflows/v3/test/e2e/fixtures"
	"github.com/argoproj/argo-workflows/v3/util/telemetry"
	"github.com/argoproj/argo-workflows/v3/workflow/common"
)

// TracingSuite tests OpenTelemetry tracing functionality
type TracingSuite struct {
	fixtures.E2ESuite
	collector *fixtures.OTELCollector
}

// findLastWorkflowSpan finds the last workflow span in the list (most recent)
func findLastWorkflowSpan(spans []fixtures.CollectedSpan) *fixtures.CollectedSpan {
	for i := len(spans) - 1; i >= 0; i-- {
		if spans[i].Name == "workflow" {
			return &spans[i]
		}
	}
	return nil
}

// assertWorkflowAttribs verifies a span has correct WorkflowName and WorkflowNamespace attributes
func assertWorkflowAttribs(t *testing.T, span *fixtures.CollectedSpan, expectedName, expectedNamespace, spanType string) {
	t.Helper()
	wfName, hasName := span.GetAttribute(telemetry.AttribWorkflowName)
	wfNs, hasNs := span.GetAttribute(telemetry.AttribWorkflowNamespace)
	assert.True(t, hasName, "%s should have WorkflowName attribute", spanType)
	assert.True(t, hasNs, "%s should have WorkflowNamespace attribute", spanType)
	assert.Equal(t, expectedName, wfName, "%s WorkflowName should match", spanType)
	assert.Equal(t, expectedNamespace, wfNs, "%s WorkflowNamespace should match", spanType)
}

// isValidID returns true if the hex ID string is non-empty and not all zeros
func isValidID(id string) bool {
	return id != "" && strings.Trim(id, "0") != ""
}

func (s *TracingSuite) SetupSuite() {
	s.E2ESuite.SetupSuite()

	ctx := s.T().Context()
	var err error
	s.collector, err = fixtures.NewOTELCollector(ctx)
	if err != nil {
		s.T().Fatalf("Failed to start OTEL collector: %v", err)
	}

	s.T().Logf("OTEL Collector started at gRPC=%s, HTTP=%s",
		s.collector.GRPCEndpoint(), s.collector.HTTPEndpoint())
}

func (s *TracingSuite) TearDownSuite() {
	if s.collector != nil {
		ctx := s.T().Context()
		if err := s.collector.Terminate(ctx); err != nil {
			s.T().Logf("Failed to terminate OTEL collector: %v", err)
		}
	}
	s.E2ESuite.TearDownSuite()
}

func (s *TracingSuite) BeforeTest(suiteName, testName string) {
	s.E2ESuite.BeforeTest(suiteName, testName)
	// Snapshot existing spans so only new spans from this test are returned
	if s.collector != nil {
		s.collector.MarkCleared(s.T().Context())
	}
}

// TestBasicWorkflowWithTracing submits a basic workflow and verifies that
// the expected tracing spans are generated by the controller.
func (s *TracingSuite) TestBasicWorkflowWithTracing() {
	s.Given().
		Workflow(`@testdata/basic-workflow.yaml`).
		When().
		SubmitWorkflow().
		WaitForWorkflow(fixtures.ToBeSucceeded).
		Then().
		ExpectWorkflow(func(t *testing.T, metadata *metav1.ObjectMeta, status *wfv1.WorkflowStatus) {
			assert.Equal(t, wfv1.WorkflowSucceeded, status.Phase)

			ctx := s.T().Context()
			workflowSpan, _, err := s.collector.WaitForWorkflowSpan(ctx, 10*time.Second)
			require.NoError(t, err, "Should receive workflow span from controller")
			require.NotNil(t, workflowSpan, "workflow span must exist")

			traceSpans, _ := s.collector.GetSpansByTraceID(ctx, workflowSpan.TraceID)
			tree := fixtures.BuildSpanTree(traceSpans)
			t.Logf("Collected %d spans for workflow %s. Span names: %v", len(traceSpans), metadata.Name, tree.GetSpanNames())

			// Verify workflow is root span
			assert.False(t, workflowSpan.HasParent(), "workflow should be root span")

			// Verify span hierarchy against expected definitions
			hierarchyErrors := tree.VerifyWorkflowHierarchy()
			if hierarchyErrors != nil {
				t.Logf("Hierarchy violations:\n%s", hierarchyErrors.Error())
				t.Logf("Span tree:\n%s", tree.PrintTree())
			}
			require.NoError(t, hierarchyErrors, "all spans should conform to expected hierarchy")

			// Verify expected spans exist
			assert.True(t, tree.HasSpan("reconcileWorkflow"), "reconcileWorkflow span must exist")
			assert.True(t, tree.HasSpan("reconcileTaskResults"), "reconcileTaskResults span must exist")
			assert.True(t, tree.HasSpan("node"), "node span must exist")
			assert.True(t, tree.HasSpan("workflowPhase"), "workflowPhase span must exist")

			// Verify new controller spans exist
			assert.True(t, tree.HasSpan("createWorkflowPod"), "createWorkflowPod span must exist")
			assert.True(t, tree.HasSpan("persistUpdates"), "persistUpdates span must exist")
			assert.True(t, tree.HasSpan("podReconciliation"), "podReconciliation span must exist")

			// Verify createWorkflowPod has NodeID attribute
			createPodSpans := tree.FindAllByName("createWorkflowPod")
			require.NotEmpty(t, createPodSpans, "should have createWorkflowPod spans")
			for _, span := range createPodSpans {
				_, hasNodeID := span.GetAttribute(telemetry.AttribNodeID)
				assert.True(t, hasNodeID, "createWorkflowPod should have NodeID attribute")
			}

			// Verify workflow span attributes
			assertWorkflowAttribs(t, workflowSpan, metadata.Name, metadata.Namespace, "workflow")

			// Verify node span attributes
			nodeSpans := tree.FindAllByName("node")
			require.NotEmpty(t, nodeSpans, "should have node spans")
			for _, nodeSpan := range nodeSpans {
				_, hasNodeID := nodeSpan.GetAttribute(telemetry.AttribNodeID)
				assert.True(t, hasNodeID, "node span should have NodeID attribute")
				assertWorkflowAttribs(t, nodeSpan, metadata.Name, metadata.Namespace, "node")
				val, hasNodeType := nodeSpan.GetAttribute(telemetry.AttribNodeType)
				assert.True(t, hasNodeType, "node span should have NodeType attribute")
				assert.NotEmpty(t, val, "NodeType should not be empty")
			}

			// Verify runInitContainer span attributes
			runInitContainerSpans := tree.FindAllByName("runInitContainer")
			assert.Len(t, runInitContainerSpans, 1)
			for _, span := range runInitContainerSpans {
				assertWorkflowAttribs(t, span, metadata.Name, metadata.Namespace, "runInitContainer")
			}

			// Verify runWaitContainer span attributes
			runWaitContainerSpans := tree.FindAllByName("runWaitContainer")
			assert.Len(t, runWaitContainerSpans, 1)
			for _, span := range runWaitContainerSpans {
				assertWorkflowAttribs(t, span, metadata.Name, metadata.Namespace, "runWaitContainer")
			}

			// Verify leaf spans that should exist for basic workflow
			// These are leaf spans (no children) that appear in every workflow
			basicLeafSpans := []string{
				"workflowPhase",       // workflow phase changes
				"persistUpdates",      // persisting status updates
				"podReconciliation",   // reconciling pod status
				"nodePhase",           // node phase changes
				"waitWorkload",        // waiting for workload completion
				"createTaskResult",    // creating task result
				"patchTaskResult",     // patching task result
				"reconcileTaskResult", // reconciling task results
			}
			for _, spanName := range basicLeafSpans {
				assert.True(t, tree.HasSpan(spanName), "%s leaf span must exist", spanName)
			}
		})
}

// TestWorkflowTracingWithArtifacts tests tracing for a workflow with artifact passing.
// This exercises both init container (loadArtifacts) and wait container (saveArtifacts) spans.
func (s *TracingSuite) TestWorkflowTracingWithArtifacts() {
	var wfTraceID string
	s.Given().
		Workflow(`@testdata/workflow-tracing.yaml`).
		When().
		SubmitWorkflow().
		WaitForWorkflow(fixtures.ToBeSucceeded, 90*time.Second).
		Then().
		ExpectWorkflow(func(t *testing.T, metadata *metav1.ObjectMeta, status *wfv1.WorkflowStatus) {
			assert.Equal(t, wfv1.WorkflowSucceeded, status.Phase)
			assert.GreaterOrEqual(t, len(status.Nodes), 3, "Should have at least 3 nodes (main + generate + consume)")

			ctx := t.Context()
			workflowSpan, _, err := s.collector.WaitForWorkflowSpan(ctx, 10*time.Second)
			require.NoError(t, err, "Should receive workflow span from controller")
			require.NotNil(t, workflowSpan, "workflow span must exist")

			traceSpans, _ := s.collector.GetSpansByTraceID(ctx, workflowSpan.TraceID)
			tree := fixtures.BuildSpanTree(traceSpans)
			t.Logf("Collected %d spans for workflow %s", len(traceSpans), metadata.Name)
			t.Log(tree.PrintTree())

			// Verify workflow is root span
			assert.False(t, workflowSpan.HasParent(), "workflow should be root span")

			// Verify all spans conform to expected hierarchy
			hierarchyErrors := tree.VerifyWorkflowHierarchy()
			if hierarchyErrors != nil {
				t.Logf("Hierarchy violations:\n%s", hierarchyErrors.Error())
				t.Logf("Span tree:\n%s", tree.PrintTree())
			}
			require.NoError(t, hierarchyErrors, "all spans should conform to expected hierarchy")

			// Verify expected spans exist for artifact workflow
			assert.True(t, tree.HasSpan("saveArtifacts"), "saveArtifacts span must exist (wait container)")
			assert.True(t, tree.HasSpan("saveArtifact"), "saveArtifact span must exist")
			assert.True(t, tree.HasSpan("loadArtifacts"), "loadArtifacts span must exist (init container)")
			assert.True(t, tree.HasSpan("loadArtifact"), "loadArtifact span must exist")

			// Verify artifact-specific leaf spans
			artifactLeafSpans := []string{
				"archiveArtifact",   // archiving artifact before upload
				"unarchiveArtifact", // unarchiving artifact after download
			}
			for _, spanName := range artifactLeafSpans {
				assert.True(t, tree.HasSpan(spanName), "%s leaf span must exist for artifact workflow", spanName)
			}

			// Verify workflow annotation contains a valid (non-zero) trace ID
			wfTraceID = metadata.Annotations[common.AnnotationKeyTraceID]
			assert.True(t, isValidID(wfTraceID),
				"workflow annotation %s should be a valid non-zero trace ID, got %q", common.AnnotationKeyTraceID, wfTraceID)

			// Verify the annotation trace ID matches the collected workflow span
			assert.Equal(t, workflowSpan.TraceID, wfTraceID,
				"workflow annotation trace ID should match the collected workflow span trace ID")
		}).
		ExpectPods(func(t *testing.T, pods []apiv1.Pod) {
			require.GreaterOrEqual(t, len(pods), 2, "artifact workflow should have at least 2 pods (generate + consume)")
			seenSpanIDs := make(map[string]string) // spanID -> pod name
			for _, pod := range pods {
				podTraceID := pod.Annotations[common.AnnotationKeyTraceID]
				podSpanID := pod.Annotations[common.AnnotationKeySpanID]
				assert.True(t, isValidID(podTraceID),
					"pod %s annotation %s should be a valid non-zero trace ID, got %q", pod.Name, common.AnnotationKeyTraceID, podTraceID)
				assert.True(t, isValidID(podSpanID),
					"pod %s annotation %s should be a valid non-zero span ID, got %q", pod.Name, common.AnnotationKeySpanID, podSpanID)

				// All pods must share the same trace ID as the workflow
				assert.Equal(t, wfTraceID, podTraceID,
					"pod %s trace ID should match workflow trace ID", pod.Name)

				// Each pod must have a unique span ID
				if otherPod, exists := seenSpanIDs[podSpanID]; exists {
					t.Errorf("pod %s has the same span ID %q as pod %s; span IDs must be unique per pod", pod.Name, podSpanID, otherPod)
				}
				seenSpanIDs[podSpanID] = pod.Name
			}
		})
}

// TestOtelCliTraceContext verifies that user workloads can participate in the trace
// using otel-cli. The TRACEPARENT env var is injected by the executor, allowing
// otel-cli spans to be children of runMainContainer spans.
func (s *TracingSuite) TestOtelCliTraceContext() {
	s.Given().
		Workflow(`@testdata/workflow-otel-cli.yaml`).
		When().
		SubmitWorkflow().
		WaitForWorkflow(fixtures.ToBeSucceeded, 120*time.Second).
		Then().
		ExpectWorkflow(func(t *testing.T, metadata *metav1.ObjectMeta, status *wfv1.WorkflowStatus) {
			assert.Equal(t, wfv1.WorkflowSucceeded, status.Phase)

			ctx := t.Context()
			// Wait for spans to be collected (otel-cli spans may take a moment)
			time.Sleep(5 * time.Second)

			spans, err := s.collector.GetSpans(ctx)
			require.NoError(t, err, "Should get spans from collector")

			// Find the workflow span
			workflowSpan := findLastWorkflowSpan(spans)
			require.NotNil(t, workflowSpan, "workflow span must exist")

			// Build a map of runMainContainer spans by spanID
			runMainContainerSpans := make(map[string]*fixtures.CollectedSpan)
			for i := range spans {
				if spans[i].Name == "runMainContainer" {
					runMainContainerSpans[spans[i].SpanID] = &spans[i]
				}
			}
			require.GreaterOrEqual(t, len(runMainContainerSpans), 2, "Should have at least 2 runMainContainer spans (one per step)")

			// Find otel-cli spans
			var otelCliSpans []fixtures.CollectedSpan
			for _, span := range spans {
				if span.Name == "user-operation-1" || span.Name == "user-operation-2" {
					otelCliSpans = append(otelCliSpans, span)
				}
			}
			require.Len(t, otelCliSpans, 2, "Should have 2 otel-cli spans (user-operation-1 and user-operation-2)")

			// Verify otel-cli spans share the same trace ID as the workflow
			for _, span := range otelCliSpans {
				assert.Equal(t, workflowSpan.TraceID, span.TraceID,
					"otel-cli span %q should share trace ID with workflow", span.Name)
			}

			// Verify each otel-cli span is a child of a runMainContainer span
			for _, span := range otelCliSpans {
				_, exists := runMainContainerSpans[span.ParentSpanID]
				assert.True(t, exists,
					"otel-cli span %q should be a child of a runMainContainer span (parentID=%s)", span.Name, span.ParentSpanID)
			}

			// Verify runMainContainer span attributes
			for _, span := range runMainContainerSpans {
				assertWorkflowAttribs(t, span, metadata.Name, metadata.Namespace, "runMainContainer")
			}
		})
}

// TestScriptTemplateTracing tests tracing for a workflow with a script template.
// This exercises stageFiles and captureScriptResult spans.
func (s *TracingSuite) TestScriptTemplateTracing() {
	s.Given().
		Workflow(`@testdata/workflow-script-tracing.yaml`).
		When().
		SubmitWorkflow().
		WaitForWorkflow(fixtures.ToBeSucceeded).
		Then().
		ExpectWorkflow(func(t *testing.T, metadata *metav1.ObjectMeta, status *wfv1.WorkflowStatus) {
			assert.Equal(t, wfv1.WorkflowSucceeded, status.Phase)

			ctx := t.Context()
			workflowSpan, _, err := s.collector.WaitForWorkflowSpan(ctx, 10*time.Second)
			require.NoError(t, err, "Should receive workflow span from controller")
			require.NotNil(t, workflowSpan, "workflow span must exist")

			traceSpans, _ := s.collector.GetSpansByTraceID(ctx, workflowSpan.TraceID)
			tree := fixtures.BuildSpanTree(traceSpans)
			t.Logf("Collected %d spans for workflow %s", len(traceSpans), metadata.Name)
			t.Log(tree.PrintTree())

			// Verify hierarchy is valid
			hierarchyErrors := tree.VerifyWorkflowHierarchy()
			if hierarchyErrors != nil {
				t.Logf("Hierarchy violations:\n%s", hierarchyErrors.Error())
			}
			require.NoError(t, hierarchyErrors, "all spans should conform to expected hierarchy")

			// Verify script-specific spans exist
			assert.True(t, tree.HasSpan("stageFiles"), "stageFiles span must exist for script template")
			assert.True(t, tree.HasSpan("captureScriptResult"), "captureScriptResult span must exist for script template")

			// Verify script-specific leaf spans
			scriptLeafSpans := []string{
				"stageFiles",          // staging script source file
				"captureScriptResult", // capturing script output
			}
			for _, spanName := range scriptLeafSpans {
				assert.True(t, tree.HasSpan(spanName), "%s leaf span must exist", spanName)
			}
		})
}

// TestArchiveLogsTracing tests tracing for a workflow with archiveLogs enabled.
// This exercises the saveLogs and saveContainerLogs spans.
func (s *TracingSuite) TestArchiveLogsTracing() {
	s.Given().
		Workflow(`@testdata/workflow-archive-logs-tracing.yaml`).
		When().
		SubmitWorkflow().
		WaitForWorkflow(fixtures.ToBeSucceeded).
		Then().
		ExpectWorkflow(func(t *testing.T, metadata *metav1.ObjectMeta, status *wfv1.WorkflowStatus) {
			assert.Equal(t, wfv1.WorkflowSucceeded, status.Phase)

			ctx := t.Context()
			workflowSpan, _, err := s.collector.WaitForWorkflowSpan(ctx, 10*time.Second)
			require.NoError(t, err, "Should receive workflow span from controller")
			require.NotNil(t, workflowSpan, "workflow span must exist")

			traceSpans, _ := s.collector.GetSpansByTraceID(ctx, workflowSpan.TraceID)
			tree := fixtures.BuildSpanTree(traceSpans)
			t.Logf("Collected %d spans for workflow %s", len(traceSpans), metadata.Name)
			t.Log(tree.PrintTree())

			// Verify hierarchy is valid
			hierarchyErrors := tree.VerifyWorkflowHierarchy()
			if hierarchyErrors != nil {
				t.Logf("Hierarchy violations:\n%s", hierarchyErrors.Error())
			}
			require.NoError(t, hierarchyErrors, "all spans should conform to expected hierarchy")

			// Verify log archiving spans exist
			assert.True(t, tree.HasSpan("saveLogs"), "saveLogs span must exist when archiveLogs is enabled")
			require.True(t, tree.HasSpan("saveContainerLogs"), "saveContainerLogs span must exist")

			// Verify saveContainerLogs has ContainerName attribute
			saveContainerLogsSpans := tree.FindAllByName("saveContainerLogs")
			require.NotEmpty(t, saveContainerLogsSpans, "should have saveContainerLogs spans")
			for _, span := range saveContainerLogsSpans {
				containerName, hasName := span.GetAttribute(telemetry.AttribContainerName)
				assert.True(t, hasName, "saveContainerLogs should have %s attribute, got attributes: %v", telemetry.AttribContainerName, span.Attributes)
				assert.Equal(t, "main", containerName, "ContainerName should be 'main'")
			}
		})
}

// TestSynchronizationTracing tests tracing for a workflow with synchronization.
// This exercises the tryAcquireLock span with its attributes.
func (s *TracingSuite) TestSynchronizationTracing() {
	s.Given().
		Workflow(`@testdata/workflow-sync-tracing.yaml`).
		When().
		SubmitWorkflow().
		WaitForWorkflow(fixtures.ToBeSucceeded).
		Then().
		ExpectWorkflow(func(t *testing.T, metadata *metav1.ObjectMeta, status *wfv1.WorkflowStatus) {
			assert.Equal(t, wfv1.WorkflowSucceeded, status.Phase)

			ctx := t.Context()
			workflowSpan, _, err := s.collector.WaitForWorkflowSpan(ctx, 10*time.Second)
			require.NoError(t, err, "Should receive workflow span from controller")
			require.NotNil(t, workflowSpan, "workflow span must exist")

			traceSpans, _ := s.collector.GetSpansByTraceID(ctx, workflowSpan.TraceID)
			tree := fixtures.BuildSpanTree(traceSpans)
			t.Logf("Collected %d spans for workflow %s", len(traceSpans), metadata.Name)
			t.Log(tree.PrintTree())

			// Verify hierarchy is valid
			hierarchyErrors := tree.VerifyWorkflowHierarchy()
			if hierarchyErrors != nil {
				t.Logf("Hierarchy violations:\n%s", hierarchyErrors.Error())
			}
			require.NoError(t, hierarchyErrors, "all spans should conform to expected hierarchy")

			// Verify lock span exists with proper attributes
			assert.True(t, tree.HasSpan("tryAcquireLock"), "tryAcquireLock span must exist")
			lockSpans := tree.FindAllByName("tryAcquireLock")
			require.NotEmpty(t, lockSpans, "should have tryAcquireLock spans")
			for _, span := range lockSpans {
				_, hasName := span.GetAttribute(telemetry.AttribLockName)
				assert.True(t, hasName, "tryAcquireLock should have LockName attribute")
				_, hasAcquired := span.GetAttribute(telemetry.AttribLockAcquired)
				assert.True(t, hasAcquired, "tryAcquireLock should have LockAcquired attribute")
			}
		})
}

// TestDataTemplateTracing tests tracing for a workflow with a data template.
// This exercises the processDataTemplate span under runMainContainer.
func (s *TracingSuite) TestDataTemplateTracing() {
	s.Given().
		Workflow(`@testdata/workflow-data-tracing.yaml`).
		When().
		SubmitWorkflow().
		WaitForWorkflow(fixtures.ToBeSucceeded, 90*time.Second).
		Then().
		ExpectWorkflow(func(t *testing.T, metadata *metav1.ObjectMeta, status *wfv1.WorkflowStatus) {
			assert.Equal(t, wfv1.WorkflowSucceeded, status.Phase)

			ctx := t.Context()
			workflowSpan, _, err := s.collector.WaitForWorkflowSpan(ctx, 10*time.Second)
			require.NoError(t, err, "Should receive workflow span from controller")
			require.NotNil(t, workflowSpan, "workflow span must exist")

			traceSpans, _ := s.collector.GetSpansByTraceID(ctx, workflowSpan.TraceID)
			tree := fixtures.BuildSpanTree(traceSpans)
			t.Logf("Collected %d spans for workflow %s", len(traceSpans), metadata.Name)
			t.Log(tree.PrintTree())

			// Verify hierarchy is valid
			hierarchyErrors := tree.VerifyWorkflowHierarchy()
			if hierarchyErrors != nil {
				t.Logf("Hierarchy violations:\n%s", hierarchyErrors.Error())
			}
			require.NoError(t, hierarchyErrors, "all spans should conform to expected hierarchy")

			// Verify data template span exists
			assert.True(t, tree.HasSpan("processDataTemplate"), "processDataTemplate span must exist for data template")

			// Verify the data template node produced a result
			transformNode := status.Nodes.FindByDisplayName("transform")
			require.NotNil(t, transformNode, "transform node should exist")
			require.NotNil(t, transformNode.Outputs, "transform node should have outputs")
			require.NotNil(t, transformNode.Outputs.Result, "transform node should have a result")
		})
}

// TestNodeSynchronizationTracing tests tracing for a workflow with template-level synchronization.
// Even though the sync is on the template, tryAcquireLock appears under workflow because
// the lock is checked in executeTemplate before the node span is created.
func (s *TracingSuite) TestNodeSynchronizationTracing() {
	s.Given().
		Workflow(`@testdata/workflow-node-sync-tracing.yaml`).
		When().
		SubmitWorkflow().
		WaitForWorkflow(fixtures.ToBeSucceeded).
		Then().
		ExpectWorkflow(func(t *testing.T, metadata *metav1.ObjectMeta, status *wfv1.WorkflowStatus) {
			assert.Equal(t, wfv1.WorkflowSucceeded, status.Phase)

			ctx := t.Context()
			workflowSpan, _, err := s.collector.WaitForWorkflowSpan(ctx, 10*time.Second)
			require.NoError(t, err, "Should receive workflow span from controller")
			require.NotNil(t, workflowSpan, "workflow span must exist")

			traceSpans, _ := s.collector.GetSpansByTraceID(ctx, workflowSpan.TraceID)
			tree := fixtures.BuildSpanTree(traceSpans)
			t.Logf("Collected %d spans for workflow %s", len(traceSpans), metadata.Name)
			t.Log(tree.PrintTree())

			// Verify hierarchy is valid
			hierarchyErrors := tree.VerifyWorkflowHierarchy()
			if hierarchyErrors != nil {
				t.Logf("Hierarchy violations:\n%s", hierarchyErrors.Error())
			}
			require.NoError(t, hierarchyErrors, "all spans should conform to expected hierarchy")

			// Verify lock span exists with proper attributes
			assert.True(t, tree.HasSpan("tryAcquireLock"), "tryAcquireLock span must exist")
			lockSpans := tree.FindAllByName("tryAcquireLock")
			require.NotEmpty(t, lockSpans, "should have tryAcquireLock spans")
			for _, span := range lockSpans {
				_, hasName := span.GetAttribute(telemetry.AttribLockName)
				assert.True(t, hasName, "tryAcquireLock should have LockName attribute")
				_, hasAcquired := span.GetAttribute(telemetry.AttribLockAcquired)
				assert.True(t, hasAcquired, "tryAcquireLock should have LockAcquired attribute")
			}
		})
}

func TestTracingSuite(t *testing.T) {
	suite.Run(t, new(TracingSuite))
}
